from __future__ import annotations

import json
from typing import Any

import structlog
from aibots.models import RAGConfig
from atlas.asgi.exceptions import AtlasAPIException
from atlas.asgi.schemas import APIGet, AtlasASGIConfig
from atlas.fastapi import AtlasDependencies, AtlasRouters
from atlas.schemas import UserLogin, Uuid
from beanie.operators import In
from fastapi import APIRouter, Depends, Query, Response, status
from fastapi_utils.cbv import cbv

from agents.models import AgentDB, KnowledgeBaseDB, RAGConfigDB

from .base import AgentsAPIMixin, RAGConfigPost

__doc__ = """
Contains all the API calls for the KnowledgeBases API

Attributes:
    router (APIRouter): KnowledgeBases API Router
"""


__all__ = ("router",)


router: APIRouter = AtlasRouters.atlas_get_router(
    prefix="",
    tags=["Agents"],
    dependencies=[
        Depends(AtlasDependencies.get_registry_item("reject_api_key"))
    ],
)


class RAGConfigGet(APIGet, RAGConfig):
    """
    GET representation of a RAG Config

    Attributes:
        id (Uuid): UUID string, autogenerated
        type (str): RAG pipeline type, one of the supported
                    RAG pipelines
        config (dict[str, Any]): RAG pipeline configuration, defaults
                                 to an empty dictionary
        agent (Uuid | None): ID of associated Agent, defaults to None
        retrieval (dict[str, Any]): Retrieval details, defaults to an
                                    empty dictionary
        timestamp (datetime): Timestamp when RAG pipeline config was
                              created, defaults to the current datetime
    """


# TODO: Restrict Agents to those with permissions granted
@cbv(router)
class RAGConfigsAPI(AgentsAPIMixin):
    """
    Class-based view for representing the RAGConfigs API

    Attributes:
        user (UserLogin): Authenticated user details
        atlas (AtlasASGIConfig): Atlas Config class
        environ (AIBotsAgentEnviron): Environment variables
        messages (M): Message class
        db (BeanieService): MongoDB Service
        knowledge_bases (BeanieDataset): knowledge_bases Dataset
        agents (BeanieDataset): agents Dataset
        logger (StructLogService): Logging Service
    """

    user: UserLogin = Depends(
        AtlasDependencies.get_registry_item("auth_session")
    )
    atlas: AtlasASGIConfig = Depends(
        AtlasDependencies.get_registry_item("get_atlas")
    )

    @router.post(
        "/agents/{agent_id}/rags/",
        response_model=list[RAGConfigGet],
        response_model_exclude={"__all__": {"retrieval"}},
        status_code=status.HTTP_201_CREATED,
        include_in_schema=False,
    )
    @router.post(
        "/agents/{agent_id}/rags",
        response_model=list[RAGConfigGet],
        status_code=status.HTTP_201_CREATED,
        responses={
            **AtlasRouters.response("created_response"),
            **AtlasRouters.response("400_invalid_parameters_error"),
        },
        response_model_exclude={"__all__": {"retrieval"}},
    )
    async def create_rag_configs(
        self,
        agent_id: Uuid,
        details: list[RAGConfigPost],
    ) -> list[dict[str, Any]]:
        """
        Creates new RAG Configs

        Args:
            agent_id (Uuid): ID of the Agent
            details (
                list[RAGConfigPost]
            ): Details for creating RAG Configs

        Returns:
            list[dict[str, Any]]: Generated RAG Configs
        """
        logger: structlog.typing.FilteringBoundLogger = (
            self.logger.get_structlog_logger(self.atlas.environ.loggers["api"])
        )

        agent: AgentDB = await self.atlas_get_agent(agent_id)

        # Validate RAG Configs and generate RAG Configs
        try:
            self.atlas_validate_rag_configs(details)
        except AtlasAPIException as e:
            raise AtlasAPIException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message=e.message,
                details=e.details,
            ) from e
        rag_configs: list[RAGConfigDB] = self.atlas_create_rag_configs(
            details, agent.id
        )

        # Insert into Database
        await logger.ainfo(
            self.messages.api_rag_configs_create_fmt.format(
                [r for r in rag_configs]  # noqa: C416
            ),
            data=json.dumps([r.model_dump(mode="json") for r in rag_configs]),
        )
        if not await self.rag_configs.create_items(rag_configs):
            raise AtlasAPIException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                message=self.messages.api_rag_configs_create_error_msg,
                details={
                    "rags": [
                        r.model_dump(mode="json", exclude_unset=True)
                        for r in details
                    ]
                },
            )

        # Extending Agent with new Knowledge Bases
        updated: AgentDB = agent.update_schema(
            user=self.user.id,
            version=agent.meta.version + 1,
            **{"rags": agent.rags + [r.id for r in rag_configs]},
        )
        await logger.ainfo(
            self.messages.api_rag_configs_update_agent_fmt.format(
                [r.id for r in rag_configs],  # noqa: C416
                agent.id,
            ),
            data=updated.model_dump_json(),
        )
        if not await self.agents.replace_item(updated):
            raise AtlasAPIException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                message=self.messages.api_agents_update_error_msg,
            )

        return [r.model_dump() for r in rag_configs]

    @router.get(
        "/agents/{agent_id}/rags/",
        status_code=status.HTTP_200_OK,
        include_in_schema=False,
        response_model=list[RAGConfigGet],
        response_model_exclude={"__all__": {"retrieval"}},
    )
    @router.get(
        "/agents/{agent_id}/rags",
        status_code=status.HTTP_200_OK,
        response_model=list[RAGConfigGet],
        response_model_exclude={"__all__": {"retrieval"}},
    )
    async def get_rag_configs(
        self,
        agent_id: Uuid,
    ) -> list[dict[str, Any]]:
        """
        Retrieves all RAG Configs associated with an Agent

        Args:
            agent_id (list[Uuid]): Agent ID

        Returns:
            list[dict[str, Any]]: Collection of RAG Configs
        """
        await self.atlas_get_agent(agent_id)
        return [
            i.model_dump()
            for i in await self.rag_configs.get_items(
                RAGConfigDB.agent == agent_id
            )
        ]

    @router.delete(
        "/agents/{agent_id}/rags/",
        status_code=status.HTTP_204_NO_CONTENT,
        include_in_schema=False,
    )
    @router.delete(
        "/agents/{agent_id}/rags",
        status_code=status.HTTP_204_NO_CONTENT,
        responses={
            **AtlasRouters.response("deleted_response"),
            **AtlasRouters.response("404_not_found_error"),
            **AtlasRouters.response("422_invalid_deletion_error"),
        },
    )
    async def delete_rag_configs(
        self,
        response: Response,
        agent_id: Uuid,
        ids: list[Uuid] = Query([]),
    ) -> Response:
        """
        Deletes all the RAG Configs given in the list of IDs

        Args:
            response (Response): FastAPI Response
            agent_id (list[Uuid]): Agent ID
            ids (list[Uuid]): IDs of RAG Configs to be deleted,
                              defaults to an empty list

        Returns:
            Response: FastAPI Response

        Raises:
            AtlasAPIException: If duplicate IDs are found in
                               deletion list
            AtlasAPIException: If some of the RAG Configs
                               could not be retrieved
        """
        logger: structlog.typing.FilteringBoundLogger = (
            self.logger.get_structlog_logger(self.environ.loggers["api"])
        )

        agent: AgentDB = await self.atlas_get_agent(agent_id)

        # TODO: Prevent deletion of RAG Configs if pipeline is running

        if ids:
            # Check that all IDs exist
            if invalid_ids := set(ids) - set(agent.rags):
                raise AtlasAPIException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    message=self.messages.api_rag_configs_not_found_error_msg,
                    details={"ids": list(invalid_ids)},
                )
        else:
            # Default to the entire agent's collection
            ids = agent.rags

        # Prevent deletion of default pipeline
        if (
            agent.default_pipeline is not None
            and agent.default_pipeline in ids
        ):
            raise AtlasAPIException(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                message=self.messages.api_rag_configs_deleting_default_pipeline_error_msg,
                details={"ids": ids},
            )

        # Retrieve list of associated
        # knowledge bases and RAG Configs
        knowledge_bases: list[
            KnowledgeBaseDB
        ] = await self.atlas_get_knowledge_bases(agent_id)
        rag_configs: list[RAGConfigDB] = await self.rag_configs.get_items(
            In(RAGConfigDB.id, ids)
        )

        # Clear all associated embeddings
        try:
            await self.atlas_delete_knowledge_base_embeddings(
                agent,
                rag_configs,
                knowledge_bases,
                logger,
            )
        except AtlasAPIException:
            raise

        # Updating Agent details
        updated: AgentDB = agent.update_schema(
            user=self.user.id,
            version=agent.meta.version + 1,
            **{
                "rags": [
                    rag_config
                    for rag_config in agent.rags
                    if rag_config not in [r.id for r in rag_configs]
                ]
            },
        )
        await logger.ainfo(
            self.messages.api_rag_configs_update_agent_fmt.format(
                updated.id, [r.id for r in rag_configs]
            ),
            data=updated.model_dump_json(),
        )
        if not await self.agents.replace_item(updated):
            raise AtlasAPIException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                message=self.messages.api_agents_update_error_msg,
            )

        # Deletes Knowledge Bases
        await logger.ainfo(
            self.messages.api_rag_configs_delete_fmt.format(
                [k.id for k in rag_configs]
            )
        )

        if not await self.rag_configs.delete_items(In(RAGConfigDB.id, ids)):
            raise AtlasAPIException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                message=self.messages.api_rag_configs_delete_error_msg,
            )

        response.status_code = status.HTTP_204_NO_CONTENT
        return response
