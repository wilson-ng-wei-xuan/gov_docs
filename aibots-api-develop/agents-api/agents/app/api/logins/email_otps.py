from __future__ import annotations

import json
from datetime import datetime, timedelta, timezone
from typing import Annotated, Any, Optional

import httpx
import structlog
from atlas.asgi.exceptions import AtlasAPIException
from atlas.asgi.schemas import APIGet, APIPostPut, AtlasASGIConfig
from atlas.fastapi import AtlasDependencies, AtlasRouters
from atlas.httpx import HttpxService
from atlas.schemas import (
    Email,
    Otp,
    UserLogin,
    Uuid,
)
from atlas.services import DS
from fastapi import APIRouter, Depends, Response, status
from fastapi.responses import JSONResponse
from fastapi_utils.cbv import cbv
from fastapi_versionizer import api_version
from pydantic import AfterValidator, EmailStr

from agents.mixins.uam import LoginsAPIMixin
from agents.models import (
    OtpDB,
    RoleDB,
    ScimGroupDB,
    ScimUserDB,
    UserLoginGet,
)

__all__ = ("router",)


router: APIRouter = AtlasRouters.atlas_get_router(
    **{
        "tags": ["Logins"],
        "prefix": "",
        "dependencies": [
            Depends(AtlasDependencies.get_registry_item("reject_api_key"))
        ],
        "responses": {
            **AtlasRouters.response("500_internal_server_error"),
        },
    }
)


class OtpEmail(APIPostPut):
    """
    Email OTP POST schema

    Attributes:
        email (EmailStr): Email to send the OTP to
        otp (Optional[str]): OTP details
    """

    email: Annotated[EmailStr, AfterValidator(lambda v: v.lower())]
    otp: Optional[str] = None


class OtpGet(APIGet, Otp):
    """
    REST representation of an OTP

    Attributes:
        id (Uuid): UUID of the Otp, autogenerated, inherited
        user (Uuid): UUID of the User
        email (EmailStr): Email of the User
        otp (str): OTP details, defaults to a randomly
                   generated otp string
        timestamp (datetime): Datetime OTP generated, defaults
                              to the current datetime
        expiry (datetime): Expiry datetime of the OTP
    """


# TODO: Use Christis messages
@cbv(router)
class EmailOtpAPI(LoginsAPIMixin):
    """
    Class-based view for representing the POST APIs of
    authentication with Email OTPs

    Attributes
        atlas (AtlasConfig): Atlas API config
        environ (AIBotsEnviron): Environment variables
        db (BeanieService): MongoDB Service
        jwt (JoseService): JWT Service
        otps (DS): OTPs Dataset
        roles (DS): Roles Dataset
        users (DS): Users Dataset
        logins (DS): User Login Dataset
        logger (StructLogService): Atlas logger
    """

    atlas: AtlasASGIConfig = Depends(
        AtlasDependencies.get_registry_item("get_atlas")
    )

    # TODO: Request details to be extracted and bound to logger
    def __init__(self):
        super().__init__()
        self.rest: HttpxService = self.atlas.rest
        self.otps: DS = self.atlas.otps

    @router.post(
        "/otp/emails/",
        status_code=status.HTTP_201_CREATED,
        include_in_schema=False,
    )
    @router.post(
        "/otp/emails",
        status_code=status.HTTP_201_CREATED,
        responses={
            **AtlasRouters.response("triggered_response"),
            **AtlasRouters.response("400_invalid_parameters_error"),
        },
    )
    @api_version(1, 0)
    async def create_email_otp(
        self, email: OtpEmail, response: Response
    ) -> Response:
        """
        Sends an email OTP and caches it temporarily

        Args:
            email (OtpEmail): Email OTP details
            response (Response): FastAPI Response

        Returns:
            Response: FastAPI Response
        """
        logger: structlog.typing.FilteringBoundLogger = (
            self.logger.get_structlog_logger(self.environ.loggers["api"])
        )

        # Perform validation checks
        if email.otp is not None:
            raise AtlasAPIException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="Unsupported field",
            )

        # Check that only allowed government agencies can retrieve the OTP
        group: Optional[ScimGroupDB] = await self.groups.get_item(
            ScimGroupDB.atlas_extensions.domain
            == Email.atlas_get_domain(email.email),
            ScimGroupDB.atlas_extensions.allow == True,  # noqa: E712
            ScimGroupDB.meta.deleted == None,  # noqa: E711
        )
        # TODO: Add techpass integration
        if not group:
            raise AtlasAPIException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                message="Unauthorised email domain",
                details=email.model_dump(exclude_unset=True, mode="json"),
            )

        # Invalidate existing email OTPs
        user_id: Uuid = ScimUserDB.atlas_get_uuid(email.email)
        await self.otps.delete_item(OtpDB.user == user_id)

        # Create an OTP
        otp: OtpDB = OtpDB(
            user=user_id,
            email=email.email,
            expiry=datetime.now(timezone.utc)
            + timedelta(minutes=self.environ.expiry.otp),
        )

        # TODO: Generalise Leon's SMTP component
        # TODO: Generalise email sending as a mixin
        # Send Email OTP
        await logger.ainfo(f"Sending email OTP to {otp.email}")
        if self.environ.use_aws:
            auth: dict[str, Any] = json.loads(self.environ.emails_api.auth)
            email: dict[str, Any] = {
                **self.atlas.emails.prepare_email(
                    variables={
                        "name": Email.atlas_get_name(otp.email),
                        "otp": otp.otp,
                        "product": self.environ.name.capitalize(),
                        "domain": f"https://{auth['SMTP_FROM'].split('@')[1]}",
                        "duration": "{:.0f} minutes".format(
                            self.environ.expiry.otp
                        ),
                    },
                    **{"to": [otp.email], "sender": auth["SMTP_FROM"]},
                ).model_dump(),
                "smtp_key": auth,
                "sender_name": self.environ.email.name,
            }
            resp: httpx.Response = await self.rest.post(
                str(self.environ.emails_api.url),
                content=json.dumps(email).encode("utf-8"),
            )
            try:
                resp.raise_for_status()
            except (httpx.HTTPError, httpx.StreamError):
                raise AtlasAPIException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    message="Error when sending email OTP via Email "
                    "OTP service",
                    details=resp.json(),
                ) from None
        else:
            auth: dict[str, Any] = json.loads(self.environ.emails_api.auth)
            self.atlas.emails.atlas_send_email(
                variables={
                    "name": Email.atlas_get_name(otp.email),
                    "otp": otp.otp,
                    "product": self.environ.name.capitalize(),
                    "domain": self.environ.project.public_domain,
                    "duration": "{:.0f} minutes".format(
                        self.environ.expiry.otp
                    ),
                },
                **{"to": [otp.email], "sender": auth["SMTP_FROM"]},
            )

        # Insert into DB
        await logger.ainfo("Generated OTP", data=otp.model_dump_json())
        if not await self.otps.create_item(otp):
            raise AtlasAPIException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                message="Error creating Email OTP",
                details=email.model_dump(exclude_unset=True, mode="json"),
            )

        response.status_code = status.HTTP_201_CREATED
        return response

    @router.get(
        "/otp/emails/",
        status_code=status.HTTP_200_OK,
        response_model=list[OtpGet],
        include_in_schema=False,
    )
    @router.get(
        "/otp/emails",
        status_code=status.HTTP_200_OK,
        response_model=list[OtpGet],
        responses={
            status.HTTP_200_OK: {
                "description": "Successfully retrieved OTPs",
                "content": {"application/json": {"example": []}},
                "model": list[OtpGet],
            },
            **AtlasRouters.response("403_permissions_error"),
        },
    )
    @api_version(1, 0)
    async def get_email_otps(self) -> list[dict[str, Any]]:
        """
        Retrieves all email OTPs created

        Returns:
            Response: FastAPI Response
        """
        # TODO: Add permissions
        # TODO: Add filters based on user's role
        return [i.model_dump() for i in await self.otps.get_items({})]

    @router.post(
        "/otp/emails/logins/",
        status_code=status.HTTP_201_CREATED,
        include_in_schema=False,
    )
    @router.post(
        "/otp/emails/logins",
        status_code=status.HTTP_201_CREATED,
        responses={
            status.HTTP_201_CREATED: {
                "description": "Successfully logged a user in via Email OTP",
                "content": {"application/json": {"example": {}}},
                "model": UserLoginGet,
            },
            **AtlasRouters.response("401_authentication_error"),
        },
    )
    @api_version(1, 0)
    async def login_email_otp(self, email: OtpEmail) -> JSONResponse:
        """
        Authenticates users logging in via Email OTPs,
        registering new users in the process.

        Args:
            email (OtpEmail): Email OTP details

        Returns:
            Response: FastAPI Response
        """
        logger: structlog.typing.FilteringBoundLogger = (
            self.logger.get_structlog_logger(self.environ.loggers["api"])
        )

        # Check that OTP is provided
        if email.otp is None:
            raise AtlasAPIException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="No OTP provided",
                details=email.model_dump(exclude_unset=True, mode="json"),
            )

        # Check if OTP is valid:
        #   1. OTP must have been issued previously
        #   2. OTP email must match the email provided
        #   3. OTP must not have expired
        otp: Optional[OtpDB] = await self.otps.get_item(OtpDB.otp == email.otp)
        if not otp:
            raise AtlasAPIException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                message="OTP was not issued",
                details=email.model_dump(exclude_unset=True, mode="json"),
            )
        if otp.email != email.email:
            raise AtlasAPIException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                message="OTP issued does not match",
                details=email.model_dump(exclude_unset=True, mode="json"),
            )
        if otp.expiry < datetime.now(timezone.utc):
            raise AtlasAPIException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                message="OTP has expired",
                details=email.model_dump(exclude_unset=True, mode="json"),
            )

        # Check if user already exists
        # If user does not exist, check domain rules and create user
        user_role: RoleDB
        new_user: bool
        user: Optional[ScimUserDB] = await self.users.get_item_by_id(otp.user)
        if user:
            # 1. Validate if user is authorised
            # 2. Update a user's unverified state
            await self.atlas_block_unauthorised_user(user)
            await self.atlas_update_unverified_user(user)

            user_role = await self.roles.get_item_by_id(
                user.roles.primary.value
            )
            new_user = False
        else:
            group: ScimGroupDB = await self.atlas_block_unauthorised_group(
                email.email
            )
            user, user_role, permissions, group = await self.atlas_create_user(
                email=email.email,
                name=Email.atlas_get_name(email.email),
                username=email.email,
                group=group,
            )

            # Create a new user
            await logger.ainfo(
                f"Creating new user {user.emails.primary.value} with "
                f"role {user_role.name}",
                data=user.model_dump_json(),
            )
            if not await self.users.create_item(user):
                raise AtlasAPIException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    message="Error creating new user",
                )

            # Add their permission set
            await logger.ainfo(
                "Create user's permission set",
                data=permissions.model_dump_json(),
            )
            if not await self.permissions.create_item(permissions):
                raise AtlasAPIException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    message="Error creating user's permission set",
                )

            # Add the association to a new group
            await logger.ainfo(
                f"Adding user {user.emails.primary.value} "
                f"to group {group.display_name}",
            )
            if not await self.groups.replace_item(group):
                raise AtlasAPIException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    message="Error adding user to group",
                )
            new_user = True

        # Log user out and back in again
        await self.atlas_get_login(user)

        # Retrieve all individual and group permissions
        (
            user_permissions,
            all_permissions,
            group_permissions,
        ) = await self.atlas_get_all_user_permissions(user)

        # Login a user
        user_login: UserLogin = await self.atlas_login_user(
            all_permissions=all_permissions,
            group_permissions=group_permissions,
            user_permissions=user_permissions,
            error_details=email.model_dump(mode="json", exclude_unset=True),
            logger=logger,
            new_user=new_user,
            user=user,
            user_role=user_role,
        )

        # Clearing OTP so it cannot be reused
        if not await self.otps.delete_item_by_id(otp.id):
            raise AtlasAPIException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                message="Error deleting OTP",
                details=email.model_dump(exclude_unset=True, mode="json"),
            )

        return JSONResponse(
            status_code=status.HTTP_201_CREATED,
            content=UserLoginGet.model_construct(
                **user_login.model_dump()
            ).model_dump(mode="json", by_alias=True, exclude={"access_token"}),
            headers={"Authorization": f"Bearer {user_login.token}"},
        )
