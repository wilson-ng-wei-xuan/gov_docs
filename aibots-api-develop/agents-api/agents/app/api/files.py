from __future__ import annotations

from typing import Any

import structlog
from aibots.models import File
from atlas.asgi.exceptions import AtlasAPIException
from atlas.asgi.schemas import APIGet, APIPostPut, AtlasASGIConfig
from atlas.fastapi import AtlasDependencies, AtlasRouters
from atlas.schemas import Ownership, UserLogin, Uuid
from fastapi import APIRouter, Depends, Form, Response, UploadFile, status
from fastapi.responses import RedirectResponse, StreamingResponse
from fastapi_utils.cbv import cbv
from pydantic import AnyUrl, Json

from agents.mixins.files import FilesAPIMixin
from agents.models import FileDB

__all__ = ("router",)


router: APIRouter = AtlasRouters.atlas_get_router(
    **{
        "prefix": "",
        "tags": ["Files"],
        "dependencies": [
            Depends(AtlasDependencies.get_registry_item("reject_api_key"))
        ],
        "responses": {
            **AtlasRouters.response("401_authentication_error"),
            **AtlasRouters.response("403_permissions_error"),
            **AtlasRouters.response("500_internal_server_error"),
        },
    }
)


# TODO: Integrate this later
class FilePost(APIPostPut):
    """
    POST parameters for creating a file

    Attributes:
        version (str | int): Version of the file, defaults to 1
        folder (str): Virtual folder containing the file,
                      defaults to "/"
        ownership (Ownership | None): Ownership details of the file,
                                      defaults to None
        metadata (dict[str, Any]): Metadata associated with the file,
                                   defaults to an empty dict
    """

    version: str | int = 1
    folder: str = "/"
    ownership: Ownership | None = None
    metadata: dict[str, Any] = {}


class FileGet(APIGet, File):
    """
    Generic structure of a File stored in Atlas

    Attributes:
        id (Uuid): UUID string, autogenerated, inherited
        name (Optional[str]): Name field with no length restriction,
                                    defaults to None
        folder (str): Virtual folder name of the File, defaults to '/'
        versions (Union[int, str]): List of all uploaded versions of
                                    the File, defaults to [1]
        content (Optional[str]): Internal path link to the latest
                                 version of the file, defaults to None,
                                 excluded by FastAPI
        metadata (dict[str, Any]): Metadata associated with content,
                                   defaults to an empty dictionary
        ownership (Ownership): Ownership details of the file
        meta (Meta): Metadata associated with the resource,
                     defaults to the default Meta values
    """


@cbv(router)
class FilesAPI(FilesAPIMixin):
    """
    Class-based view for representing the Files APIs

    Attributes
        atlas (AtlasASGIConfig): Atlas API config
        environ (AppraiserEnviron): Environment variables
        db (BeanieService): MongoDB Service
        s3 (S3Service): S3 Service
        cf (CloudfrontService): Cloudfront Service
        files (DS): Files dataset
        logger (StructLogService): Atlas logger
    """

    user: UserLogin = Depends(
        AtlasDependencies.get_registry_item("auth_session")
    )
    atlas: AtlasASGIConfig = Depends(
        AtlasDependencies.get_registry_item("get_atlas")
    )

    @router.post(
        "/files/",
        status_code=status.HTTP_201_CREATED,
        response_model=list[FileGet],
        response_model_exclude={"__all__": {"content"}},
        response_model_by_alias=True,
        include_in_schema=False,
    )
    @router.post(
        "/files",
        status_code=status.HTTP_201_CREATED,
        response_model=list[FileGet],
        response_model_exclude={"__all__": {"content"}},
        response_model_by_alias=True,
        responses={
            **AtlasRouters.response("created_response"),
            **AtlasRouters.response("400_invalid_parameters_error"),
        },
    )
    async def upload_files(
        self, files: list[UploadFile], details: Json = Form({})
    ) -> list[dict[str, Any]]:
        """
        Uploads files to S3

        Args:
            files (list[UploadFile]): List of files to be uploaded
            details (Json): Metadata to be attached each file,
                            defaults to an empty dictionary

        Returns:
            list[dict[str, Any]]: Details of each File created
        """

        logger: structlog.typing.FilteringBoundLogger = (
            self.logger.get_structlog_logger(self.environ.loggers["api"])
        )

        # At least one file needs to be uploaded
        if not files:
            raise AtlasAPIException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="No files uploaded",
            )

        # Check that all files are properly formed i.e.
        # they have a name and contain information
        if not all(f.filename and f.size > 0 for f in files):
            raise AtlasAPIException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="Invalid file(s) uploaded",
            )

        to_upload: list[FileDB] = []

        for f in files:
            uid: Uuid = File.atlas_get_uuid()
            try:
                file: File = self.atlas_create_file(
                    details=details,
                    filename=f.filename,
                    filebytes=f.file,
                    content_type=f.content_type,
                    user=self.user.id,
                    uid=uid,
                )
                await logger.ainfo(
                    f"Uploading file {file.name} to S3",
                    data=file.model_dump(),
                )
                await self.atlas_upload_file(
                    file=file,
                    filebytes=f.file,
                )
                to_upload.append(FileDB.model_construct(**file.model_dump()))

            except Exception as e:
                logger.exception(
                    f"Error {e.__class__.__name__}.{str(e)} occurred when "
                    f"uploading file {uid} ({f.filename})"
                )
                continue

        # Insert Files into DB
        logger.info(
            f"Inserting files {[(file.id, file.name) for file in to_upload]} "
            f"into DB"
        )
        if to_upload and not await self.files.create_items(to_upload):
            raise AtlasAPIException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                message="Unable to upload files into the database",
            )

        return [i.model_dump() for i in to_upload]

    @router.get(
        "/files/{file_id}/",
        status_code=status.HTTP_200_OK,
        include_in_schema=False,
    )
    @router.get(
        "/files/{file_id}",
        status_code=status.HTTP_200_OK,
        responses={
            status.HTTP_200_OK: {
                "description": "Successfully downloaded file",
                "content": {"application/octet-stream": {}},
            },
            **AtlasRouters.response("404_not_found_error"),
        },
    )
    async def get_file(self, file_id: Uuid) -> StreamingResponse:
        """
        Retrieves the specified file

        Args:
            file_id (Uuid): ID of the file

        Returns:
            StreamingResponse: File response data

        Raises:
            AtlasAPIException: File does not exist
        """
        file: FileDB = await self.atlas_get_file(file_id)

        # TODO: Check if the user has access to the file

        return StreamingResponse(
            content=(await self.atlas_download_file(file))[1],
            status_code=status.HTTP_200_OK,
            media_type=file.metadata["content_type"],
        )

    @router.get(
        "/files/cdn/{file_id}/",
        status_code=status.HTTP_302_FOUND,
        include_in_schema=False,
    )
    @router.get(
        "/files/cdn/{file_id}",
        status_code=status.HTTP_302_FOUND,
        responses={
            status.HTTP_302_FOUND: {
                "description": "Redirect to signed Cloudfront URL",
                "url": {"format": AnyUrl},
            },
            **AtlasRouters.response("404_not_found_error"),
        },
    )
    async def get_files_by_cdn(self, file_id: Uuid) -> RedirectResponse:
        """
        Retrieves the specified file via signed CDN URL

        Args:
            file_id (Uuid): ID of the file

        Returns:
            RedirectResponse: Signed CDN URL

        Raises:
            AtlasAPIException: File does not exist
        """
        file: FileDB = await self.atlas_get_file(file_id)

        # TODO: Check if the user has access to the file

        signed_url = self.cf.atlas_generate_presigned_url(
            self.atlas_get_public_url(file.id, file.name)
        )

        return RedirectResponse(
            url=signed_url,
            status_code=status.HTTP_302_FOUND,
        )

    @router.delete(
        "/files/{file_id}/",
        status_code=status.HTTP_204_NO_CONTENT,
        include_in_schema=False,
    )
    @router.delete(
        "/files/{file_id}",
        status_code=status.HTTP_204_NO_CONTENT,
        responses={
            **AtlasRouters.response("deleted_response"),
            **AtlasRouters.response("404_not_found_error"),
        },
    )
    async def delete_file(self, file_id: Uuid, response: Response) -> Response:
        """
        Deletes an file

        Args:
            file_id (Uuid): ID of the file
            response (Response): FastAPI Response

        Returns:
            Response: FastAPI Response

        Raises:
            AtlasAPIException: File does not exist
        """

        logger: structlog.typing.FilteringBoundLogger = (
            self.logger.get_structlog_logger(self.environ.loggers["api"])
        )

        file: FileDB = await self.atlas_get_file(file_id)

        # TODO: Check if the user has delete rights to the file

        # Deletes the file from S3
        logger.info(f"Deleting file {file.content} from S3")
        self.s3.delete_object(Bucket=self.bucket, Key=file.content)

        logger.info(f"Deleting file {file.id} from DB")
        if not await self.files.delete_item_by_id(file.id):
            raise AtlasAPIException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                message="Error deleting file",
            )

        response.status_code = status.HTTP_204_NO_CONTENT
        return response

    @router.get(
        "/files/details/{file_id}/",
        status_code=status.HTTP_200_OK,
        response_model=FileGet,
        response_model_exclude={"content"},
        include_in_schema=False,
    )
    @router.get(
        "/files/details/{file_id}",
        status_code=status.HTTP_200_OK,
        response_model=FileGet,
        response_model_exclude={"content"},
        responses={
            status.HTTP_200_OK: {
                "description": "Successfully retrieved file details",
                "content": {"application/json": {"example": {}}},
                "model": FileGet,
            },
            **AtlasRouters.response("404_not_found_error"),
        },
    )
    async def get_file_details(self, file_id: Uuid) -> dict[str, Any]:
        """
        Retrieves the specified file

        Args:
            file_id (Uuid): ID of the file

        Returns:
            dict[str, Any]: File details

        Raises:
            AtlasAPIException: File does not exist
        """
        file: FileDB = await self.atlas_get_file(file_id)

        # TODO: Check if the user has access to the file

        return file.model_dump()
