import json
from copy import deepcopy
from typing import Optional, Any
from textwrap import dedent
from custom_agents.base import CustomAgent
from custom_agents.response_formatter_agent import ResponseFormatterAgent
from schema.recon import TagReconInfo
from schema.xss import XSSParamResult, XSSType
from schema.common import ParamResultList, FinalParamResult, ResultType, FinalTestingResult
from schema.request_response import RequestResponsePair
from tools.perplexity_search import PerplexitySearch
from tools.web_requester.web_requester import WebRequesterTool, WebRequesterGuardedToolkit
from tools.shell_tools.safe_shell_tool import ShellGuardedToolkit
from agno.utils.log import logger
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from config.globals import STREAM_RESPONSES, DEBUG_MODE
from server.sink import stream_status

XSS_AGENT_INSTRUCTIONS = dedent("""
    You are "XSS Agent," an AI specialized in detecting and confirming Cross-Site Scripting (XSS) vulnerabilities in web applications.

    Your mission is to identify all types of XSS vulnerabilitiesâ€”primarily reflected, stored, and DOM-basedâ€”using both automated techniques and intelligent manual probing. Craft context-aware payloads and analyze responses thoroughly to reduce false positives and discover edge-case bypasses.
        
    ===============================================
    ðŸ“¡ Context Awareness
    ===============================================
    - Use the UserInput toolkitâ€™s `get_user_input(<question>)` to get user input or confirmation.
    - Use PerplexitySearch synchronous search method to research any necessary information.
    - Use ShellTools to execute command-line tools available in a Kali Linux shell environment.
    
    ===============================================
    ðŸŽ¯ Responsibilities
    ===============================================
    You must:
    - If the user provides a sample payload, test that payload as-is.
    - Probe only the parameter specified by the user; leave other parameters at default or appropriate values.
    - Detect and differentiate between:
      - Reflected XSS
      - Stored XSS
      - DOM-based XSS
    - If no sample payload is provided, craft and inject low-noise, context-aware payloads based on the parameterâ€™s context, including:
      - HTML body
      - Attribute values
      - JavaScript contexts
      - Event handlers
    - Analyze server responses and rendered content for evidence of payload execution or injection.
    - Test common encoding, filtering, and sanitization bypass techniques.
    - Adapt payloads based on input validation and response behavior.
    - Confirm vulnerabilities by detecting actual script execution or reflected payload presence.
    
    ===============================================
    ðŸ§° Tool Use Guidelines
    ===============================================
    - Use tools and scripts as helpers but do not rely solely on automated scanners.
    - Prefer manual, context-aware payload crafting and iterative testing.
    - Use browser simulation or lightweight headless browsing where possible to detect DOM XSS.
    
    ===============================================
    ðŸ“¡ Input Vector Exploration
    ===============================================
    Test parameters in:
    - URL query strings
    - POST bodies and JSON payloads
    - HTTP headers (e.g., Referer, User-Agent)
    - Cookies
    - URL fragments (for DOM XSS)
    Analyze JavaScript and HTML responses for injection points and payload reflection.

    ================================================
    ðŸ“¤ Output Format Example
    ================================================
    Respond using the following model for each payload tested:
    ```
    class ParamResult(BaseModel):
        endpoint_url: str
        method: str
        param: str
        payload: str
        vulnerable: bool
        xss_type: XSSType
        notes: str
    ```
    
    Example:
    ```
    result = ParamResult(
        endpoint_url='http://example.com',
        method='GET',
        param = "?search"
        payload = "qqq'"
        vulnerable = True
        xss_type = XSSType.reflected
        notes = "?search parameter is vulnerable to Reflected XSS. The payload is reflected in ..."
    ```
    
    Final result should be a list of ParamResult in JSON string format:
    ```
    class ParamResultList(BaseModel):
        param_result_list: List[ParamResult]
    ```
    Return only the JSON string as your response.
    ================================================
    ðŸ§  Behavior Expectations
    ================================================
    - Emulate a skilled web security tester applying both creativity and rigor.
    - Validate vulnerabilities with clear proof (e.g., payload reflection, execution).
    - Avoid noisy or indiscriminate fuzzing; be precise and context-sensitive.
    - Provide detailed evidence and recommendations with every finding.
""")

PAYLOADS = ["yomama'", "yomama\"","yomama<"]

class XSSAgent(CustomAgent):
    """
    Class for Agent specialising in exploiting XSS vulnerabilities.
    """

    def __init__(self, session_id: str, *args, **kwargs) -> None:
        """
        Initialise the XSS agent.
        :param session_id: The session id of the agent.
        :param args: Additional arguments passed to the agent.
        :param kwargs: Additional keyword arguments passed to the agent.
        """
        super().__init__(
            name="XSS Agent",
            instructions=XSS_AGENT_INSTRUCTIONS,
            sess_id=session_id,
            goal="Validate and exploit XSS vulnerabilities via low-noise payloads.",
            success_criteria="Successfully validate and exploit XSS vulnerabilities with low-noise payloads.",
            tools=[PerplexitySearch(cache_results=True), ShellGuardedToolkit(cache_results=True), WebRequesterGuardedToolkit(vuln_type="xss", cache_results=True, use_vpn=False, session_id=session_id)],
            parser_model=self.model,  # use the same model for parsing output
            *args,
            **kwargs
        )
### TODO: REFACTOR THIS WHOLE FREAKING CODE together with OpenRedirect

def _is_payload_reflected(payload: str, req_resp_obj: RequestResponsePair) -> Optional[str]:
    """
    Checks if a given payload is reflected in response header/response body.

    Args:
        payload (str): The payload to check.
        req_resp_obj (RequestResponsePair): The request response object.
    """
    
    response = getattr(req_resp_obj, 'response', None)
    
    if response is None:
        logger.warning(f'_is_payload_reflected did not receive a response for payload {payload}')
        return None
    else:
        if any(payload in value for value in response.response_headers.values()):
            return "Payload reflected in response header."
        elif payload in response.response_body:
            return "Payload reflected in response body."
        else:
            return None

async def _check_for_reflection(web_requester: WebRequesterTool, target_url: str, target_param: str, payload: str, request_body: Optional[Any] = None) -> XSSParamResult:
    """
    Check if a payload is reflected in response.

    Args:
        web_requester: Instance of WebRequesterTool.
        target_url (str): The target URL with the payload to check for reflection.
        target_param (str): The target parameter name.
        payload (str): Payload to check for reflection.
        request_body (Optional[Any]): The payload of the POST request to check for reflection.
    Returns:
        str: The list of request response pair objects in string format.
    """
    method = "POST" if request_body else "GET"

    try:
        response = await (
            web_requester.arun_web_requester(url=target_url, method=method, data=request_body)
            if request_body
            else web_requester.arun_web_requester(url=target_url, method=method)
        )
        req_resp_list = json.loads(response)
    except (json.JSONDecodeError, Exception) as e:
        logger.error(f"Failed to parse response JSON or make request: {e}")
        return XSSParamResult(
            endpoint_url=target_url,
            method=method,
            param=target_param,
            payload=payload,
            potentially_vulnerable=False,
            xss_type=XSSType.REFLECTED,
            notes=f"Request or JSON parsing failed: {e}"
        )

    for req_resp in req_resp_list:
        req_resp_obj = RequestResponsePair.model_validate_json(json.dumps(req_resp))
        reflection_note = _is_payload_reflected(payload, req_resp_obj)
        if reflection_note:
            return XSSParamResult(
                endpoint_url=req_resp_obj.request.request_url,
                method=method,
                param=target_param,
                payload=payload,
                potentially_vulnerable=True,
                xss_type=XSSType.REFLECTED,
                notes=reflection_note,
            )

    return XSSParamResult(
        endpoint_url=target_url,
        method=method,
        param=target_param,
        payload=payload,
        potentially_vulnerable=False,
        xss_type=XSSType.REFLECTED,
        notes="Not vulnerable."
    )

async def check_for_reflection(url: str, target_param: str, request_body: Optional[Any] = None) -> ParamResultList:
    """
    Check if a payload is reflected in response via both GET and POST requests.

    Args:
        url (str): The target URL with the payload to check for reflection.
        target_param (str): The target parameter name.
        E.g. https://eservice.nlb.gov.sg/components/v2/get/nlb-notice.url?app=CAS&key=MPoJWMVKDUP5&callback=notice_eqTeeFJ16qqq=a;let+a='conf';let+b='irm';top[a%2bb](1);//
        `callback` is the target parameter, and `notice_eqTeeFJ16qqq=a;let+a='conf';let+b='irm';top[a%2bb](1);//` is the payload.
        request_body (Any): The request body of the POST request to check for reflection.
    """
    web_requester = WebRequesterTool()
    param_result_list = ParamResultList(param_result_list=[])
    parsed_url = urlparse(url)
    query_params = parse_qs(parsed_url.query)

    for payload in PAYLOADS:
        # Format GET request
        query_params[target_param] = [payload]
        new_query = urlencode(query_params, doseq=True)
        get_url = urlunparse(parsed_url._replace(query=new_query))
        param_result = await _check_for_reflection(web_requester, get_url, target_param, payload)
        param_result_list.param_result_list.append(param_result)

        # Format POST request
        post_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, '', '', ''))
        post_body = None
        if request_body is not None:
            if isinstance(request_body, dict):
                post_body = deepcopy(request_body)
                post_body[target_param] = payload
            elif isinstance(request_body, str):
                parsed_body = parse_qs(request_body)
                parsed_body[target_param] = [payload]
                post_body = urlencode(parsed_body, doseq=True)
        else:
            post_body = f"{target_param}={payload}"

        param_result = await _check_for_reflection(web_requester, post_url, target_param, payload, post_body)
        param_result_list.param_result_list.append(param_result)

    return param_result_list

@stream_status()
async def run_xss_agent(tag_recon_info: TagReconInfo, session_id: str) -> FinalTestingResult:
    """
    Tests for reflected & stored XSS vulnerabilities.

    Stores xss testing result into the XSSTestingResult dataclass.

    Args:
        tag_recon_info (TagReconInfo): Vulnerability assessment output containing the endpoint and parameters that should undergo XSS testing.
        session_id (str): Unique session ID number.

    Returns:
        FinalTestingResult: XSS testing result object containing the endpoint and list of parameters testing result.
    """
    xss_agent = XSSAgent(
        session_id=session_id, 
        show_tool_calls=True,
        debug_mode=DEBUG_MODE
        )
    response_formatter_agent = ResponseFormatterAgent(response_model=ParamResultList)
    xss_testing_result = FinalTestingResult(endpoint=tag_recon_info.url, final_param_result_list={})

    xss_testing_result.final_param_result_list[tag_recon_info.vuln_param] = []

    base_prompt = (f"The vulnerable endpoint URL is: {tag_recon_info.url}. The parameter that you are requested to test is: {tag_recon_info.vuln_param}. "
                   f"This endpoint expects all these other parameters: {tag_recon_info.param_set}. Only test {tag_recon_info.vuln_param} while keeping all other parameters at default values. "
                   f"Try both GET and POST request methods. ")

    target_url = tag_recon_info.url
    request_body = None

    # Run diagnostic payload and observe response
    if tag_recon_info.method == "GET":
        # Format GET request
        parsed_url = urlparse(tag_recon_info.url)
        parsed_query = parse_qs(tag_recon_info.param_set)
        encoded_query = urlencode(parsed_query, doseq=True)
        target_url = urlunparse(parsed_url._replace(query=encoded_query))

    if tag_recon_info.enctype == "application/x-www-form-urlencoded":
        request_body = tag_recon_info.param_set
    elif tag_recon_info.enctype == "application/json":
        # TODO: idk i am assuming it will be a json string
        try:
            request_body = json.loads(tag_recon_info.param_set)
        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse JSON request body: {e}")
            request_body = None
    elif tag_recon_info.enctype == "multipart/form-data":
        # TODO: add support for multipart/form-data
        pass

    param_result_list = await check_for_reflection(target_url, tag_recon_info.vuln_param, request_body)
    basic_param_result = FinalParamResult(
        result_type=ResultType.BASIC,
        param_result_list=param_result_list,
    )
    xss_testing_result.final_param_result_list[tag_recon_info.vuln_param].append(basic_param_result)

    # Get XSS_Agent to craft more advanced payloads to try
    advanced_user_prompt = (f"We previously tested some basic payloads: {basic_param_result.model_dump_json()}"
                            f"{base_prompt}\nPlease craft your own low-noise context-aware payloads to avoid WAF detection. Feel free to try more than one payload.\n")
    try:
        resp = await xss_agent.arun(
            advanced_user_prompt,
            stream=STREAM_RESPONSES
            )
        
        if STREAM_RESPONSES:
            async for chunk in resp: 
                pass
            resp = xss_agent.run_response
        
        resp = await response_formatter_agent.arun(resp.content)
        if isinstance(resp.content, ParamResultList):
            advanced_result = FinalParamResult(result_type=ResultType.ADVANCED, param_result_list=resp.content)
            xss_testing_result.final_param_result_list[tag_recon_info.vuln_param].append(advanced_result)
        else:
            logger.error(f"Failed to convert agent response to ParamResultList. Got {type(resp.content)}.")
            raise ValueError(f"Failed to convert agent response to ParamResultList.")
    except Exception as e:
        logger.error(f"Failed to run xss test: {e}.")
        raise

    logger.info(f"{xss_testing_result.model_dump_json(indent=2)}")
    return xss_testing_result
