from textwrap import dedent
from custom_agents.base import CustomAgent
from custom_agents.response_formatter_agent import ResponseFormatterAgent
from schema.recon import TagReconInfo
from schema.common import ParamResultList, FinalParamResult, ResultType, FinalTestingResult
from tools.perplexity_search import PerplexitySearch
from tools.web_requester.web_requester import WebRequesterTool, WebRequesterGuardedToolkit
from tools.shell_tools.safe_shell_tool import ShellGuardedToolkit
from agno.utils.log import logger
from config.globals import STREAM_RESPONSES, DEBUG_MODE
from server.sink import stream_status

XXE_AGENT_INSTRUCTIONS = dedent("""
    You are "XXE Agent," an AI specialized in detecting and confirming **XML External Entity (XXE) vulnerabilities** in web applications and APIs.

    Your mission is to identify unsafe XML parsers that improperly handle external entities. You will attempt to confirm the vulnerability through crafted XML payloads and by observing direct behavioral indicators such as OOB DNS requests, error messages, or file inclusion behavior.

    ===============================================
    ðŸ“¡ Context Awareness
    ===============================================
    - Use the UserInput toolkitâ€™s `get_user_input(<question>)` to collect target URLs, authentication headers, or sample XML schemas.
    - Use PerplexitySearch synchronous search for learning about framework behaviors or parsing libraries.
    - Use ShellTools to perform local file operations or launch supporting tools.
    - Use WebRequesterTools to make all your web requests. Do not use `curl` or `wget` unless context requires.

    ===============================================
    ðŸŽ¯ Responsibilities
    ===============================================
    You must:
    - Analyze target endpoints (URLs or API routes) that accept XML input.
    - Craft XXE payloads that attempt:
        - External entity resolution to internal HTTP/DNS hosts
        - Access to sensitive files (e.g., `/etc/passwd`)
        - Parameter/entity expansion (for DoS or entity injection testing) DO NOT CRASH THE SERVER!!!
    - Inject payloads in:
        - Direct XML body (raw)
        - XML embedded in multipart/form-data or JSON fields (e.g., `{"xml":"<xml>...</xml>"}`)
        - Content-Type: `application/xml`, `text/xml`, or custom XML-like types
    - Detect signs of vulnerability based on:
        - Response body containing sensitive file contents
        - XML parsing errors or stack traces referencing external entities
        - Server interaction with DNS/OOB listener (if used)
    - Evaluate the severity level:
        - `high` (arbitrary file read or remote fetch)
        - `medium` (entity parsing enabled but restricted)
        - `low` (payload reflected, but external entities blocked)

    ===============================================
    ðŸ§° Tool Use Guidelines
    ===============================================
    - Use WebRequesterTool to send crafted XML payloads with different encodings and entity declarations.
    - Do not brute-force. Use **purpose-built, minimal XML payloads** tailored to the context of the target.
    - Use manual payload tuning based on response behavior.

    ===============================================
    ðŸ§ª Input Vector Exploration
    ===============================================
    Test XML payloads in:
    - POST body (raw XML)
    - File upload fields (XML content or .xml files)
    - Nested XML in JSON or form fields
    - Alternate content types (SOAP, RSS, SVG, etc.)
    - Headers or multipart segments containing XML

    ===============================================
    ðŸ“¤ Output Format Example
    ===============================================
    Respond using the following model for each payload tested:
    ```
    class XXEResult(BaseModel):
        endpoint_url: str
        method: str
        param: str
        payload: str
        vulnerable: bool
        severity: Severity  # high, medium, low
        detection_method: XXEDetectionMethod  # file_read, parser_error, reflection
        notes: str
    ```

    Example:
    ```
    result = XXEResult(
        endpoint_url="https://api.example.com/upload",
        method="POST",
        param_or_vector="raw_body",
        payload="<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><foo>&xxe;</foo>",
        vulnerable=True,
        severity=Severity.HIGH,,
        detection_method=XXEDetectionMethod.FILE_READ,
        notes="Response contained contents of /etc/passwd, confirming file disclosure via external entity."
    )
    ```

    Final result should be a list of XXEResult in JSON string format:
    ```
    class XXEResultList(BaseModel):
        xxe_result_list: List[XXEResult]
    ```

    Return only the JSON string as your response.

    ===============================================
    ðŸ§  Behavior Expectations
    ===============================================
    - Emulate a skilled security tester: precise, iterative, and context-aware.
    - Confirm vulnerabilities only when behavioral evidence (content leak, or parse error) is observed.
    - Adapt payloads based on Content-Type, parsing hints, or stack traces.
    - Avoid false positives: if the server blocks the entity, treats it as plain text, or escapes it, mark as not vulnerable.
    - Provide clear notes on how and why the vulnerability was confirmed (or not).
""")

class XXEAgent(CustomAgent):
    """
    Class for Agent specialising in exploiting XXE vulnerabilities.
    """

    def __init__(self, session_id: str, *args, **kwargs) -> None:
        """
        Initialise the XXE agent.
        :param session_id: The session id of the agent.
        :param args: Additional arguments passed to the agent.
        :param kwargs: Additional keyword arguments passed to the agent.
        """
        super().__init__(
            name="XXE Agent",
            instructions=XXE_AGENT_INSTRUCTIONS,
            sess_id=session_id,
            goal="Validate and exploit XXE vulnerabilities via low-noise payloads.",
            success_criteria="Successfully validate and exploit XXE vulnerabilities with low-noise payloads.",
            tools=[PerplexitySearch(cache_results=True), ShellGuardedToolkit(cache_results=True), WebRequesterGuardedToolkit(vuln_type="xxe", cache_results=True, use_vpn=False, session_id=session_id)],
            *args,
            **kwargs
        )

@stream_status()
async def run_xxe_agent(tag_recon_info: TagReconInfo, session_id: str) -> FinalTestingResult:
    """
    Tests for XXE vulnerabilities.

    Stores XXE testing result into the FinalTestingResult dataclass.

    Args:
        tag_recon_info (TagReconInfo): Vulnerability assessment output containing the endpoint and parameters that should undergo XXE testing.
        session_id (str): Unique session ID number.

    Returns:
        FinalTestingResult: FinalTestingResult instance that is parsed by ResponseFormatterAgent.
    """
    xxe_agent = XXEAgent(
        session_id=session_id, 
        show_tool_calls=True,
        debug_mode=DEBUG_MODE)
    response_formatter_agent = ResponseFormatterAgent(response_model=ParamResultList)
    xxe_testing_result = FinalTestingResult(endpoint=tag_recon_info.url, final_param_result_list={})

    base_prompt = (
        f"The vulnerable endpoint URL is: {tag_recon_info.url}. The parameter that you are requested to test is: {tag_recon_info.vuln_param}. "
        f"Identify any XXE vulnerabilities and exploit them to achieve the goal. If {tag_recon_info.vuln_param} is not vulnerable, feel free to try other parameters. "
        f"Try both GET and POST request methods. ")

    xxe_testing_result.final_param_result_list[tag_recon_info.vuln_param] = []

    resp = await xxe_agent.arun(
        base_prompt,
        stream=STREAM_RESPONSES
        )
    
    if STREAM_RESPONSES:
            async for chunk in resp: 
                pass
            resp = xxe_agent.run_response
            
    resp = await response_formatter_agent.arun(resp.content)
    if isinstance(resp.content, ParamResultList):
        xxe_testing_result.final_param_result_list[tag_recon_info.vuln_param].append(FinalParamResult(result_type=ResultType.ADVANCED, param_result_list=resp.content))
    else:
        logger.error(f"Failed to convert agent response to ParamResultList. Got {type(resp.content)}.")
        raise ValueError(f"Failed to convert agent response to ParamResultList.")

    logger.info(f"{xxe_testing_result.model_dump_json(indent=2)}")
    return xxe_testing_result
