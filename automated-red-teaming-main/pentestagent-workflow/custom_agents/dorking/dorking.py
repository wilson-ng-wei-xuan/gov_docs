from typing import List, Optional
from custom_agents.base import CustomAgent
from agno.tools.serper import SerperTools
from tools.shell_tools.safe_shell_tool import ShellGuardedToolkit
from agno.utils.log import logger
from textwrap import dedent
import os
from schema.recon import PassiveReconOutput, KatanaAnalysisOutput, KatanaEndpoint
from custom_agents.response_formatter_agent import ResponseFormatterAgent
from config.globals import STREAM_RESPONSES, DEBUG_MODE
from server.sink import StreamEvent, stream_status
from config.context import current_sink 

DORKING_INSTRUCTIIONS = dedent(
            """                
                <dorking_task>
                    <agent_role>
                        You are a reconnaissance agent skilled in Google Dorking and vulnerability identification.
                        You will use the Serper.dev Google Search API to investigate a given set of target URLs.
                    </agent_role>

                    <objectives>
                        <objective>Identify exposed and sensitive pages under the target domain.</objective>
                        <objective>Detect pages that could enable cybersecurity attacks.</objective>
                        <objective>Uncover CVEs and public exploits related to the target or linked URLs.</objective>
                    </objectives>

                    <output_format>
                        <format_description>Return a JSON string structured as below:</format_description>
                        <json_format>
                        {
                            "dorking_links": [
                            {
                                "url": "",
                                "passive_evidence": {
                                "vulnerability": "",
                                "cves_exploits": [
                                    {
                                    "id": "",
                                    "summary": "",
                                    "link": ""
                                    }
                                ]
                                }
                            },
                            ...
                            ]
                        }
                        </json_format>
                    </output_format>

                    <instructions>
                        <section title="Google Dorking">
                        <description>Use dork queries against the target URLs to discover vulnerable or sensitive pages.</description>
                        <query_format>site:&lt;target_url&gt; &lt;dork_string&gt;</query_format>
                        <url_forms>Use both full and shortened forms (e.g., "https://github.com" and "github.com").</url_forms>

                        <dork_categories>
                            <category name="Admin Access">
                            `inurl:/admin | inurl:/administrator | inurl:/adminpanel | inurl:/admin_area | inurl:/cpanel | inurl:/adminconsole | inurl:/wp-admin | inurl:/useradmin | inurl:/admin_dashboard | inurl:/dashboard/admin | intitle:"Admin Panel" | intitle:"Login Panel" | intitle:"Administrator Login" | intitle:"Backend Login"`
                            </category>
                            <category name="Sensitive Keys and Secrets">
                            `intext:"AWS_ACCESS_KEY_ID" | intext:"BEGIN RSA PRIVATE KEY" | intext:"MYSQL_PASSWORD" | intext:"api_key=" | intext:"x-api-key" | intext:"SECRET_KEY" | intext:"OAUTH_SECRET" | inurl:.env | intext:"client_id" | ext:yaml | ext:ini | ext:conf | ext:json | intext:"passwd"`
                            </category>
                            <category name="Sensitive Indicators">
                            'intitle:"index of /confidential" | intitle:"index of /private" | intitle:"index of /restricted" | "INTERNAL USE ONLY" ext:pdf | "NOT FOR PUBLIC RELEASE" ext:docx | intext:"confidential report" ext:xls | intext:"proprietary information" ext:pptx | intext:"trade secret" ext:txt | intext:"for internal distribution only" ext:csv | intitle:"index of" "leaked"`
                            </category>
                            <category name="Upload and Shell Access">
                            `inurl:upload.php | inurl:file_upload.jsp | intitle:"index of /uploads" | inurl:handle_upload | inurl:/admin/upload | inurl:shell.asp | intext:"web shell by" ext:php | inurl:cmd.php | inurl:backdoor.jsp | intext:"Uploader: " ext:php`
                            </category>
                            <category name="Logs and Monitoring">
                            `intitle:"index of /logs" | ext:log intext:"error" | ext:txt intext:"exception" | inurl:debug.log | inurl:system.log | inurl:access.log | intitle:"Prometheus Time Series Collection" | intitle:"Grafana" inurl:dashboard | intext:"traceback (most recent call last)" | intitle:"Monitoring Report"`
                            </category>
                            <category name="Documents and Reports">
                            `filetype:pdf | filetype:doc | filetype:xls | intitle:"Index of" + report | inurl:financial | intitle:"index of /documents" | ext:pdf intext:"confidential report" | ext:docx intext:"quarterly summary" | ext:xlsx intext:"financials" | ext:pptx intext:"strategy presentation" | ext:csv intext:"client list" | ext:rtf intext:"project timeline" | ext:txt intext:"internal memo" | ext:doc intext:"board meeting" | ext:pdf intext:"risk assessment" `
                            </category>
                            <category name="Source Code and Configs">
                            `filetype:sql | filetype:json | filetype:conf | filetype:xml | inurl:config | intitle:"index of" + src | intitle:"index of /src" | ext:js | ext:py | ext:java | ext:go | ext:rb | ext:sh | ext:conf | ext:ini | ext:env | ext:json`
                            </category>
                            <category name="Development Artifacts">
                            `intitle:"index of /backup" | ext:bak | ext:old | ext:tmp | ext:swp | ext:log intext:"debug" | ext:log intext:"trace" | ext:sql | intitle:"test environment" | intitle:"development server" | inurl:"/dev" | inurl:"/test" | inurl:"/staging" | inurl:"/backup" | inurl:"/old" | inurl:"/temp" | inurl:"/logs" | inurl:"/debug" | inurl:"/maintenance"`
                            </category>
                            <category name="IDs and Tokens">
                            `inurl:id= | inurl:token= | inurl:auth= | inurl:session= | inurl:access_token= | inurl:userid= | inurl:api_key= | inurl:secret= | inurl:password= | inurl:sid=`
                            </category>
                            <category name="Third-party Frameworks">
                            `inurl:wp-content | inurl:wp-includes | inurl:drupal | inurl:joomla | inurl:laravel | inurl:magento | inurl:shopify | inurl:telerik | inurl:react | inurl:angular`
                            </category>
                            <category name="Common Gateways">
                              'inurl:gateway | inurl:api-gateway | inurl:proxy | inurl:loadbalancer | inurl:reverse-proxy | inurl:auth-gateway | inurl:webgate | inurl:portal | inurl:access-gateway | inurl:login-gateway`
                            </category>
                        </dork_categories>

                        <filtering_criteria>
                            <include>
                            <item>Directly exposed sensitive data (.env, backups, tokens)</item>
                            <item>Technical signs of misconfiguration (stack traces, SQL errors)</item>
                            <item>Unauthenticated or exposed internal systems</item>
                            </include>
                            <exclude>
                            <item>Generic login screens with no debug or credential data</item>
                            <item>Educational or forum content (e.g., Stack Overflow, tutorials)</item>
                            <item>Honeypots or decoy pages</item>
                            </exclude>
                        </filtering_criteria>
                        </section>

                        <section title="CVE and Exploit Discovery">
                        <description>Search for known CVEs and public exploits relevant to the target or exposed components.</description>
                        <search_examples>
                            <query>"Apache 2.4.49" CVE site:nvd.nist.gov</query>
                            <query>"Apache 2.4.49" exploit site:exploit-db.com</query>
                            <query>"Apache 2.4.49" RCE OR LFI OR disclosure</query>
                            <query>"Apache HTTP Server 2.4.49" vulnerability</query>
                            <query>site:cvedetails.com "Apache 2.4.49"</query>
                        </search_examples>
                        <cve_inclusion_rules>
                            <rule>Extract CVE ID (e.g., CVE-YYYY-NNNNN)</rule>
                            <rule>Summarize type (RCE, LFI, etc.)</rule>
                            <rule>Include authoritative link (prefer .gov or .org)</rule>
                            <rule>Exclude vague or irrelevant matches</rule>
                        </cve_inclusion_rules>
                        </section>

                        <section title="Workflow">
                        <step number="1">
                            <title>Generate Queries</title>
                            <details>Build unique, semantically varied dorking queries across multiple categories.</details>
                        </step>
                        <step number="2">
                            <title>Execute Queries</title>
                            <details>Use Serper.dev. Deduplicate links. Avoid redundant or low-value queries. Use queries that are compounded with multiple dork strings appended</details>
                            <example>' site:github.com inurl:/admin | inurl:/administrator | inurl:/adminpanel | inurl:/admin_area | inurl:/cpanel | inurl:/adminconsole | inurl:/wp-admin | inurl:/useradmin | inurl:/admin_dashboard | inurl:/dashboard/admin | intitle:"Admin Panel" | intitle:"Login Panel" | intitle:"Administrator Login" | intitle:"Backend Login"`
                        </step>
                        <step number="3">
                            <title>Filter & Classify</title>
                            <details>Retain only high-value URLs. Tag with vulnerability summary. Add to JSON output. You must ensure the initial list of target URLs are added to the JSON output</details>
                        </step>
                        <step number="4">
                            <title>Associate CVEs/Exploits</title>
                            <details>Search for CVEs only where applicable. Skip irrelevant or trivial pages. Add verified findings to the output.</details>
                        </step>
                        </section>
                    </instructions>

                    <constraints>
                        <item>Do not fabricate results or CVEs.</item>
                        <item>Do not repeat URLs or CVEs from previous runs.</item>
                        <item>Ensure output is concise, accurate, and non-redundant.</item>
                        <item>Each discovered URL must be authentic and part of the target domain.</item>
                        <item>For step 2: Execute Queries, limit the number of queries to 20 queries. </item>
                        <item>The input list of target URLs must be included in "dorking_urls". </item>
                    </constraints>

                    <expected_behavior>
                        <item>Use your thinking tool and search tools to verify that discovered high-value URLs can indeed be accessed and exploited</item>
                        <item>Use your thinking tool and search tools to determine the nature of the target URL and use that as context for actions.</item>
                        <item>Use your thinking tool to discern when sufficient vulnerable links have been identified.</item>
                        <item>Use your thinking tool to discern when dorking results are consistently failing and if so stop making further queries. </item>              
                    </expected_behavior>

            """
    )

class DorkingAgent(CustomAgent):
    
    def __init__(self, name: str, session_id: str, instructions: Optional[str] = DORKING_INSTRUCTIIONS, context: Optional[dict] = None, tools: Optional[List] = None, *args, **kwargs):
        """
        Extend Agno Agent with context-aware run methods and session history saving.

        Args:
            name (str): Name of the agent.
            session_id (str): Unique session ID number.
            instructions (str): System prompt / instructions.
            context (Optional[str]): Persistent context.
            tools (Optional[List]): Tool list for agent.
        """
        
        # Other tools passed in will be ignored, we only use SerperTools
        tools = [
            SerperTools(api_key=os.getenv("SERPER_API_KEY")),
            ShellGuardedToolkit(cache_results=True)
        ]

        super().__init__(
            name=name,
            instructions=instructions,
            sess_id=session_id,
            context=context or {},
            goal="Perform Google dorking queries to identify possible vulnerabilities based on URL",
            success_criteria="Successfully gathered information regarding target",
            tools=tools,
            *args,
            **kwargs,
        )

@stream_status(
    input_metadata_fields=['katana_output', 'session_id'],
    log_output=True
)
async def run_dorking_agent(katana_output: KatanaAnalysisOutput, session_id: str) -> KatanaAnalysisOutput:
    """
    Run the Dorking agent to find all associated passive vulnerabilities

    Args:
        katana_output (KatanaAnalysisOutput): All endpoints discovered from run_katana

    Returns:
        KatanaAnalysisOutput: Initial input appended with new endpoints discovered through dorking. Each endpoint is also tagged with any CVEs found online.
    """

    BATCH_SIZE = 20
    dorking_agent = DorkingAgent(
        name="dorking_agent", 
        session_id=session_id, 
        show_tool_calls=False,
        debug_mode=DEBUG_MODE
        )
    response_formatter = ResponseFormatterAgent(response_model=PassiveReconOutput)

    seen_urls = {}
    curr_index = 0

    while curr_index < len(katana_output.endpoints):
        batch_endpoints = katana_output.endpoints[curr_index:min(curr_index+BATCH_SIZE, len(katana_output.endpoints))]
        batch_urls = []

        for endpoint in batch_endpoints:
            if endpoint.url in seen_urls:
                # Case where it is already processed, simply needs to be insert methods + technologies
                logger.info(f"Dorking: Skipping {endpoint.url}: Already processed")
                seen_urls[endpoint.url].methods = endpoint.methods
                seen_urls[endpoint.url].technologies = endpoint.technologies
                continue
            
            seen_urls[endpoint.url] = endpoint
            batch_urls.append(endpoint.url)
        
        curr_index += BATCH_SIZE
        if len(batch_urls) == 0:
            logger.info("Dorking: Current batch is fully processed - skip")

        try:
            response = await dorking_agent.arun(
                f"Given the target URLs: {batch_urls}, use Google dorking to find potential vulnerable URLs",
                stream=STREAM_RESPONSES
                )
            
            if STREAM_RESPONSES:
                async for chunk in response: 
                    pass
                response = dorking_agent.run_response
                 
            formatted_response = await response_formatter.arun(response.content)
            formatted_response = formatted_response.content

            if not isinstance(formatted_response, PassiveReconOutput):
                logger.error(f"Dorking: Dorking Agent output format is invalid. Found: {type(formatted_response)}")
                raise ValueError("Dorking: Failed to successful convert Dorking Agent output to PassiveReconOutput")

                
            for link in formatted_response.dorking_links:
                if link.url in seen_urls:
                    # In this case, simply add the passive_evidence
                    seen_urls[link.url].passive_evidence = link.passive_evidence
                
                else:
                    # In this case, a new KatanaEndpoint needs to be made
                    new_endpoint = KatanaEndpoint(url=link.url, passive_evidence=link.passive_evidence)
                    seen_urls[link.url] = new_endpoint

        except Exception as e:
            logger.error(f"Dorking: Dorking Agent/Response Formatter failed to return on {endpoint.url} {e}")
            raise
    
    # Adds all newly discovered endpoint
    katana_output.endpoints = list(seen_urls.values())

    return katana_output


    
    