import json
from typing import List
from agno.utils.log import logger
from schema.task import WorkflowStage, TaskStatus, Task, TaskList
from custom_agents.base import CustomAgent
from tools.state_management import get_session_history

class OrchestratorAgent(CustomAgent):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
    
    def summarize_tasks(self, tasks_queue: List[Task]) -> str:
        # Summarize task queue into a readable JSON string for prompt context
        summary = [
            {
                "task_name": task.name,
                "status": task.status.value,
                "stage": task.stage.value,
                "retry_count": task.retry_counter,
                "result_summary": str(task.result) if task.result else "No result yet",
            }
            for task in tasks_queue
        ]
        return json.dumps(summary, indent=2)

    def summarize_history(self, session_id: str) -> str:
        # Retrieve session history from DB
        try:
            history = get_session_history(session_id)
            return history
        except Exception as e:
            logger.exception(f"Failed to get session history: {e}")
            return None

    def prepare_prompt(self) -> str:
        """
        Craft system prompt for orchestrator agent.

        Returns:
            str: System prompt for orchestrator agent.
        """
        # Prepare context for prompt
        history_context = self.summarize_history(session_id)
        if history_context is None:
            raise Exception("Unable to get session history")

        tasks_context = self.summarize_tasks(tasks_queue)

        prompt = (
            "You are the Orchestrator Agent overseeing the pentest workflow.\n"
            "Here is the session history of previous decisions and outputs:\n"
            f"{history_context}\n\n"
            "Here is the current list of tasks pending:\n"
            f"{tasks_context}\n\n"
            "Evaluate if the current tasks pending are optimal to achieve the pentest goal.\n"
            "If you think changes are needed (add, remove, reorder tasks), provide the revised list of tasks in JSON format, "
            "each with fields: name, args (list), stage, and optionally prompt.\n"
            "If the current tasks are good as-is, reply with the JSON list unchanged.\n"
            "Respond ONLY with the JSON list of tasks."
        )

        return prompt

    def propose_new_tasks(self, session_id: str, tasks_queue: List[Task]) -> List[Task]:
        """
        Main method to evaluate current workflow and propose a new task list.

        Args:
            session_id (str): Unique session ID.
            tasks_queue (List[Task]): Current tasks left in the queue.

        Returns:
            List[Task]: New task list proposed by orchestrator.
        """
        prompt = self.prepare_prompt()

        try:
            response = self.run(prompt, session_id)
            return response.content.task_list
        except Exception as e:
            # If parsing fails, log and fallback to existing tasks_queue
            logger.exception(f"OrchestratorAgent failed to run: {e}")
            return tasks_queue

    async def apropose_new_tasks(self, session_id: str, tasks_queue: List[Task]) -> List[Task]:
        # Async version of propose_new_tasks
        prompt = self.prepare_prompt()

        try:
            response = await self.arun(prompt, session_id)
            return response.content.task_list
        except Exception as e:
            # If parsing fails, log and fallback to existing tasks_queue
            logger.exception(f"OrchestratorAgent failed to run: {e}")
            return tasks_queue
