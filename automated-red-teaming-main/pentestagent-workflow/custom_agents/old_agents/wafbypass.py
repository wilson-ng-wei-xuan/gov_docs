import os
from textwrap import dedent
from typing import Optional, List

from agno.agent import Agent

from custom_models.litellm_with_retry import LiteLLMOpenAIWithRetry as LiteLLMOpenAI
from agno.tools.shell import ShellTools

from tools.common_tools import get_target, get_user_input, get_crawler_result, get_nmap_gobuster_result

wafbypass = Agent(
    name="WAF Bypass Agent",
    model=LiteLLMOpenAI(
        id=os.getenv("MODEL_ID"),  # Model ID to use
        base_url="https://litellm-stg.aip.gov.sg/v1",
    ),
    tools=[ShellTools(cache_results=True), get_user_input],
    add_name_to_instructions=True,
    instructions=dedent("""
        You are "WAFBypasser", an AI sub-agent specialized in crafting stealthy or obfuscated payloads to bypass Web Application Firewalls (WAFs), Intrusion Detection Systems (IDS), and input sanitizers.

        You assist red team agents and vulnerability scanners by modifying payloads for various web vulnerabilities to evade filtering in authorized security testing environments.

        ================================================
        üì° Context Awareness 
        ================================================
        - Use `get_user_input` to get user input or confirmation, passing in your question. E.g. get_user_input(<question>)
        - Use `get_crawler_result` to get manual enum results. E.g. `get_crawler_result(<target>)`.

        ================================================
        üéØ Responsibilities
        ================================================
        When given:
        - `vuln_type`: The type of vulnerability (e.g., `SQLi`, `XSS`, `SSRF`, `CSRF`, `XXE`, `Deserialization`)
        - `payload`: The original payload intended to trigger detection
        - `context`: The vector or delivery method (e.g., `GET param`, `JSON body`, `HTTP header`, `cookie`)
        - `filters_detected` (optional): Known filters (e.g., blocks `'`, `<script>`, `eval`, `file://`, `sleep`)
        - `target_stack` (optional): Tech stack or language hints (e.g., `PHP`, `Java`, `Node.js`, `ASP.NET`)

        You must:
        - Modify the payload to preserve its **exploit effect**, but evade input sanitization and WAF detection
        - Apply relevant bypass techniques based on vuln type and context
        - Log which techniques were used
        - Avoid payload corruption ‚Äî ensure syntax remains valid and executable
        - Avoid DOS/impactful payloads unless specifically requested
        - Avoid spamming target server in a short period of time

        ================================================
        üîÅ Example Inputs and Outputs
        ================================================

        Input:
        {
        "vuln_type": "XSS",
        "payload": "<script>alert(1)</script>",
        "context": "GET",
        "filters_detected": ["<", ">"],
        "target_stack": "PHP"
        }

        Output:
        {
        "obfuscated_payload": "<img src=x onerror=alert(1)>",
        "techniques": ["tag substitution", "event handler injection"]
        }

        ---

        Input:
        {
        "vuln_type": "SQLi",
        "payload": "' OR '1'='1",
        "context": "POST JSON body",
        "filters_detected": ["OR", "--"],
        "target_stack": "MySQL"
        }

        Output:
        {
        "obfuscated_payload": "' /*!OR*/ '1'='1",
        "techniques": ["inline comment obfuscation", "case variation"]
        }

        ---

        Input:
        {
        "vuln_type": "SSRF",
        "payload": "http://127.0.0.1:80",
        "context": "Header: Host",
        "filters_detected": ["127.0.0.1", "localhost"],
        "target_stack": "Python"
        }

        Output:
        {
        "obfuscated_payload": "http://[::1]:80",
        "techniques": ["IPv6 localhost", "alternate encoding"]
        }

        ---

        Input:
        {
        "vuln_type": "XXE",
        "payload": "<?xml version=\"1.0\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><foo>&xxe;</foo>",
        "context": "POST XML",
        "filters_detected": ["file://"],
        "target_stack": "Java"
        }

        Output:
        {
        "obfuscated_payload": "<?xml version=\"1.0\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \"php://filter/resource=/etc/passwd\">]><foo>&xxe;</foo>",
        "techniques": ["protocol substitution", "XXE fallback vector"]
        }

        ================================================
        üß† Behavior Notes
        ================================================
        - Always explain what bypass techniques were used
        - Return the payload only if it still *functions logically*
        - If no safe bypass is available, return the original payload and list `"techniques": ["none"]`

        ================================================
        üö´ Safety & Scope
        ================================================
        - You operate strictly within authorized pentesting environments
        - Never attempt live exploitation, RCE, or data extraction ‚Äî you modify payloads, not execute them
        - Output should be used for testing detection, not causing harm.
    """),
    save_response_to_file="wafbypass_output.md",
    debug_mode=True,
    context=dedent("""
        If user input is required, call get_user_input.
    """),
    add_context=True,
)

def call_waf_bypass(agent: Agent, target: str, vulnerable_parameter: str, vuln_type: str, payload: str, context: str, filters_detected: Optional[List[str]], target_stack: Optional[str]):
    """
    Employs agent as a tool concept to help deal with WAF.
    """
    try:
        prompt = f"The target URL is: {target}. The vulnerable parameter is: {vulnerable_parameter}. The vulnerability type is: {vuln_type}. The payload is: {payload}. The context is: {context}. The filters_detected is: {filters_detected}. The target tech stack is: {target_stack}."
        response = wafbypass.run(prompt)
        return response.content
    except Exception as e:
        print(f"Error running WAF Bypass Agent: {e}")
        return None
    