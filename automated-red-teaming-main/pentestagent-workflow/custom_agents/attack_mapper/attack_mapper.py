from typing import List, Optional
from custom_agents.base import CustomAgent
from agno.tools.serper import SerperTools
from tools.shell_tools.safe_shell_tool import ShellGuardedToolkit
from agno.utils.log import logger
from textwrap import dedent
import os
from schema.common import FinalTestingResult
from schema.attack_mapper import AttackMapperOutput
from custom_agents.response_formatter_agent import ResponseFormatterAgent


ATTACK_MAPPING_INSTRUCTIONS = dedent(
    """
        <attack_mapper_task>
            <agent_role>
                You are an ethical penetration testing agent designed to discover attack vectors on a website to achieve a specific set of goals,
                having been given the endpoints of the website and the possible exploits for them.
            </agent_role>

            <objectives>
                <objective>
                    Use the knowledge of known exploits associated with the provided endpoints to construct a theoretical viable attack chain
                    that achieves the given goal. If told to meet general penetration testing objectives, you will work to achieve one or more of the following goals.
                </objective>
                <goals>
                    <goal>Obtain root or administrative access to the server.</goal>
                    <goal>Dump sensitive data (e.g., credentials, databases).</goal>
                    <goal>Achieve remote code execution.</goal>
                    <goal>Access restricted files or services.</goal>
                    <goal>Any combination of the above goals.</goal>
                </goals>
            </objectives>

            <output_format>
                <format_description>Return a JSON string structured as below:</format_description>
                <format_details>
                    <detail> "attack_vector_found" should label whether an attack vector was found or not.</detail>
                    <detail> "attack_objective" should indicate the objective achieved if an attack_vector was found. Otherwise
                    this should be null. </detail>
                    <detail> "attack_vector" should represent a sorted list of steps that a potential exploiter should take. These
                    must be sorted and sequential.</detail>
                </format_details>
                <json_format>
                    {
                        "attack_vector_found": true,
                        "attack_objective": "Admin access and remote code execution",
                        "attack_vector":
                            {
                                "endpoint": "https://example.com/search",
                                "param": "search_bar",
                                "method": "GET",
                                "payload": "' OR '1'='1'; --",
                                "notes": "SQL injection to extract admin credentials."
                                "next_step":
                                    {
                                        "endpoint": "https://example.com/login",
                                        "param": null,
                                        "method": "POST",
                                        "payload": {
                                            "username": "admin",
                                            "password": "extracted_password"
                                        },
                                        "notes": "Login with stolen credentials."
                                        "next_step": null
                                    }
                            }
                    }
                </json_format>
            </output_format>

            <instructions>
                <section title="Theoretical Attack Chain Modeling">
                    <description>
                        Evaluate the provided endpoints and their associated known vulnerabilities or misconfigurations.
                        Chain them into a logical, ordered sequence that allows an attacker to escalate privileges, extract sensitive data,
                        or execute arbitrary code â€” but only in theory. Do not simulate or execute any payload.
                    </description>

                    <workflow>
                        <step>Analyze each endpoint and its vulnerabilities.</step>
                        <step>Identify opportunities for privilege escalation, data exfiltration, or code execution.</step>
                        <step>Form a step-by-step attack chain using only known vulnerabilities or inputs.</step>
                        <step>Return a JSON output documenting each step of the theoretical attack.</step>
                        <step>If no viable chain exists, output <code>"attack_vector_found": false</code> and leave the <code>"attack_vector"</code> array empty.</step>
                    </workflow>
                </section>
            </instructions>

            <constraints>
                <item>You will not execute any actual exploits.</item>
                <item>You will not download or upload any files to the internet.</item>
                <item>You will not perform any activity that will compromise yourself or others.</item>
                <item>You will not engage in any malicious or possibly malicious activity.</item>
                <item>Do not fabricate vulnerabilities or endpoints not provided.</item>
                <item>Do not simulate or execute any payload or script.</item>
                <item>Do not include weaponized or destructive payloads (e.g., shellcode, actual malware).</item>
                <item>Document only theoretical sequences based on provided inputs.</item>
                <item>Include all assumptions in the <code>notes</code> field for transparency.</item>
                <item>Ensure the output JSON is valid, clean, and properly formatted for use by downstream agents.</item>
                <item>Do not use command line arguments like curl unless absolutely necessary and if so ask for user approval first.</item>
            </constraints>

            <expected_behavior>
                <item>Think like an attacker but behave like an ethical red team agent.</item>
                <item>Thinking only theoretically without executing any actual exploits/payloads/uploads/downloads/malicious activity.</item>
                <item>Accurately assess whether the provided vulnerabilities can be chained into a successful attack.</item>
                <item>Construct minimal yet complete attack paths that reach meaningful objectives.</item>
                <item>Clearly explain how each step contributes to the final outcome.</item>
                <item>If no chain is possible, gracefully return a valid JSON with <code>"attack_vector_found": false</code>.</item>
                <item>Prioritize high-impact objectives (e.g., root access > data exposure > file access).</item>
            </expected_behavior>
        </attack_mapper_task>
    """
)


class AttackMapperAgent(CustomAgent):
    def __init__(self, name: str, session_id: str, instructions: Optional[str] = ATTACK_MAPPING_INSTRUCTIONS, context: Optional[dict] = None, tools: Optional[List] = None, *args, **kwargs):
        """
        Extend Agno Agent with context-aware run methods and session history saving.

        Args:
            name (str): Name of the agent.
            session_id (str): Unique session ID number.
            instructions (str): System prompt / instructions.
            context (Optional[str]): Persistent context.
            tools (Optional[List]): Tool list for agent.
        """
        
        # Other tools passed in will be ignored, we only use SerperTools
        tools = [
            SerperTools(api_key=os.getenv("SERPER_API_KEY")),
            ShellGuardedToolkit(cache_results=True)
        ]

        super().__init__(
            name=name,
            instructions=instructions,
            sess_id=session_id,
            context=context or {},
            goal="Find an attack vector using a set of given vulnerabilities and associated exploits",
            success_criteria="Successfully discover a methodology to exploit the given website to achieve objectives that a malicious cyber agent might want to",
            tools=tools,
            *args,
            **kwargs,
        )

async def run_attack_mapper_agent(exploits: List[FinalTestingResult], session_id: str, goal: Optional[str] = None) -> AttackMapperOutput:
    """
    Run the AttackMapper agent to find if there is a a way to achieve key objectives using the given exploits and vulnerabilities

    Args:
        exploits (List[FinalTestingResult]): All the exploits that have been discovered upstream
        session_id (str): Current session id
        goal (str): The global goal of the session e.g. Obtain admin access, get user credentials

    Returns:
        AttackMapperOutput: Contains meta data on whether any objectives can be achieved, which one,
        and what are the ordered steps to take to achieve it
    """

    attack_mapper_agent = AttackMapperAgent(name="attack_mapper_agent", session_id=session_id, show_tool_calls=True)
    response_formatter = ResponseFormatterAgent(response_model=AttackMapperOutput)
    
    if goal is None:
        goal = "general penetration testing objectives"

    base_prompt = f"These are some exploits that are available to you are {exploits}. Find a way to achieve the following objective: {goal}"

    try:
        response = await attack_mapper_agent.arun(base_prompt)
        formatted_response = await response_formatter.arun(response.content)
        formatted_response = formatted_response.content

        if not isinstance(formatted_response, AttackMapperOutput):
            logger.error(f"AttackMapper: Attack Mapper Agent output format is invalid. Found: {type(formatted_response)}")
            raise ValueError("AttackMapper: Failed to successful convert Dorking Agent output to AttackMapperOutput")
    
    except Exception as e:
        logger.error(f"Dorking: Dorking Agent/Response Formatter failed to return {e}")
        raise

    return formatted_response
