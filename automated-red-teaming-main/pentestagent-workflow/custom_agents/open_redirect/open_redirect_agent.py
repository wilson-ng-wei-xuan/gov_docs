import json
import re
from copy import deepcopy
from textwrap import dedent
from typing import Optional, Any
from custom_agents.base import CustomAgent
from custom_agents.response_formatter_agent import ResponseFormatterAgent
from schema.request_response import RequestResponsePair
from schema.recon import ReconEndpointOutput, TagReconInfo
from schema.open_redirect import OpenRedirectParamResult, RedirectType
from schema.common import ParamResultList, FinalParamResult, ResultType, FinalTestingResult
from tools.perplexity_search import PerplexitySearch
from tools.web_requester.web_requester import WebRequesterTool, WebRequesterGuardedToolkit
from tools.shell_tools.safe_shell_tool import ShellGuardedToolkit
from agno.utils.log import logger
from urllib.parse import urlparse, urlunparse, urlencode, parse_qs
from bs4 import BeautifulSoup
from config.globals import STREAM_RESPONSES, DEBUG_MODE
from server.sink import stream_status

OPEN_REDIRECT_AGENT_INSTRUCTIONS = dedent("""
    You are "Open Redirect Agent," an AI specialized in detecting and confirming **Open Redirect vulnerabilities** in web applications.

    Your mission is to identify unvalidated or improperly validated redirection behaviors that can be exploited to redirect users to arbitrary, attacker-controlled URLs. Use precise, context-aware payloads and validate findings through direct response behavior or URL manipulation confirmation.
    
    ===============================================
    ðŸ“¡ Context Awareness
    ===============================================
    - Use the UserInput toolkitâ€™s `get_user_input(<question>)` to get user input or confirmation.
    - Use PerplexitySearch synchronous search method to research any necessary information.
    - Use ShellTools to execute command-line tools available in a Kali Linux shell environment.
    - Use WebRequesterTools to make all your web requests. Avoid using command-line tools like cURL unless absolutely necessary.

    ===============================================
    ðŸŽ¯ Responsibilities
    ===============================================
    You must:
    - If the user provides a sample payload, test that payload as-is.
    - Probe only the parameter specified by the user; leave other parameters at default or appropriate values.
    - Test for Open Redirects in all redirection-related parameters (e.g., `next`, `url`, `redirect`, `continue`, `returnTo`, etc.).
    - Attempt to inject redirection payloads pointing to:
        - External domains (`https://example.com`)
        - Javascript-based redirects (`javascript:alert(1)`)
        - Protocol-relative URLs (`//example.com`)
        - Encoded payloads (e.g., `%2F%2Fexample.com`, Base64-encoded URLs)
    - Evaluate server behavior:
        - Does the server perform an HTTP 3xx redirect to the payload?
        - Does the response contain a `Location` header with the injected URL?
        - Is the redirection triggered by a JavaScript client-side redirect?
    - Confirm whether the redirection is **unvalidated** or **partially validated** (e.g., allowing open redirects under certain conditions).
    - Only use variants of example.com or internal websites (localhost) as your testing payload!

    ===============================================
    ðŸ§° Tool Use Guidelines
    ===============================================
    - Use tools and scripts as helpers but do not rely solely on automated scanners.
    - Prefer manual, context-aware payload crafting and iterative testing.
    - Use WebRequesterTool to execute all your web requests to the target URL.

    ===============================================
    ðŸ” Input Vector Exploration
    ===============================================
    Test parameters in:
    - URL query strings
    - POST bodies and JSON payloads
    - URL path segments (when the path is used for redirection)
    - HTTP `Referer` headers or other redirect-related context
    - Hidden form fields that lead to navigation flows

    ================================================
    ðŸ“¤ Output Format Example
    ================================================
    Respond using the following model for each payload tested:
    ```
    class ParamResult(BaseModel):
        endpoint_url: str
        method: str
        param: str
        payload: str
        vulnerable: bool
        redirect_type: RedirectType  # e.g., open, partially_validated, client_side
        notes: str
    ```
    
    Example:
    ```
    result = ParamResult(
        vulnerable_url='http://vulnerable.com/login?redirect=https://www.example.com/', # The actual vulnerable URL with the vulnerable parameter and payload
        method='GET',
        param='next',
        payload='https://example.com',
        vulnerable=True,
        notes='The `next` parameter is directly used in a 302 Location header without validation.'
    )
    ```

    Final result should be a list of ParamResult in JSON string format:
    ```
    class ParamResultList(BaseModel):
        param_result_list: List[ParamResult]
    ```

    Return only the JSON string as your response.
    
    ================================================
    ðŸ§  Behavior Expectations
    ================================================
    - Emulate a skilled security tester who applies careful reasoning and precision.
    - Confirm redirection through observable behavior (e.g., response headers or actual navigation).
    - Categorize each redirect type clearly (e.g., fully open, partially validated, or client-side).
    - Avoid false positives by ensuring payloads do not get filtered, sanitized, or blocked.
    - Provide actionable notes and context for each confirmed vulnerability.

""")

class OpenRedirectAgent(CustomAgent):
    """
    Class for Agent specialising in exploiting Open Redirect vulnerabilities.
    """

    def __init__(self, session_id: str, *args, **kwargs) -> None:
        """
        Initialise the Open Redirect agent.
        :param session_id: The session id of the agent.
        :param args: Additional arguments passed to the agent.
        :param kwargs: Additional keyword arguments passed to the agent.
        """
        super().__init__(
            name="Open Redirect Agent",
            instructions=OPEN_REDIRECT_AGENT_INSTRUCTIONS,
            sess_id=session_id,
            goal="Validate and exploit Open Redirect vulnerabilities via low-noise payloads.",
            success_criteria="Successfully validate and exploit Open Redirect vulnerabilities with low-noise payloads.",
            tools=[PerplexitySearch(cache_results=True), ShellGuardedToolkit(cache_results=True), WebRequesterGuardedToolkit(vuln_type="open_redirect", cache_results=True, use_vpn=False, session_id=session_id)],
            parser_model=self.model,  # use the same model for parsing output
            *args,
            **kwargs
        )

REDIRECT_PAYLOADS = [
    "https://example.com",
    "//example.com",
    "%2F%2Fexample.com"
]

def _is_js_redirect_with_payload(body: str, payload: str) -> bool:
    """
    Detects if a JavaScript-based redirect in the response body uses the provided payload as the redirect target.

    This function searches for common JavaScript redirection patterns such as:
        - location.href = "https://example.com"
        - location.replace = "https://example.com"

    It ensures that the payload appears specifically as the assigned value in a redirection statement,
    rather than elsewhere in the page, reducing false positives.

    Parameters:
        body (str): The raw HTML or JavaScript content of the HTTP response.
        payload (str): The exact payload string (e.g., a URL) to match in redirect assignments.

    Returns:
        bool: True if a JavaScript redirect to the payload is found, False otherwise.
    """
    pattern = re.compile(
        r"""(?:location\.href|location\.replace|window\.location|document\.location)\s*=\s*['"]{}['"]""".format(
            re.escape(payload)), re.IGNORECASE
    )

    return bool(pattern.search(body))

def _detect_redirect(request_response: RequestResponsePair, param: str, payload: str) -> OpenRedirectParamResult:
    """
    Analyzes an HTTP response to detect potential open redirect behavior based on a given payload.

    This function inspects the response for multiple types of redirect mechanisms that may indicate
    the presence of an open redirect vulnerability. It looks for:

    1. HTTP 3xx Redirects via the 'Location' header.
    2. HTML-based Meta Refresh redirects.
    3. JavaScript-based redirects using location assignment or redirection functions.
    4. HTTP 'Refresh' header redirects.

    If any of the vulnerabilities is found, it will return a ParamResult immediately, so it is not comprehensive, but it saves time.

    Parameters:
        request_response (RequestResponsePair): The HTTP request & response pair to analyze.
        param (str): The query or form parameter name used to inject the payload.
        payload (str): The injected payload string used to attempt the redirect.

    Returns:
        OpenRedirectParamResult: Each ParamResult contains:
                    (vulnerable_url, method, param, payload, potentially_vulnerable, redirect_type)
                    where redirect_type is one of:
                        - "Location Header"
                        - "Meta Refresh"
                        - "JS Redirect"
                        - "HTTP Refresh Header"
    """
    # Check Location header
    redirected_to = request_response.response.response_headers.get("Location", "")
    if payload in redirected_to:
        logger.info(f"[!!!] {request_response.request.request_method} Location header redirect via '{param}': {request_response.request.request_url}")
        return OpenRedirectParamResult(
            endpoint_url=request_response.request.request_url,
            method=request_response.request.request_method,
            param=param,
            payload=payload,
            potentially_vulnerable=True,
            redirect_type=RedirectType.LOCATION_HEADER,
        )

    # Check meta refresh
    soup = BeautifulSoup(request_response.response.response_body, "html.parser")
    meta = soup.find("meta", attrs={"http-equiv": "refresh"})
    if meta:
        content = meta.get("content", "")
        match = re.search(r'url=([^;]+)', content, re.IGNORECASE)
        if match and payload in match.group(1):
            logger.info(f"[!!!] {request_response.request.request_method} Meta refresh redirect via '{param}': {request_response.request.request_url}")
            return OpenRedirectParamResult(
                endpoint_url=request_response.request.request_url,
                method=request_response.request.request_method,
                param=param,
                payload=payload,
                potentially_vulnerable=True,
                redirect_type=RedirectType.META_REFRESH,
            )

    # Check JS-based redirects
    if _is_js_redirect_with_payload(request_response.response.response_body, payload):
        logger.info(
            f"[!!!] {request_response.request.request_method} JS-based redirect via '{param}': {request_response.request.request_url}")
        return OpenRedirectParamResult(
            endpoint_url=request_response.request.request_url,
            method=request_response.request.request_method,
            param=param,
            payload=payload,
            potentially_vulnerable=True,
            redirect_type=RedirectType.JS_REDIRECT,
        )

    # Check Refresh header
    refresh_header = request_response.response.response_headers.get("Refresh", "")
    if payload in refresh_header:
        logger.info(f"[!!!] {request_response.request.request_method} HTTP Refresh header redirect via '{param}': {request_response.request.request_url}")
        return OpenRedirectParamResult(
            endpoint_url=request_response.request.request_url,
            method=request_response.request.request_method,
            param=param,
            payload=payload,
            potentially_vulnerable=True,
            redirect_type=RedirectType.HTTP_REFRESH_HEADER,
        )

    return OpenRedirectParamResult(
        endpoint_url=request_response.request.request_url,
        method=request_response.request.request_method,
        param=param,
        payload=payload,
        potentially_vulnerable=False,
        redirect_type=RedirectType.NOT_VULNERABLE,
    )

async def _check_open_redirects(web_requester: WebRequesterTool, target_url: str, target_param: str, payload: str, request_body: Optional[Any] = None) -> ParamResultList:
    """
    Check if a payload is reflected in potentially vulnerable redirects.

    Args:
        web_requester: Instance of WebRequesterTool.
        target_url (str): The target URL with the payload to check for reflection.
        target_param (str): The target parameter name.
        payload (str): Payload to check for reflection.
        request_body (Optional[Any]): The payload of the POST request to check for reflection.
    Returns:
        ParamResultList: The list of ParamResult objects returned from detect_redirect.
    """
    param_result_list = ParamResultList(param_result_list=[])
    method = "POST" if request_body else "GET"

    try:
        response = await (
            web_requester.arun_web_requester(url=target_url, method=method, data=request_body)
            if request_body
            else web_requester.arun_web_requester(url=target_url, method=method)
        )
        req_resp_list = json.loads(response)
    except (json.JSONDecodeError, Exception) as e:
        logger.error(f"Failed to parse response JSON or make request: {e}")
        return ParamResultList(param_result_list=[OpenRedirectParamResult(
            endpoint_url=target_url,
            method=method,
            param=target_param,
            payload=payload,
            potentially_vulnerable=False,
            redirect_type=RedirectType.ERROR,
            notes=f"Request or JSON parsing failed: {e}"
        )])

    for req_resp in req_resp_list:
        req_resp_obj = RequestResponsePair.model_validate_json(json.dumps(req_resp))
        # Redirect to example.com will yield no response as the site does not exist
        if req_resp_obj.response:
            param_result = _detect_redirect(req_resp_obj, target_param, payload)
            if target_url in param_result.endpoint_url:
                param_result_list.param_result_list.append(param_result)

    return param_result_list

async def check_open_redirects_get_and_post(target_url: str, target_param: str, request_body: Optional[Any] = None) -> ParamResultList:
    """
    Tests a given URL for potential open redirect vulnerabilities via both GET and POST methods.

    This function attempts to identify if user-controllable redirect parameters
    (e.g., ?url=, ?redirect=, etc.) can be exploited to redirect the user to an attacker-controlled domain.

    It checks for four main types of redirects:
    1. HTTP Header Redirects (via 3xx Location headers)
    2. Meta Refresh Tag Redirects (e.g., <meta http-equiv="refresh">)
    3. JavaScript-Based Redirects (e.g., window.location = ...)
    4. HTTP 'Refresh' header redirects.

    Parameters:
        target_url (str): The URL to test for open redirect vulnerabilities.
        target_param (str): The parameter to test for open redirect vulnerabilities.
        request_body (Optional[Any]): Optional POST request body to test for open redirect vulnerabilities.

    Returns:
        ParamResultList: A list of detected redirect findings. Each ParamResult contains:
                        (vulnerable_url, method, param, payload, potentially_vulnerable, redirect_type)
                        where redirect_type is one of:
                            - "Location Header"
                            - "Meta Refresh"
                            - "JS Redirect"
                            - "HTTP Refresh Header"
    """
    web_requester = WebRequesterTool(start_with_vpn=False, use_vpn=False)
    final_result_list = ParamResultList(param_result_list=[])

    for payload in REDIRECT_PAYLOADS:
        # --- GET Request ---
        parsed_url = urlparse(target_url)
        query = parse_qs(parsed_url.query)
        query[target_param] = [payload]
        get_query = urlencode(query, doseq=True)
        get_url = urlunparse(parsed_url._replace(query=get_query))
        get_result_list = await _check_open_redirects(web_requester, get_url, target_param, payload)
        final_result_list.param_result_list.extend(get_result_list.param_result_list)

        # --- POST Request ---
        post_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, '', '', ''))
        post_body = None
        if request_body is not None:
            if isinstance(request_body, dict):
                post_body = deepcopy(request_body)
                post_body[target_param] = payload
            elif isinstance(request_body, str):
                parsed_body = parse_qs(request_body)
                parsed_body[target_param] = [payload]
                post_body = urlencode(parsed_body, doseq=True)
        else:
            post_body = f"{target_param}={payload}"
        post_result_list = await _check_open_redirects(web_requester, post_url, target_param, payload, post_body)
        final_result_list.param_result_list.extend(post_result_list.param_result_list)

    return final_result_list

async def _run_open_redirect_agent(prompt: str, open_redirect_agent: OpenRedirectAgent, response_formatter_agent: ResponseFormatterAgent) -> ParamResultList:
    """
    Tests for Open Redirect vulnerabilities.

    Stores open redirect testing result into the FinalParamResult dataclass.

    Args:
        prompt (str): User prompt to run XSS Agent.
        open_redirect_agent (OpenRedirectAgent): OpenRedirectAgent instance.
        response_formatter_agent (ResponseFormatterAgent): Response formatter agent.

    Returns:
        ParamResultList: Dataclass containing a list of ParamResult instances.
    """
    resp = await open_redirect_agent.arun(
        prompt,
        stream=STREAM_RESPONSES
        )
    
    if STREAM_RESPONSES:
        async for chunk in resp: 
            pass
        resp = open_redirect_agent.run_response
        
    resp = await response_formatter_agent.arun(resp.content)
    if isinstance(resp.content, ParamResultList):
        return resp.content
    else:
        logger.error(f"Failed to convert agent response to ParamResultList. Got {type(resp.content)}.")
        raise ValueError(f"Failed to convert agent response to ParamResultList.")

@stream_status()
async def run_open_redirect_agent(tag_recon_info: TagReconInfo, session_id: str) -> FinalTestingResult:
    """
    Tests for Open Redirect vulnerabilities.

    Stores open redirect testing result into the OpenRedirectTestingResult dataclass.

    Args:
        tag_recon_info (TagReconInfo): Vulnerability assessment output containing the endpoint and parameters that should undergo Open Redirect testing.
        session_id (str): Unique session ID number.

    Returns:
        FinalTestingResult: OpenRedirectTestingResult instance that is parsed by ResponseFormatterAgent.
    """
    open_redirect_agent = OpenRedirectAgent(
        session_id=session_id, 
        show_tool_calls=True,
        debug_mode=DEBUG_MODE,
        )
    response_formatter_agent = ResponseFormatterAgent(response_model=ParamResultList)
    open_redirect_testing_result = FinalTestingResult(endpoint=tag_recon_info.url, final_param_result_list={})

    open_redirect_testing_result.final_param_result_list[tag_recon_info.vuln_param] = []
    base_prompt = (f"The vulnerable endpoint URL is: {tag_recon_info.url}. The parameter that you are requested to test is: {tag_recon_info.vuln_param}. "
                         f"This endpoint expects all these other parameters: {tag_recon_info.param_set}. Only test {tag_recon_info.vuln_param} while keeping all other parameters at default values. "
                         f"For the other parameters, just try to fill some default values or values that the webserver will accept. ")

    target_url = tag_recon_info.url
    request_body = None

    # Run diagnostic payload and observe response
    if tag_recon_info.method == "GET":
        # Format GET request
        parsed_url = urlparse(tag_recon_info.url)
        parsed_query = parse_qs(tag_recon_info.param_set)
        encoded_query = urlencode(parsed_query, doseq=True)
        target_url = urlunparse(parsed_url._replace(query=encoded_query))

    if tag_recon_info.enctype == "application/x-www-form-urlencoded":
        request_body = tag_recon_info.param_set
    elif tag_recon_info.enctype == "application/json":
        # TODO: idk i am assuming it will be a json string
        try:
            request_body = json.loads(tag_recon_info.param_set)
        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse JSON request body: {e}")
            request_body = None
    elif tag_recon_info.enctype == "multipart/form-data":
        # TODO: add support for multipart/form-data
        pass

    basic_result = await check_open_redirects_get_and_post(target_url=target_url, target_param=tag_recon_info.vuln_param, request_body=request_body)
    open_redirect_testing_result.final_param_result_list[tag_recon_info.vuln_param].append(FinalParamResult(result_type=ResultType.BASIC, param_result_list=basic_result))

    # Run advanced payloads via OpenRedirectAgent
    advanced_user_prompt = (f"We previously tested some basic payloads: {basic_result.model_dump_json()}"
                            f"{base_prompt}\nPlease craft your own low-noise context-aware payloads to avoid WAF detection. Feel free to try more than one payload.\n")
    try:
        advanced_result = await _run_open_redirect_agent(advanced_user_prompt, open_redirect_agent, response_formatter_agent)
        open_redirect_testing_result.final_param_result_list[tag_recon_info.vuln_param].append(FinalParamResult(result_type=ResultType.ADVANCED, param_result_list=advanced_result))
    except Exception as e:
        logger.error(f"Failed to run open redirect agent: {e}.")
        raise

    logger.info(f"{open_redirect_testing_result.model_dump_json(indent=2)}")
    return open_redirect_testing_result
