import json
import os 
import asyncio
from langfuse import get_client, observe
from typing import List, Optional
from custom_agents.base import CustomAgent
from custom_agents.response_formatter_agent import ResponseFormatterAgent
from tools.shell_tools.safe_shell_tool import ShellGuardedToolkit
from agno.utils.log import logger
from tools.web_requester.web_requester import WebRequesterGuardedToolkit
from tools.common import parse_json_from_output
from config.globals import STREAM_RESPONSES, DEBUG_MODE
from textwrap import dedent
from schema.recon import (
    ReconOutput,
    ReconEndpointOutput,
    KatanaAnalysisOutput,
    VulParamSetList,
)
from dotenv import load_dotenv
from server.sink import stream_status

load_dotenv()

# Define the instructions in code first for easier debugging; can use langfuse prompt versioning in future
# langfuse_client = get_client()
# prompt_handler = langfuse_client.get_prompt(name="recon_agent_prompt", label="latest")
# # prompt managed using langfuse, available at https://langfuse.watsonchua.pro/project/cmdgthopp0006za072xzrxrcl/prompts/recon_agent_prompt
# RECON_INSTRUCTIONS = prompt_handler.prompt
RECON_INSTRUCTIONS = """<task>
  You are an **active reconnaissance agent**. 
  For each provided URL you will receive an output from a Katana tool containing 
   - an endpoint 
   - the parameters
   - and other relevant info about the endpoint 
   
  In addition, you might also be given one or both of these, if available:  
  - Output from a fingerprinting tool (technologies, headers, params)  
  - Output from a Googleâ€‘dorking tool (search results/snippets)  
  
  Your job is to perform **active recon only**, using minimal HTTP probes (via the web requestor tool, `curl`, or their equivalent), to detect the set of parameters which are susceptible to the vulnerabilities, SQLi, XSS, XXE, and OpenRedirect.

  Objectives, example methodologies and example responses which guide you to identify vulnerabilities are provided below in the *Vulnerability Tests* section, in markdown format. The methodologies and examples provided are just for reference and non-exhaustive. Add your own methodologies to do a comprehensive analysis, where necessary. You are given access to both a bash tool and a web requestor tool, make use of them effectively.

  ========================================================================
  # Vulnerability Tests

  ## SQL Injection (SQLi) Identification Methodology
  
  ### Objective
  Identify user input points (URL parameters, form fields, POST data) that likely interact with a backend **SQL database**, and may be vulnerable to **SQL Injection (SQLi)**.
  
  > ðŸ” Focus on **passive observation only** â€” do not inject test payloads. The goal is to identify potential DB-interacting inputs.
  
  ---
  
  ### ðŸ” Methodology
  
  Use **field names**, **contextual clues**, and **behavioral hints** to identify parameters that likely influence database queries.
  For this purpose, you will only use the web_requester_sqli_payload tool to send web requests
  
  ---
  
  ### 1. URL Parameters (GET Requests)
  
  Look for parameters in the URL that suggest querying or filtering data from a database.
  
  **Examples:**
  - `search`, `query`, `keyword`, `lookup`, `filter`  
    âž¤ `https://www.example.com/?search=laptop`
  
  - `id`, `product_id`, `user_id`, `item`, `order`  
    âž¤ `https://www.example.com/?product_id=123`
  
  These are commonly used in SQL queries like:  
  `SELECT * FROM products WHERE product_id = 123`
  
  ---
  
  ### 2. Form Fields (POST Requests)
  
  Forms that collect structured user input (e.g., login forms, filters, profile updates) are likely to interact with a SQL database.
  
  **Common field names:**
  - `username`, `password`, `email`, `name`, `address`, `search`, `comment`, `filter`, `amount`, `category`
  
  **Example 1 â€“ Login Form**
  - **Endpoint:** `https://www.example.com/login`
  - **POST Body:**
      ```
      username=john&password=secret123
      ```
  
  Likely used in SQL like:  
  `SELECT * FROM users WHERE username = 'john' AND password = '...'`
  
  **Example 2 â€“ Search Form**
  - **Endpoint:** `https://www.example.com/search`
  - **POST Body:**
      ```
      keyword=monitor&sort=price
      ```
  
  These fields may influence `WHERE`, `ORDER BY`, or `LIMIT` clauses.
  
  ---
  
  ### 3. Contextual Clues (Implied DB Interaction)
  
  Even if not obvious, fields that modify how content is shown likely influence SQL.
  
  **Examples:**
  - `ref`, `code`, `uuid`, `slug`, `session_id`
  - `date`, `start_date`, `end_date`, `range`
  - `limit`, `offset`, `page`, `sort`
  
  **Example:**  
  `https://www.example.com/logs?start_date=2023-01-01&limit=50`  
  â†’ Often results in SQL like:  
  `SELECT * FROM logs WHERE date >= '2023-01-01' LIMIT 50`
  
  ---
  
  ### Passive Observation Tips
  
  When analyzing a form or request:
  
  - Does changing the input **change the data shown** on the page?
  - Is the input controlling **search, sorting, or filtering**?
  - Inspect requests using browser **DevTools â†’ Network** to see:
    - What data is sent
    - How the server responds
    - If there's structured query-like behavior
  
  ---
  
  ### Passive Detection Checklist
  
  - [ ] Parameter name implies DB use (`id`, `search`, `filter`, `sort`, `page`)
  - [ ] Changing value changes visible content (e.g., search results, records)
  - [ ] Field is part of login, search, filter, or profile update
  - [ ] Present in POST body or form data
  - [ ] Used for pagination, sorting, or date filtering
  - [ ] Data is reflected in page content or structured output (e.g., tables, lists)
  
  ---
  
  ### Notes
  
  - Passive observation is for mapping possible SQL injection surfaces.
  - It does **not confirm vulnerabilities**, but identifies high-probability fields.
  - Do **not inject or fuzz** at this stage â€” just watch how the input is used.
  ========================================================================

  ## Cross-Site Scripting (XSS) Identification Methodology
  
  ### Objective
  Identify input fieldsâ€”via URLs, form submissions, or POST requestsâ€”that are **reflected back into the page**. These reflection points may be vulnerable to **Cross-Site Scripting (XSS)** if not properly sanitized.
  
  ---
  
  ### Methodology
  
  Use **field names**, **contextual clues**, and **visual inspection** to find values that may be user-controlled and reflected into the page.
  For this purpose, you will only use the web_requester_xss_payload tool to send web requests
  
  ---
  
  ### 1. URL Parameters (GET Requests)
  
  Look for parameters whose values appear back on the webpage, especially those controlling user-facing content.
  
  **Examples:**
  - `search`, `q`, `message`, `name`, `title`, `query`
    - **Example:** `https://www.example.com/?search=laptop`  
      - The string `laptop` may appear in a heading, paragraph, or form field (e.g., *"Showing results for laptop"*).
  
  - `status`, `error`, `note`, `alert`, `msg`
    - **Example:** `https://www.example.com/?error=invalid+input`  
      - Message appears in a notification or alert box.
  
  ---
  
  ### 2. Form Fields (User-Input Fields in the UI)
  
  Forms that take user input and then display it (either on the same page or after submission) are key targets for reflection.
  
  **Examples:**
  - Contact forms, search bars, comment boxes, registration forms
  - Fields such as:
    - `name`, `email`, `message`, `subject`, `feedback`, `username`, `description`
  
  **What to Look For:**
  - Is the entered value shown again on the **same page** after submission?
  - Is it shown on the **next page**, e.g., a confirmation page?
  
  **Passive Testing Approach:**
  - Submit the form with **regular input** (no script/payload).
  - Observe whether your input appears on the resulting page or in the page's HTML.
  
  ---
  
  ### 3. POST Requests (Non-URL Data Submission)
  
  While you can't see POST parameters directly in the URL, they are often used in forms and APIs. These can also lead to reflected XSS if the server reflects them in a response.
  
  **How to Observe Passively:**
  - Use developer tools (e.g. browser DevTools â†’ Network tab) to monitor POST submissions.
  - Check if any submitted data (e.g., from a login form, feedback form, etc.) appears in the response body or rendered page.
  
  **Example Flow:**
  1. Fill in a form like:
     - `name=John`, `message=Hello there!`
  2. Submit.
  3. On the result page, observe:
     - Is "John" or "Hello there!" displayed back?
     - Is it part of HTML output (view source) or DOM (Inspect Element)?
  
  ---
  
  ### Passive Observation Checklist
  
  - [ ] Does input appear in page **headings**, **paragraphs**, or **alert messages**?
  - [ ] Is it reflected in **form field values** (e.g., pre-filled input boxes)?
  - [ ] Is it used in **JavaScript variables** or inline scripts (e.g. `var msg = "your input";`)?
  - [ ] Is input embedded in **HTML attributes**, such as `value`, `alt`, `title`, etc.?
  - [ ] Is the input shown in **error messages**, **confirmation pages**, or **results**?
  
  ---
  
  ### Notes
  
  - **No payloads** should be injected during this step â€” rely on **observation only**.
  - Input reflection **does not confirm a vulnerability**, but is a **strong indicator** of a potential XSS risk.
  - Combine:
    - Field naming patterns,
    - Form behavior,
    - Network traffic analysis, and
    - DOM inspection
  
  to build a list of candidate fields for deeper (safe and controlled) testing later.
  ========================================================================

  ## XML External Entity (XXE) Identification Methodology
  
  ### Objective
  Identify input points (URLs, form fields, APIs) that **accept XML payloads** as input. These may be vulnerable to **XXE (XML External Entity)** attacks if the backend XML parser is misconfigured.
  
  ---
  
  ### Methodology
  
  Use **parameter naming**, **content-type clues**, and **form/endpoint behavior** to identify XML-accepting inputs â€” without sending malicious payloads.
  For this purpose, you will only use the web_requester_xxe_payload tool to send web requests

  ---
  
  ### 1. Based on Parameter Names and Context
  
  Look for field names or API endpoints that suggest XML input.
  
  **Common indicators:**
  - Parameter names: `xml`, `data`, `request`, `payload`, `document`, `body`
  - API endpoints or upload pages that reference:
    - Feeds, documents, config files, or structured data uploads
  
  **Example URLs:**
  - `https://www.example.com/api/upload?format=xml`
  - `https://www.example.com/submit?data=<note><to>John</to></note>`
  - `https://api.example.com/parse?body=<invoice><id>123</id></invoice>`
  
  **What to Look For:**
  - Hints that the system is expecting a **structured XML document**
  - Parameters that start with `<`, contain tags (`<tag>`), or resemble XML
  
  ---
  
  ### 2. Look at Content-Type Headers (for APIs or POST requests)
  
  If you're observing network traffic (e.g., using browser DevTools or a proxy like Burp Suite), check for:
  - `Content-Type: application/xml`
  - `Content-Type: text/xml`
  - `Accept: application/xml`
  
  These headers often indicate that the server expects or returns XML.
  
  **What to Look For:**
  - Any endpoint or client behavior where XML is the standard communication format
  - APIs that support both JSON and XML (`format=xml` is a common switch)
  
  ---
  
  ### 3. Passive Behavior Clues
  
  Without injecting any payloads, you can passively test for XML-handling behavior:
  
  - Submit a **well-formed XML snippet** (like a basic structure) via a form or API that claims to accept structured input.
  - Observe if the application:
    - Accepts the XML without error
    - Parses it and reflects any part of it back
    - Returns an XML-based response
    - Returns **parsing errors** (e.g., "invalid XML", "malformed document")
  
  **Example XML for passive testing:**
  
      <note>
          <to>Alice</to>
          <from>Bob</from>
      </note>
  
  You can observe:
  - Whether the app attempts to parse it
  - If the values appear in the response or UI
  - If the server gives XML-specific error messages
  
  ---
  
  ### Passive Detection Checklist
  
  - [ ] Parameter name suggests structured or XML input (`xml`, `body`, `data`, `request`, `document`)
  - [ ] Endpoint uses or supports XML (`format=xml`, XML API docs, `.xml` URLs)
  - [ ] Form or API uses `Content-Type: application/xml` or `text/xml`
  - [ ] Server accepts basic XML input without error
  - [ ] Server reflects XML content or errors related to XML parsing
  - [ ] Response format is XML or includes XML headers
  
  ---
  
  ### Notes
  
  - This process involves **no payloads or malicious DTDs** â€” only passive detection of XML-handling behavior.
  - If an endpoint:
    - Accepts XML input  
    - Parses it  
    - Responds with XML-based output or parsing errors  
    â†’ it may be a candidate for further XXE testing.
  
  ---
  
  ### Reminder
  
  Full XXE exploitation should only be done in authorized environments with permission. Passive identification is an essential first step before deeper analysis.
  ========================================================================

  ## Open Redirect Identification Methodology

  ### Objective
  Identify URL parameters or form inputs that may be used by the server to **redirect users to another page or domain**, potentially enabling an **open redirect vulnerability**.
  
  ---
  
  ### Methodology
  
  Use **field naming**, **context clues**, and **browser observation** to detect whether a parameter is used for redirection and if it accepts **URL-like input**.
  For this purpose, you will only use the web_requester_open_redirect_payload tool to send web requests

  ---
  
  ### 1. Based on Parameter Names
  
  Certain parameter names are commonly associated with redirects or return URLs.
  
  **Examples of common redirect-related parameters:**
  - `redirect`, `redirect_uri`, `return`, `return_to`, `url`, `next`, `dest`, `destination`, `continue`, `go`, `target`
  
  **Example URLs:**
  - `https://www.example.com/login?redirect=https://sub.example.com/dashboard`
  - `https://www.example.com/logout?return_to=/login`
  - `https://www.example.com/?next=/checkout`
  
  **What to look for:**
  - Parameters that contain a **full URL**, a **path**, or a **partial path**
  - URLs that seem to control where the user is taken **after login, logout, form submission, or access denial**
  
  ---
  
  ### 2. Observe Redirection Behavior
  
  **Passive steps to confirm redirection behavior (no tampering):**
  1. Visit the URL in a browser.
  2. See if you are **automatically redirected** to the path or domain specified in the parameter.
  3. Pay attention to the browser's **address bar**:
     - Does the destination match the value of the parameter?
     - Is the page taking you to a **different domain or subdomain**?
  
  ---
  
  ### 3. Contextual Clues (Implied Redirects)
  
  Even without obvious names, some URLs may redirect based on parameters passed during actions like:
  - OAuth flows (`redirect_uri`)
  - SSO logins (`return_to`)
  - Post-login navigation (`next`)
  - Email confirmation links or invite URLs
  
  **Examples:**
  - `https://www.example.com/auth?redirect_uri=https://app.example.com/dashboard`
  - `https://www.example.com/reset?continue=https://www.example.com/login`
  
  If the destination changes based on the parameter â€” **even internally** â€” it's worth noting.
  
  ---
  
  ### 4. How to Passively Verify
  
  Use only **safe, observational techniques**:
  
  - Check browser redirects â€” do you end up at the parameter's URL or path?
  - Monitor network activity using **DevTools â†’ Network tab** to inspect 3xx redirect responses.
  - Use **"View Source"** or **"Inspect"** to check if the value is used in:
    - `window.location`, `meta refresh`, or anchor (`<a href>`) tags
    - Embedded JavaScript handling redirection
  - Observe whether a link or button action **leads to a location controlled by the parameter**
  
  ---
  
  ### Passive Detection Checklist
  
  - [ ] Parameter value **looks like a URL or path**
  - [ ] Parameter name suggests redirect intent (e.g., `redirect`, `next`, `return_to`)
  - [ ] Visiting the URL results in a **redirect to the parameter's value**
  - [ ] Destination can be a **different domain** or **external URL**
  - [ ] Parameter value is **used in JavaScript** or `meta refresh` redirection
  - [ ] Redirection occurs **after login, logout, or error message**
  
  ---
  
  ### Notes
  
  - This is a **non-exploitative approach** â€” do **not inject external domains** or modify values at this stage.
  - If a parameter:
    - Accepts a URL/path
    - Redirects users to it (even internally)
  
  It may be a candidate for **open redirect** and should be logged for further investigation.
  ========================================================================
  
</task>
<additional_instructions>
    For each parameter set which you are testing for the endpoint:
      - First, think step by step on how you want to perform the test, using the tools available.
      - Then, execute the test.
      - Note the **observation**: reflection, error, redirect etc.
      - Summarize the result: `"vulnerable"` or `"not vulnerable"` for each vulnerability type.
      - Perform more tests wherever necessary if the test is inconclusive.


    Finally, give your output as a json parseable markdown string in the following format for each endpoint.
    ```json
      {schema}
    ```
</additional_instructions>""".format(
    schema=json.dumps(VulParamSetList.model_json_schema(), indent=2),
)

class ReconAgent(CustomAgent):
    def __init__(
        self,
        name: str,
        session_id: str,
        instructions: Optional[str] = RECON_INSTRUCTIONS,
        context: Optional[dict] = None,
        tools: Optional[List] = None,
        *args,
        **kwargs,
    ):
        """
        Extend Agno Agent with context-aware run methods and session history saving.

        Args:
            name (str): Name of the agent.
            session_id (str): Unique session ID number.
            instructions (str): System prompt / instructions.
            context (Optional[str]): Persistent context.
            tools (Optional[List]): Tool list for agent.
        """
        self.tools = [
            ShellGuardedToolkit(cache_results=True),
            WebRequesterGuardedToolkit(vuln_type="sqli", cache_results=True, use_vpn=False, session_id=session_id),
            WebRequesterGuardedToolkit(vuln_type="xss", cache_results=True, use_vpn=False, session_id=session_id),
            WebRequesterGuardedToolkit(vuln_type="xxe", cache_results=True, use_vpn=False, session_id=session_id),
            WebRequesterGuardedToolkit(vuln_type="open_redirect", cache_results=True, use_vpn=False, session_id=session_id),
            WebRequesterGuardedToolkit(vuln_type="general", cache_results=True, use_vpn=False, session_id=session_id),
        ]

        self.tools.extend(tools or [])

        logger.debug(f"ReconAgent initialized with tools: {tools}")
        super().__init__(
            name=name,
            instructions=instructions,
            sess_id=session_id,
            context=context or {},
            goal="Conduct active reconnaisance to gather information regarding target.",
            success_criteria="Successfully assessed if parameter set are vulnerable to web vulnerabilities",
            tools=self.tools,
            *args,
            **kwargs,
        )

@stream_status(
    input_metadata_fields=['katana_analysis_output', 'session_id'],
    log_output=True
)
async def run_recon_agent(
    katana_analysis_output: KatanaAnalysisOutput, session_id: str
) -> ReconOutput:
    """
    Performs reconnaissance analysis on endpoints discovered by Katana.

    Analyzes each endpoint and HTTP method to identify parameters that should be
    tested for web vulnerabilities.

    Args:
        katana_analysis_output: Katana analysis results with endpoints and methods
        session_id: Unique session identifier for tracking

    Returns:
        ReconOutput: Analysis results with vulnerability assessments per endpoint

    Raises:
        ValueError: When agent response cannot be parsed as JSON
    """
   
    katana_endpoints = katana_analysis_output.endpoints
    recon_output = ReconOutput(assessments=[])

    for katana_endpoint in katana_endpoints:
        url = katana_endpoint.url
        
        technologies = katana_endpoint.technologies
        methods = katana_endpoint.methods
        passive_evidence = (
            katana_endpoint.passive_evidence.model_dump_json(indent=2)
            if katana_endpoint.passive_evidence
            else "No previously found evidence"
        )

        endpoint_output = ReconEndpointOutput(
            url=url,
            technologies=technologies,
            vuln_param_sets=[],  # Initialize with empty list, will be populated later
        )


        for method in methods:
            recon_agent = ReconAgent(
                name="Recon Agent",
                session_id=session_id,
                debug_mode=DEBUG_MODE
            )
            
            response_formatter_agent = ResponseFormatterAgent(
                response_model=VulParamSetList,
                debug_mode=DEBUG_MODE
            )
            
            prompt = f"""Do a reconnaissance to check which of the parameters of the endpoint {url} should be analyzed for web vulnerabilities given the following information: {method.model_dump_json(indent=2)} and possible evidence for vulnerabilities: {passive_evidence}. Do not actively exploit with payloads, just do passive vulnerability identification."""
            
            response = await recon_agent.arun(
                prompt=prompt,
                summarize_on_fail=True,
                stream=STREAM_RESPONSES,
            )
            
            if STREAM_RESPONSES:
                async for chunk in response: 
                    pass
                response = recon_agent.run_response
            
            formatted_response = await response_formatter_agent.arun(response.content)
            endpoint_output.vuln_param_sets.extend(
                formatted_response.content.vuln_param_sets
            )

        recon_output.assessments.append(endpoint_output)
        
    return recon_output


if __name__ == "__main__":
    import uuid
    from urllib.parse import parse_qs, urlencode
    from schema.state import GlobalState
    from tools.state_management import (
        init_db,
        create_session,
        save_current_global_state,
    )
    from schema.recon import KatanaEndpoint, KatanaEndpointMethod

    # # PortSwigger SQLi lab for UNION attack
    # demo_endpoint = "https://0ad100ad04e73bc380c48f4f0016009b.web-security-academy.net/filter"
    # demo_qs = """category=Clothing%2c+shoes+and+accessories"""
    # demo_qs = urlencode(parse_qs(demo_qs), doseq=True)
    # target_parameter = "category"
    
    # Fire Extinguisher SQLi 
    demo_endpoint = "https://app.tuv-sud-psb.sg/FireExtSearch/"
    demo_qs = """__EVENTTARGET=&__EVENTARGUMENT=&__VIEWSTATE=%2FwEPDwUKMTI2ODU2ODExMA9kFgJmD2QWAgIDD2QWAgIFD2QWAgIBDw9kFgIeDGF1dG9jb21wbGV0ZQUDb2ZmZBgBBRljdGwwMCRNYWluQ29udGVudCRncmREYXRhDzwrAAwBCGZkb91ZqkIn7kLXN%2FDEI799XkHgZE2bWl2Ouapf%2Ff0Vjj8%3D&__VIEWSTATEGENERATOR=9B8E6F44&__EVENTVALIDATION=%2FwEdAANEZDZk90mUdhFMPeum3BZIHxqdRe3Ts9FuiYr%2BeBdnxp%2BI%2FHPZ86NEZcbXwR9jxA7opVEulydnRnlymEvGVJYw%2FHgeLWyLuDisiNlnw%2Bz7ig%3D%3D&ctl00%24MainContent%24txtSearch=123123*&ctl00%24MainContent%24btnSearch=Search"""
    demo_qs = urlencode(parse_qs(demo_qs), doseq=True)
    target_parameter = "ctl00$MainContent$txtSearch"

    # Mock session
    init_db()
    session_id = str(uuid.uuid4())
    create_session(session_id)
    current_global_state = GlobalState(
        goal="test",
        target=demo_endpoint,
        session_id=session_id,
        task_list={},
    )
    save_current_global_state(session_id, current_global_state)

    mock_input = KatanaAnalysisOutput(
        endpoints=[
            KatanaEndpoint(
                url=demo_endpoint,
                methods=[
                    KatanaEndpointMethod(
                        method="GET",
                        parameters=[{target_parameter: []}],
                        parameter_sets=[demo_qs],
                    )
                ],
            )
        ]
    )
    result = asyncio.run(run_recon_agent(mock_input, session_id))
    print(result)
