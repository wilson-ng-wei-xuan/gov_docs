from typing import List, Optional, Dict, Any
from custom_agents.base import CustomAgent
from agno.tools.thinking import ThinkingTools
from tools.shell_tools.safe_shell_tool import ShellGuardedToolkit
from agno.tools.serper import SerperTools
from urllib.parse import parse_qs
from textwrap import dedent
import os
import re
import json
from schema.recon import KatanaAnalysisOutput, KatanaEndpoint, FingerprintOutput, FingerprintInfo, FingerprintInfoList
from schema.request_response import RequestResponsePair
from tools.web_requester.web_requester import WebRequesterTool
from custom_agents.response_formatter_agent import ResponseFormatterAgent
from config.globals import DEBUG_MODE, STREAM_RESPONSES
from agno.utils.log import logger
from config.context import current_sink
from server.sink import StreamEvent, stream_status

RECON_INSTRUCTIONS = dedent(
            """\
                <task>
                    You are a fingerprinting agent tasked with identifying the technology stack, framework, libraries and determine their versions, to the best of your abilities, used by the website. These information will be used to identify vulnerabilities by the next agent.
                    You are given a list of URLs, together with their metadata to analyze, this includes the request method, request body, response headers, response body, techonologies identified by the previous web crawler agent.
                    You will be given a list as such:
                    [
                        {
                            "request_url":"https://example.org",
                            "request_method":"POST",
                            "request_body":{"aaa":"aaa","bbb":"bbb"},
                            "response_headers":{"ddd":"ddd","eee":"eee"},
                            "response_body":"zzzzzzz",
                            "technologies":["ASP"]
                        },
                        {
                            "request_url":"http://test.com?ccc=ccc",
                            "request_method":"GET",
                            "request_body":"",
                            "response_headers":{"fff":"fff","ggg":"ggg"},
                            "response_body":"xxxxxxx",
                            "technologies":["Next.js"]
                        }
                    ]
                    Your task is to iterate through every item in the list, identify the technology stack, libraries and determine their versions, to the best of your abilities, used by the website by looking at the following:
                    - URL (e.g. `Telerik` suggests using Telerik, `/system/sling.js` suggests using Adobe Experience Manager, `SitePages` suggest SharePoint, `wp-login.php` suggest WordPress)
                    - HTTP request URL and body parameters (e.g. `_VIEWSTATE` suggests .NET or Java which might be used for deserialization attack, `csrfmiddlewaretoken` suggests Django, `wpnonce` suggests WordPress)
                    - HTTP response headers (e.g. `PHPSESSID` suggests PHP, `ASP.NET_SessionId` suggests .NET, `Server: nginx` suggests Nginx, `X-Powered-By: Servlet` suggests Java)
                    - HTTP response body (e.g. `siteclienttag` suggests SharePoint, `__NEXT_DATA__` suggests Next.js, `{{ username }}` suggests JinJa or Twig or others, stacktrace error like `NullReferenceException: Object reference not` suggests .NET)
                    
                    You are to:
                        - Gather more information if you are unsure. If you need to use search engines to gather more information, use SerperTools to perform Google searches.
                        - Append your fingerprinting findings in the technologies field in the following format:
                    
                    ```json
                    [
                        {
                            "technologies":["ASP","Microsoft SharePoint","Slick Carousel 2.2"]
                        },
                        {
                            "technologies":["Next.js","Jinja2","jQuery 3.3.3"]
                        }
                    ]
                    ```
                </task>
            """
    )

class FingerprintAgent(CustomAgent):
    
    def __init__(self, name: str, session_id: str, instructions: Optional[str] = RECON_INSTRUCTIONS, context: Optional[dict] = None, tools: Optional[List] = None, *args, **kwargs):
        """
        Extend Agno Agent with context-aware run methods and session history saving.

        Args:
            name (str): Name of the agent.
            session_id (str): Unique session ID number.
            instructions (str): System prompt / instructions.
            context (Optional[str]): Persistent context.
            tools (Optional[List]): Tool list for agent.
        """
        
        # Other tools passed in will be ignored, we only use Katana and ThinkingTools for now
        tools = [
            SerperTools(api_key=os.getenv("SERPER_API_KEY")), 
            ShellGuardedToolkit(cache_results=True),
            #WebRequesterTool(cache_results=True, use_vpn=True, proxies="172.31.112.1:8080")
        ]

        super().__init__(
            name=name,
            instructions=instructions,
            sess_id=session_id,
            context=context or {},
            goal="Conduct active and passive reconnaisance to gather information regarding target.",
            success_criteria="Successfully gathered information regarding target",
            tools=tools,
            use_json_mode=True,
            *args, 
            **kwargs
        )

def extract_request_response_fields(data: List[RequestResponsePair]) -> List[Dict[str, Any]]:
    """
    Extracts key request and response fields from a RequestResponseList for fingerprint analysis.

    This includes request details (URL, method, body) and corresponding response details (headers, body),
    along with any associated notes (e.g., inferred technologies).

    Args:
        data (RequestResponseList): A list of request-response pairs returned from a web request tool.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries containing:
            - "request_url": str
            - "request_method": str
            - "request_body": Optional[str or bytes]
            - "response_headers": Optional[Dict[str, str]]
            - "response_body": Optional[str]
            - "technologies": Optional[List[str]] (from `notes`)
    """
    extracted = []

    for pair in data:
        request = pair.request
        response = pair.response

        extracted.append({
            "request_url": request.request_url,
            "request_method": request.request_method,
            "request_body": request.request_body,
            "response_headers": response.response_headers if response else None,
            "response_body": response.response_body if response else None,
            "technologies": pair.notes
        })

    return extracted

def extract_unique_parameter(katana_analysis_output: KatanaAnalysisOutput) -> FingerprintInfoList:
    """
    Extracts unique parameter names from the parameter_sets field of each method
    in the KatanaAnalysisOutput.

    Args:
        katana_analysis_output (KatanaAnalysisOutput): The parsed output containing endpoints and methods.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries with:
            - "url": str (endpoint URL)
            - "method": str (HTTP method)
            - "unique_parameters": List[str] (unique parameter names)
    """
    result = []

    for endpoint in katana_analysis_output:
        for method in endpoint.methods:
            unique_param_names = set()
            for parameter_set in method.parameter_sets:
                parsed = parse_qs(parameter_set)
                unique_param_names.update(parsed.keys())

            result.append(FingerprintInfo(
                url = endpoint.url,
                method = method.method,
                enctype = method.enctype,
                unique_parameters = sorted(unique_param_names)
            ))

    return FingerprintInfoList(endpoints=result)

async def make_request(url: str, method: str, param: Optional[Any] = None, headers: Optional[dict] = None, technologies: Optional[dict] = None, proxies: Optional[str] = None) -> List[RequestResponsePair]:
    """
    Sends an HTTP request to the specified URL and returns a list of structured request-response pairs.

    This function uses the WebRequesterTool to perform HTTP requests and parse the response data into
    a list of RequestResponsePair objects. Optionally includes payloads, headers, and proxy routing.
    If technology data is provided, it is stored in the `notes` field of the final response object.

    Args:
        url (str): The target URL to which the HTTP request is sent.
        method (str): The HTTP method to use (e.g., "GET", "POST").
        param (Optional[Any]): Optional payload to include in the request (as query parameters or body).
        headers (Optional[dict]): Optional HTTP headers to include in the request.
        technologies (Optional[dict]): Optional dictionary of detected technologies; stored in the `notes` field.
        proxies (Optional[str]): Optional proxy address to route the request through.

    Returns:
        List[RequestResponsePair]: A list of structured request-response pairs from the request.

    Raises:
        Exception: Logs and re-raises exceptions if the request fails or the response cannot be parsed.
    """
    try:
        web_requester = WebRequesterTool(proxies=proxies)
        if param:
            result = await web_requester.arun_web_requester(url=url, method=method, data=param, headers=headers)
        else:
            result = await web_requester.arun_web_requester(url=url, method=method, headers=headers)
        parsed_list = json.loads(result)
        final_result = [RequestResponsePair(**item) for item in parsed_list]
        if final_result:
            final_result[-1].notes = technologies
        return final_result
    except (json.JSONDecodeError, Exception) as e:
        logger.error(f"Failed to parse response JSON or make request: {e}")
        return final_result

@stream_status(
    input_metadata_fields=['katana_analysis_output', 'session_id'],
    log_output=True
)
async def run_fingerprint_agent(katana_analysis_output: KatanaAnalysisOutput, session_id: str, proxies: Optional[str] = None) -> KatanaAnalysisOutput:
    """
    Runs the fingerprinting agent on the provided Katana analysis output to enhance endpoint data with detected technologies.

    This function performs active analysis on each endpoint from the Katana scan by:
    - Iterating through all endpoints and their associated HTTP methods.
    - Building and sending requests using extracted parameter sets and content types.
    - Capturing request/response data and extracting structured fields.
    - Passing the structured data to a fingerprinting agent to analyze server responses.
    - Aggregating and updating identified technologies for each endpoint.
    - Reconstructing enriched KatanaEndpoint objects with updated fingerprint data.

    Args:
        katana_analysis_output (KatanaAnalysisOutput): Output from a Katana scan, containing analyzed endpoints, methods, and passive evidence.
        session_id (str): A unique session identifier for correlating the fingerprinting process.
        proxies (Optional[str]): Proxy server address to route outgoing HTTP requests (e.g., 'http://127.0.0.1:8080').

    Returns:
        KatanaAnalysisOutput: An updated version of the original Katana analysis output,
                              where each endpoint includes enriched technology information
                              obtained via active fingerprinting.
    """
    
    fingerprint_result = KatanaAnalysisOutput(endpoints=[])
    katana_endpoints = katana_analysis_output.endpoints
    for katana_endpoint in katana_endpoints:
        base_technologies = katana_endpoint.technologies or []

        for method in katana_endpoint.methods:
            fingerprint_agent = FingerprintAgent(
                name="Fingerprint agent", 
                session_id=session_id, 
                # show_tool_calls=True,
                debug_mode=DEBUG_MODE
                )
            response_formatter_agent = ResponseFormatterAgent(
                response_model=FingerprintOutput,
                debug_mode=DEBUG_MODE
                )
    
            param_set = method.parameter_sets[0] if method.parameter_sets else ""
            if method.enctype:
                headers = {"Content-Type": method.enctype}
            else:
                headers = {}
            request_result = await make_request(katana_endpoint.url, method.method, param_set, headers, base_technologies, proxies)
            extracted_request_result = extract_request_response_fields(request_result)
            
            agent_response  = await fingerprint_agent.arun(
                extracted_request_result,
                stream=STREAM_RESPONSES
                )
            if STREAM_RESPONSES:
                async for chunk in agent_response: 
                    pass
                agent_response = fingerprint_agent.run_response
            
            
            formatted_response = await response_formatter_agent.arun(agent_response.content)
            logger.debug(f"formatted_response:\n{formatted_response.content}")
            if isinstance(formatted_response.content, FingerprintOutput):
                updated_tech = formatted_response.content.technologies
                base_technologies = list(set(base_technologies + updated_tech))
            else:
                updated_tech = []

        # Reconstruct the enriched endpoint
        enriched_endpoint = KatanaEndpoint(
            url=katana_endpoint.url,
            technologies=base_technologies,
            methods=katana_endpoint.methods,
            passive_evidence = katana_endpoint.passive_evidence
        )
        fingerprint_result.endpoints.append(enriched_endpoint)
        
    return fingerprint_result
