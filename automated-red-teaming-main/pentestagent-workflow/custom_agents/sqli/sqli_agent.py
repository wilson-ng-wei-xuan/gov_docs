import asyncio
import uuid
import json
from copy import deepcopy
from typing import List, Dict, Optional, Any
from textwrap import dedent
from custom_agents.base import CustomAgent
from custom_agents.response_formatter_agent import ResponseFormatterAgent
from schema.request_response import RequestResponsePair
from agno.utils.log import logger
from custom_agents.sqli.utils import (
    SQLIHandler,
    DIAGNOSTIC_EXAMPLE,
)
from custom_agents.sqli.config import DIAGNOSTIC_PAYLOADS, ACTIVE_ENCODERS
from schema.sqli import DiagnosticSQLiResult, SQLiResult, SQLiType, SQLiResultList
from tools.web_requester.web_requester import WebRequesterGuardedToolkit
from tools.shell_tools.safe_shell_tool import ShellGuardedToolkit
from schema.recon import TagReconInfo
from schema.common import (
    ParamResultList,
    FinalParamResult,
    ResultType,
    FinalTestingResult,
)
from schema.task import VulnType
from config.globals import STREAM_RESPONSES, DEBUG_MODE
from config.context import current_sink
from server.sink.utils import stream_status

SQLi_DIAGNOSTIC_INSTRUCTIONS = dedent(
    """
    You are "SQLi Agent," an AI specialized in detecting and confirming SQL Injection (SQLi) vulnerabilities in web applications.
    
    We are currently in the diagnostic phase. In this phase, your task is to analyze the results from a series of diagnostic payloads and determine if they provide evidence of a SQL Injection vulnerability.
    The each diagnostic payload is run independently. The diagnostic payload is substituted into the target_parameter in default_query, encoded together with the URL as URL parameters and executed as a GET request.
    
    The results of these diagnostic tests will be provided in the following format: 
    
    ```xml
    {example}
    ```
    
    # Task
    1. Compare each `<diagnostic_test>` response to the `<baseline>`.
    2. For each diagnostic_test, determine whether any differences in the responses provide evidence of a SQL Injection vulnerability.
        a. Focus on anomalies such as error messages, broken layouts, or unexpected content that may indicate SQL syntax issues or altered server behavior.
    3. Translate your analysis into the provided response schema. Make sure to include all the diagnostic payloads tested, regardless of whether they yield vulnerabilities.
    
    Provide a clear verdict on whether the results are indicative of a potential SQLi vulnerability, supported by a concise explanation.
    You should make a verdict based entirely on these results - no additional diagnostic tests will be performed and you must not ask the user for input.
    Further testing will be performed in a later stage.
    
    # Output Format: 
    Respond based on the following schema:
    {schema}
    """.format(
        schema=json.dumps(DiagnosticSQLiResult.model_json_schema(), indent=2),
        example=DIAGNOSTIC_EXAMPLE.to_xml(),
    )
)

SQLi_AGENT_INSTRUCTIONS = dedent(
    """
    You are "SQLi Agent," an AI specialized in detecting and confirming SQL Injection (SQLi) vulnerabilities in web applications.
    
    We are currently in the exploitation phase. In this phase, you will be provided results from an initial diagnostic test for SQL Injection vulnerability. 
    Your task is to perform comprehensive testing for SQLi exploits.  
    The diagnostic payloads used were basic and generic, designed to elicit obvious signs of SQL Injection vulnerabilities. 
    However, these tests may not cover all possible SQLi vectors or account for context-specific nuances of the target application.
    You may consider more diagnostic payloads that cover areas the basic diagnostic tests may have missed.
    Following these basic payloads, you should also consider more advanced and context-aware SQLi payloads that are tailored to the specific behaviors and responses of the target application. 
    
    # Task:
    Generate advanced payloads and make use of the WebRequester tool to test those payloads. Clearly document your findings, including any confidential information obtained from successful exploits. 
    Ensure your conclusions are drawn with a high degree of certainty.
    
    # Output Format: 
    Respond based on the following schema:
    {schema}
    """.format(
        schema=json.dumps(SQLiResultList.model_json_schema(), indent=2),
    )
)


class SQLiDiagnosticAgent(CustomAgent):
    """
    Class for Agent specialising in analyzing diagnostic results for SQLi vulnerabilities.
    """

    def __init__(self, session_id: str, *args, **kwargs) -> None:
        """
        Initialise the SQLi agent.
        :param session_id: The session id of the agent.
        :param args: Additional arguments passed to the agent.
        :param kwargs: Additional keyword arguments passed to the agent.
        """
        super().__init__(
            name="SQLi Diagnostic Agent",
            instructions=SQLi_DIAGNOSTIC_INSTRUCTIONS,
            sess_id=session_id,
            goal="Determine if SQLi vulnerabilities exist based on diagnostic tests.",
            success_criteria="Successfully identifying and justifying SQLi vulnerabilities based on the diagnostic results provided.",
            *args,
            **kwargs,
        )


class SQLiAgent(CustomAgent):
    """
    Class for Agent specialising in performing advanced SQLi exploits.
    """

    def __init__(self, session_id: str, *args, **kwargs) -> None:
        """
        Initialise the SQLi agent.
        :param session_id: The session id of the agent.
        :param args: Additional arguments passed to the agent.
        :param kwargs: Additional keyword arguments passed to the agent.
        """
        super().__init__(
            name="SQLi Agent",
            instructions=SQLi_AGENT_INSTRUCTIONS,
            sess_id=session_id,
            goal="Determine if SQLi vulnerabilities exist based on context-aware, advanced SQLi payloads.",
            success_criteria="Successfully identifying and justifying SQLi vulnerabilities based on advanced tests.",
            tools=[
                ShellGuardedToolkit(cache_results=True),
                WebRequesterGuardedToolkit(vuln_type="sqli", cache_results=True, use_vpn=False, session_id=session_id)
            ],
            *args,
            **kwargs,
        )

@stream_status(
    log_output=True
)
async def run_sqli_agent(tag_recon_info: TagReconInfo, session_id: str) -> FinalTestingResult:
    """Executes the SQLi Agent workflow from fixed diagnostic tests to agentic advanced tests."""

    # Retrieve input fields from TagReconInfo
    endpoint = tag_recon_info.url
    parameter_set = tag_recon_info.param_set
    target_parameter = tag_recon_info.vuln_param
    reason = tag_recon_info.reason
    sqli_testing_result = FinalTestingResult(
        endpoint=tag_recon_info.url,
        final_param_result_list={tag_recon_info.vuln_param: []},
    )

    # Instantiate agents and SQLi Handler
    diagnostic_agent = SQLiDiagnosticAgent(session_id=session_id)
    diagnostic_formatter_agent = ResponseFormatterAgent(
        response_model=DiagnosticSQLiResult
    )

    # for parsing the final output, use SQLiResultList instead of ParamResultList
    # using ParamResultList is redundant because it dumps all the schemas of XSSParamResult, XXEResult, SQLiResult, etc into the model context even though the model is only performing SQL exploits
    # SQLiResultList is identical to ParamResultList but only includes the schema for SQLiResult; later on we convert it to ParamResultList to fit the common schema
    SQLi_agent = SQLiAgent(session_id=session_id, debug_mode=DEBUG_MODE)
    SQLi_formatter_agent = ResponseFormatterAgent(response_model=SQLiResultList)

    handler = SQLIHandler(
        endpoint=endpoint,
        base_query_string=parameter_set,
        target_parameter=target_parameter,
        payloads=DIAGNOSTIC_PAYLOADS,
        encoders=ACTIVE_ENCODERS,
    )

    # Run diagnostic tests
    diagnostic_sql_output = await handler.arun(include_baseline=True)
    diagnostic_prompt = dedent(
        """Diagnostic result:
        ```xml
        {result}
        ```
        """.format(result=diagnostic_sql_output.to_xml())
    )  # format diagnostic test results as XML and pass to diagnostic_agent for analysis
    
    diagnostic_agent_response = await diagnostic_agent.arun(
        diagnostic_prompt,
        summarize_on_fail=True,
        stream=STREAM_RESPONSES
        )
    if STREAM_RESPONSES:
        async for chunk in diagnostic_agent_response:
            pass
        
    diagnostic_agent_response = diagnostic_agent.run_response
    _diagnostic_result = await diagnostic_formatter_agent.arun(
        diagnostic_agent_response.content
    )  # format diagnostic_agent results using formatter agent
    diagnostic_result: DiagnosticSQLiResult = _diagnostic_result.content

    # Parse diagnostic tests to common schema if vulnerabilities detected
    basic_param_result = FinalParamResult(
        result_type=ResultType.BASIC,
        param_result_list=ParamResultList(
            param_result_list=[
                SQLiResult(
                    url=endpoint,
                    method="GET",
                    sqli_type=SQLiType.CLASSIC,
                    param=target_parameter,
                    potentially_vulnerable=row.potentially_vulnerable,
                    payload=row.payload,
                    notes=row.explanation,
                )
                for row in diagnostic_result.exploit_payloads
            ]
        ),
    )
    sqli_testing_result.final_param_result_list[tag_recon_info.vuln_param].append(
        basic_param_result
    )

    # Perform advanced tests
    agent_prompt = dedent(
        f"""
        URL: {endpoint}
        Base Query: {parameter_set}
        Diagnostic Result: 
        {diagnostic_result}
        """
    )  # format diagnostic test findings and pass to SQLi agent as context
    sqli_agent_response = await SQLi_agent.arun(
        agent_prompt,
        summarize_on_fail=True,
        stream=STREAM_RESPONSES
        )
    if STREAM_RESPONSES:
        async for chunk in sqli_agent_response: 
            pass
        sqli_agent_response = SQLi_agent.run_response
        
    _final_sqli_result = await SQLi_formatter_agent.arun(sqli_agent_response.content)
    final_sqli_result = FinalParamResult(
        result_type=ResultType.ADVANCED,
        param_result_list=ParamResultList(
            param_result_list=_final_sqli_result.content.param_result_list
        ),
    )  # format diagnostic_agent results using formatter agent and parse to common schema

    sqli_testing_result.final_param_result_list[tag_recon_info.vuln_param].append(
        final_sqli_result
    )

    return sqli_testing_result


if __name__ == "__main__":
    from urllib.parse import parse_qs, urlencode

    # PortSwigger SQLi lab for UNION attack
    demo_endpoint = (
        "https://0a5e000f03d9589c834b335000640021.web-security-academy.net/filter?"
    )
    demo_qs = """category=Clothing%2c+shoes+and+accessories"""
    demo_qs = urlencode(parse_qs(demo_qs), doseq=True)
    target_parameter = "category"

    # Fire Extinguisher SQLi; note that WebRequester does not currently work for this, so it must be removed from SQLiAgent
    # demo_endpoint = "https://app.tuv-sud-psb.sg/FireExtSearch/"
    # demo_qs = """__EVENTTARGET=&__EVENTARGUMENT=&__VIEWSTATE=%2FwEPDwUKMTI2ODU2ODExMA9kFgJmD2QWAgIDD2QWAgIFD2QWAgIBDw9kFgIeDGF1dG9jb21wbGV0ZQUDb2ZmZBgBBRljdGwwMCRNYWluQ29udGVudCRncmREYXRhDzwrAAwBCGZkb91ZqkIn7kLXN%2FDEI799XkHgZE2bWl2Ouapf%2Ff0Vjj8%3D&__VIEWSTATEGENERATOR=9B8E6F44&__EVENTVALIDATION=%2FwEdAANEZDZk90mUdhFMPeum3BZIHxqdRe3Ts9FuiYr%2BeBdnxp%2BI%2FHPZ86NEZcbXwR9jxA7opVEulydnRnlymEvGVJYw%2FHgeLWyLuDisiNlnw%2Bz7ig%3D%3D&ctl00%24MainContent%24txtSearch=123123*&ctl00%24MainContent%24btnSearch=Search"""
    # demo_qs = urlencode(parse_qs(demo_qs), doseq=True)
    # target_parameter = "ctl00$MainContent$txtSearch"

    # Mock session
    init_db()
    session_id = str(uuid.uuid4())
    create_session(session_id)
    current_global_state = GlobalState(
        goal="test",
        target=demo_endpoint,
        session_id=session_id,
        task_list={},
    )
    save_current_global_state(session_id, current_global_state)

    mock_input = TagReconInfo(
        url=demo_endpoint,
        param_set=demo_qs,
        vuln_param=target_parameter,
        tag=VulnType.SQL,
    )

    # Run
    result: FinalTestingResult = asyncio.run(run_sqli_agent(
        session_id=session_id, tag_recon_info=mock_input
    ))
    print(result.model_dump_json(indent=2))
