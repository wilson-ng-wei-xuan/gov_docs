import time
import json
import warnings
import random
from urllib.parse import urlencode, parse_qs, parse_qsl, urlunparse, urlparse
from pydantic import BaseModel, Field
from typing import Literal, Union, List, Callable, Dict, Optional
from tools.web_requester.web_requester import WebRequesterTool
from agno.utils.log import logger
from schema.recon import KatanaEndpoint
from schema.request_response import ResponseDetails
from server.sink import stream_status, StreamType

# Payload Encoders
def random_case(s: str) -> str:
    return "".join(c.upper() if random.choice([True, False]) else c.lower() for c in s)


def inject_inline_comments(payload: str, keywords=("UNION", "SELECT", "OR", "AND")):
    for keyword in keywords:
        pattern = keyword.upper()
        payload = payload.replace(pattern, "/**/".join(list(pattern)))
    return payload


def obfuscate_whitespace(payload: str) -> str:
    whitespace_options = [" ", "  ", "\t", "\n"]
    return "".join(
        random.choice(whitespace_options) if c == " " else c for c in payload
    )


# Helper functions
def safe_format_url(url: str, parameters: Dict[str, Union[str, List]]):
    parsed = urlparse(url)
    existing_params = parse_qs(parsed.query)

    for key, value in parameters.items():
        if isinstance(value, list):
            existing_params[key] = existing_params.get(key, []) + value
        else:
            existing_params[key] = existing_params.get(key, []) + [value]

    query = urlencode(existing_params, doseq=True)

    full_url = urlunparse(
        (
            parsed.scheme,
            parsed.netloc,
            parsed.path,
            parsed.params,
            query,
            parsed.fragment,
        )
    )

    return full_url


# Schemas
class SQLiDiagnosticTest(BaseModel):
    name: str
    method: Literal["GET", "POST"]
    payload: str
    response: Optional[ResponseDetails] = None
    error: Optional[str] = None

    def to_xml(self, indent="    ") -> str:
        lines = [f"{indent}<diagnostic_test>"]
        lines.append(f"{indent * 2}<name>{self.name}</name>")
        lines.append(f"{indent * 2}<method>{self.method}</method>")
        lines.append(f"{indent * 2}<payload>{self.payload}</payload>")
        lines.append(
            f"{indent * 2}<status_code>{self.response.response_status_code if self.response is not None else 'NA'}</status_code>"
        )
        lines.append(
            f"{indent * 2}<response_body>{self.response.response_body if self.response is not None else 'NA'}</response_body>"
        )
        if self.error is not None:
            lines.append(f"{indent * 2}<error>{self.error}</error>")
        lines.append(f"{indent}</diagnostic_test>")
        return "\n".join(lines)


class SQLiDiagnostic(BaseModel):
    url: str
    default_parameters: str
    target_parameter: str
    tests: List[SQLiDiagnosticTest] = Field(default_factory=list)

    def to_xml(self) -> str:
        lines = [f"<sqli_diagnostic>"]
        lines.append(f"    <url>{self.url}</url>")
        lines.append(
            f"    <target_parameter>{self.target_parameter}</target_parameter>"
        )
        lines.append(
            f"    <default_parameters>{self.default_parameters}</default_parameters>"
        )

        for test in self.tests:
            lines.append(test.to_xml(indent="    "))

        lines.append(f"</sqli_diagnostic>")
        return "\n".join(lines)


# Main Classes
class SQLPayloadEncoder(BaseModel):
    """Represents a single callable for encoding a SQL payload."""

    fn: Callable[[str], str]

    def __call__(self, input: str) -> str:
        return self.fn(input)


class SQLPayload(BaseModel):
    """Represents a single SQLi payload as a string, with optional categorization."""

    payload: str
    category: Optional[Literal["diagnostic", "basic", "blind", "custom"]] = None


class SQLIHandler:
    """Handles definition and execution of SQLi injection tests for a given endpoint and parameters.

    SQLi is tested with respect to a specific endpoint using a base_query_string, from which the target_parameter will be modified to each payload (and optionally encoded).
    """

    def __init__(
        self,
        endpoint: str,
        base_query_string: str,
        payloads: Dict[str, SQLPayload],
        target_parameter: str,
        encoders: List[SQLPayloadEncoder],
        session_id: Optional[str] = None
    ):
        self.endpoint = endpoint
        self.default_parameters = parse_qs(base_query_string)
        self.target_parameter = target_parameter
        self.requester = WebRequesterTool(use_vpn=False, cache_results=True, max_redirects=1)
        self.payloads = payloads
        self.encoders = encoders
        self.session_id = session_id

        if self.target_parameter not in self.default_parameters:
            warnings.warn(
                f"Provided target_parameter `{self.target_parameter}` is not in base query string `{self.default_parameters}`, so it will be inserted as a new parameter for SQLi. Make sure this is intended.",
                UserWarning,
            )

    def maybe_mutate_payload(self, payload: SQLPayload):
        """Mutates payload using encoders if provided, else returns original payload"""
        new_payload = payload.payload
        for encoder in self.encoders:
            new_payload = encoder(new_payload)
        return new_payload

    async def arun(self, include_baseline=False):
        def update_parameters(
            default_parameters: dict, target_parameter: str, final_payload: str
        ) -> Dict[str, Dict[str, Union[str, ResponseDetails]]]:
            """Convenience function to update target_parameter with modified payload"""

            # parse_qs returns a dictionary with list values
            # for this to be correctly encoded, the updated parameters must also have list values
            # this is then fed to urlencode(doseq=True)
            # improper handling leads to malformed payloads
            updated_params = default_parameters.copy()

            # update full set of parameters with new payload
            if target_parameter in updated_params:
                # if it exists in the current parameters, override the first value
                updated_params[target_parameter][0] = final_payload
            else:
                # if it does not exist in the current parameters, add it in
                updated_params[target_parameter] = [final_payload]

            return updated_params

        @stream_status(
            module_name='SQLDiagnostic',
            prefix='[DIAGNOSTIC]',
            START_TYPE= StreamType.DIAGNOSTICSTART,
            END_TYPE=StreamType.DIAGNOSTICCOMPLETE,
            input_metadata_fields=['url', 'data', 'method'],
            log_output=True
        )
        async def make_and_parse_request(url: str, data: str = None, method: Literal['GET', 'POST']='GET'):
            """Performs request using WebRequester and parses results.

            If `data` is supplied, POST request is executed.
            If not, GET request is executed.
            GET request assumes that url contains query parameters.
            method is only used for logging purposes.
            """
            
            try:
                if data:
                    logger.debug(f"Running POST request {url} with data {data}")
                    request_response = await self.requester.arun_web_requester(url=url, method="POST", data=data)
                else:
                    logger.debug(f"Running GET request {url}")
                    request_response = await self.requester.arun_web_requester(
                        url=url,
                        method="GET",
                    )
                request_response = json.loads(request_response)

                return {
                    "response_details": ResponseDetails.model_validate(
                        request_response[-1]["response"]
                    ),
                    "error": None,
                }
            except Exception as e:
                logger.error(f"Error making request to {url}; Error: {e}")
                return {"response_details": None, "error": str(e)}

        result = SQLiDiagnostic(
            url=self.endpoint,
            target_parameter=self.target_parameter,
            default_parameters=urlencode(self.default_parameters, doseq=True),
        )
        if include_baseline:
            logger.info(f"Running SQLi diagnostic: Baseline")
            # format query string and make GET request
            query_string_formatted_url = safe_format_url(
                url=self.endpoint, parameters=self.default_parameters
            )
            # Execute GET request
            request_response = await make_and_parse_request(url=query_string_formatted_url, method='GET')
            result.tests.append(
                SQLiDiagnosticTest(
                    name="baseline",
                    payload="",
                    method="GET",
                    response=request_response.get("response_details"),
                    error=request_response.get("error"),
                )
            )

            # Execute POST request
            # POST request data is simply assumed to be url encoded string of parameters
            request_response = await make_and_parse_request(
                url=self.endpoint, data=urlencode(self.default_parameters, doseq=True), method='POST'
            )
            result.tests.append(
                SQLiDiagnosticTest(
                    name="baseline",
                    payload="",
                    method="POST",
                    response=request_response.get("response_details"),
                    error=request_response.get("error"),
                )
            )

        for payload_name, payload in self.payloads.items():
            # apply any encodings specified
            final_payload = self.maybe_mutate_payload(payload)

            # update the default payload with the modified target parameter containing the (encoded) SQLi payload
            request_parameters = update_parameters(
                self.default_parameters, self.target_parameter, final_payload
            )

            # format query string and make GET request
            query_string_formatted_url = safe_format_url(
                url=self.endpoint, parameters=request_parameters
            )

            logger.info(
                f"Running SQLi payload [{payload_name}]: \n - Parameter:{self.target_parameter}\n - Value: {final_payload}"
            )

            # GET request
            request_response = await make_and_parse_request(url=query_string_formatted_url, method='GET')
            result.tests.append(
                SQLiDiagnosticTest(
                    name=payload_name,
                    payload=final_payload,
                    method="GET",
                    response=request_response.get("response_details"),
                    error=request_response.get("error"),
                )
            )

            # POST request
            # POST request data is simply assumed to be url encoded string of parameters
            request_response = await make_and_parse_request(
                url=self.endpoint, data=urlencode(request_parameters, doseq=True), method='POST'
            )
            result.tests.append(
                SQLiDiagnosticTest(
                    name=payload_name,
                    payload=final_payload,
                    method="POST",
                    response=request_response.get("response_details"),
                    error=request_response.get("error"),
                )
            )

            time.sleep(5)

        return result


# Examples for formatting reference
DIAGNOSTIC_EXAMPLE = SQLiDiagnostic(
    url="www.example-shop.com/search",
    default_parameters="product_id=123&category=clothing&gender=male",
    target_parameter="category",
    baseline=SQLiDiagnosticTest(
        name="baseline",
        payload="",
        method="GET",
        response=ResponseDetails(
            response_status_code=200,
            response_body="...",
            response_url="abc",
            response_headers={},
        ),
    ),
    tests=[
        SQLiDiagnosticTest(
            name="single_quote",
            payload="q'",
            method="GET",
            response=ResponseDetails(
                response_status_code=200,
                response_body="...",
                response_url="abc",
                response_headers={},
            ),
        ),
        SQLiDiagnosticTest(
            name="double_quote",
            payload="q''",
            method="GET",
            response=ResponseDetails(
                response_status_code=200,
                response_body="...",
                response_url="abc",
                response_headers={},
            ),
        ),
    ],
)
