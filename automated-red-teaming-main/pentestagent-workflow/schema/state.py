import json
from uuid import uuid4
from pydantic import BaseModel, Field, field_serializer, model_validator
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Set, Union
from schema.task import WorkflowStage
from decimal import Decimal

DISABLED_STAGES: Set[WorkflowStage] = set([
    
])

class NodeStatus(str, Enum):
    INITIALIZED = "initialized"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    RETRYING = "retrying"
    SKIPPED = "skipped"
    CANCELLED = "cancelled"

class TreeStatus(str, Enum):
    INITIALIZED = "initialized"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"
    
class PentestNode(BaseModel):
    '''Represents a specific node/task (e.g. run_katana, run_recon_agent) in the pentest workflow.
    
    Each node has a unique node_id, a label indicating its type, and may have a parent and children to form a tree structure.
    
    
    '''
    label: WorkflowStage
    function: Union[Callable[..., Any], str]   # Store as callable, but serialize as function name

    node_id: str = Field(default_factory=lambda: str(uuid4()))
    parent: Optional["PentestNode"] = None
    children: List["PentestNode"] = Field(default_factory=list)
    
    # Inputs
    inputs: Optional[Dict[str, Any]] = Field(default_factory=dict) # make sure it is JSON-compatible
    
    # Outputs
    result: Optional[Any] = None # make sure it is JSON-compatible
    
    # Metadata 
    status: NodeStatus = NodeStatus.INITIALIZED
    error: List[str] = Field(default_factory=list)
    retry_counter: int = 0

    def model_post_init(self, __context):
        # Ensure that when we load from JSON, we convert function names back to callable
        if isinstance(self.function, str):
            # Use lazy import to avoid circular dependency
            try:
                from schema.task_functions import TASK_FUNCTIONS
                func = TASK_FUNCTIONS.get(self.function)
                if func:
                    self.function = func
                else:
                    raise ValueError(f"Function {self.function} not found in TASK_FUNCTIONS.")
            except ImportError:
                # If we can't import TASK_FUNCTIONS due to circular dependency,
                # keep the function as string - it will be resolved later when needed
                pass
    
    def mark_completed(self, result: Any):
        self.result = result
        self.status = NodeStatus.COMPLETED
        
    def mark_failed(self, error: str):
        self.error.append(error)
        self.status = NodeStatus.FAILED
        
    def mark_retrying(self):
        self.retry_counter += 1
        self.status = NodeStatus.RETRYING
        
    def mark_cancelled(self):
        self.status = NodeStatus.CANCELLED
        
    def mark_skipped(self):
        self.status = NodeStatus.SKIPPED
        
    def mark_resume(self):
        self.status = NodeStatus.IN_PROGRESS

    def mark_in_progress(self):
        self.status = NodeStatus.IN_PROGRESS
        
    @property
    def is_activated(self):
        return self.label not in DISABLED_STAGES 

    @field_serializer('function')
    def serialize_function(self, function):
        if function is not None:
            return getattr(function, "__name__", str(function))
        return None

def _normalize_decimals(obj):
    if isinstance(obj, dict):
        return {k: _normalize_decimals(v) for k, v in obj.items()}
    if isinstance(obj, list):
        return [_normalize_decimals(v) for v in obj]
    if isinstance(obj, Decimal):
        return int(obj) if obj == obj.to_integral_value() else float(obj)
    return obj

class PentestTree(BaseModel):
    goal: str
    target: str 
    session_id: str
    root: Optional[PentestNode] = None
    status: TreeStatus = TreeStatus.INITIALIZED 
    
    nodes: List[PentestNode] = Field(default_factory=list)  
    nodes_index: Dict[str, PentestNode] = Field(default_factory=dict)  # node_id -> PentestNode
    
    input_tokens: int = 0
    output_tokens: int = 0

    # noVNC variables
    verify_url: Optional[str] = None
    verify_str: Optional[str] = None
    username: Optional[str] = None
    password: Optional[str] = None
    
    def add_node(self, node: PentestNode, parent_id: str = None):
        self.nodes.append(node)
        self.nodes_index[node.node_id] = node
        if parent_id:
            parent_node = self.nodes_index.get(parent_id)
            if parent_node:
                parent_node.children.append(node)
            else:
                raise ValueError(f"Parent node with ID {parent_id} not found.")
        else:
            if not self.root:
                self.root = node
            else:
                raise ValueError("Root node already exists. You must specify a parent_id for non-root nodes.")
    
    def get_node(self, node_id: str) -> PentestNode:
        return self.nodes_index.get(node_id)
    
    def get_all_nodes(self) -> List[PentestNode]:
        return self.nodes
    
    def get_running_nodes(self) -> List[PentestNode]:
        return [node for node in self.nodes if node.status == NodeStatus.IN_PROGRESS]
    
    def get_incomplete_nodes(self) -> List[PentestNode]:
        return [node for node in self.nodes if node.status not in (NodeStatus.COMPLETED, NodeStatus.SKIPPED)]
    
    def model_dump(self, **kwargs) -> Dict[str, Any]:
        """Custom serialization that includes tree structure instead of nodes/nodes_index/root"""
        # Get the base serialization
        data = super().model_dump(**kwargs)
        
        # Remove the fields we don't want to serialize
        data.pop('root', None)
        data.pop('nodes', None)
        data.pop('nodes_index', None)
        
        # Add the tree structure
        data['tree'] = self._serialize_tree()
        
        return data
    
    def _serialize_tree(self) -> Optional[Dict[str, Any]]:
        """Convert the tree structure to nested JSON"""
        if not self.root:
            return None
        
        def node_to_dict(node: PentestNode) -> Dict[str, Any]:
            node_data = node.model_dump()
            # Convert children list to nested structure
            if node.children:
                node_data['children'] = [node_to_dict(child) for child in node.children]
            return node_data
        
        return node_to_dict(self.root)
    
    @classmethod
    def from_json_data(cls, data: Dict[str, Any]) -> 'PentestTree':
        """Rebuild PentestTree from JSON data with tree structure"""
        # Extract tree data
        tree_data = data.pop('tree', None)
        
        # Create the PentestTree instance with the remaining data
        pentest_tree = cls(**data)
        
        # Rebuild the tree structure
        if tree_data:
            pentest_tree._rebuild_tree(tree_data)
        
        return pentest_tree
    
    def _rebuild_tree(self, tree_data: Dict[str, Any]):
        """Rebuild nodes, nodes_index, and root from tree structure"""
        def build_node(node_data: Dict[str, Any]) -> PentestNode:
            # Extract children data before creating node
            children_data = node_data.pop('children', [])
            
            # Create the node
            node = PentestNode(**node_data)
            
            # Add to our tracking structures
            self.nodes.append(node)
            self.nodes_index[node.node_id] = node
            
            # Recursively build children
            for child_data in children_data:
                child_node = build_node(child_data)
                node.children.append(child_node)
            
            return node
        
        # Build the entire tree starting from root
        self.root = build_node(tree_data)
    
    def mark_completed(self):
        self.status = TreeStatus.COMPLETED
        
    def mark_failed(self, error: str):
        self.status = TreeStatus.FAILED
        
    def mark_cancelled(self):
        self.status = TreeStatus.CANCELLED
        
    def mark_in_progress(self):
        self.status = TreeStatus.IN_PROGRESS
        
# FOR DEBUGGING
# with open('./server/sample_pentest_tree.json', 'r') as f:
#     sample_data = json.load(f)

# pentest_tree = PentestTree.from_json_data(sample_data)

# print(pentest_tree)