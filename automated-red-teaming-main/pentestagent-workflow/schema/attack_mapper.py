from __future__ import annotations 
from pydantic import BaseModel, Field
from typing import Optional, List

# Attack vector step could be an actual exploit on a param, method, payload or could be simpler like simply rerouting to another page
class AttackVectorStep(BaseModel):
    endpoint: str = Field(..., description="The endpoint being targetted by this step")
    param: Optional[str] = Field(None, description="The parameter involved in the attack vector")
    method: Optional[str] = Field(None, description="The HTTP method used (e.g., GET, POST)")
    payload: Optional[str] = Field(None, description="The payload used for the attack")
    notes: str = Field(..., description="Additional notes or explanation about this step")
    next_step: Optional[AttackVectorStep] = Field(None, description="The next node in the linked list - corresponding to the next step in the attack")

    def next(self) -> AttackVectorStep:
        """
        Returns next node of linked list
        """
        return self.next_step
    
    def display_step(self) -> str:
        """
        Returns display string for linkedlist
        """
        res = f"Endpoint: {self.endpoint}\n"
        res += f"Param: {self.param}, Method: {self.method}\n"
        res += f"Payload: {self.payload}\n"
        res += f"Notes:\n{self.notes}\n"

        return res

class AttackMapperOutput(BaseModel):
    attack_vector_found: bool = Field(..., description="Boolean indicating whether an attack vector was found")
    attack_objective: Optional[str] = Field(None, description="The objective of the attack vector, if one was found")
    attack_vector: Optional[AttackVectorStep] = Field(None, description="A linked list data structure corresponding to the order of steps in the attack")

    def display_attack(self) -> str:
        """
        Returns display string for Output
        """
        if not self.attack_vector_found:
            return "No Attack Vector found"
        
        res = f"Attack Vector found\n"
        res += "=======================\n"
        res += f"Attack Objective: {self.attack_objective}\n"

        curr_step = self.attack_vector
        step_no = 1
        while curr_step:
            res += f"\nStep {step_no}\n"
            res += curr_step.display_step()
            curr_step = curr_step.next()
            step_no += 1
        
        res += "=======================\n"
        return res
    
    def get_attack_chain(self) -> List[AttackVectorStep]:
        """
        Gets attack vector flattened into a list
        """
        chain = []
        curr_step = self.attack_vector

        while curr_step:
            chain.append(curr_step)
            curr_step = curr_step.next()
        
        return chain