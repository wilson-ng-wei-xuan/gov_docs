from __future__ import annotations

import asyncio
import boto3
import aioboto3
from botocore.exceptions import ClientError, NoCredentialsError
from urllib.parse import urlparse
import logging
from typing import Optional, Union
import json

logger = logging.getLogger(__name__)


class S3URIError(Exception):
    """Raised when S3 URI is invalid or malformed."""
    pass


class S3OperationError(Exception):
    """Raised when S3 operation fails."""
    pass


class S3Storage:
    """Utility class for S3 operations with support for both sync and async operations.
    
    Provides methods to read from and write to S3 using S3 URIs (s3://bucket/key format).
    """

    def __init__(self, region: str = "ap-southeast-1"):
        """Initialize S3 utility.
        
        Args:
            region: AWS region for S3 operations
        """
        self.region = region
        self.s3_client = boto3.client("s3", region_name=region)
        
    @staticmethod
    def _parse_s3_uri(s3_uri: str) -> tuple[str, str]:
        """Parse S3 URI into bucket and key components.
        
        Args:
            s3_uri: S3 URI in format s3://bucket/key
            
        Returns:
            Tuple of (bucket, key)
            
        Raises:
            S3URIError: If URI is not valid S3 format
        """
        try:
            parsed = urlparse(s3_uri)
            if parsed.scheme != "s3":
                raise S3URIError(f"Invalid S3 URI scheme. Expected 's3', got '{parsed.scheme}'")
            
            bucket = parsed.netloc
            key = parsed.path.lstrip("/")
            
            if not bucket:
                raise S3URIError("S3 URI must contain a bucket name")
            if not key:
                raise S3URIError("S3 URI must contain a key/path")
                
            return bucket, key
        except Exception as e:
            if isinstance(e, S3URIError):
                raise
            raise S3URIError(f"Failed to parse S3 URI '{s3_uri}': {str(e)}")

    def read(self, s3_uri: str) -> str:
        """Read content from S3 URI synchronously.
        
        Args:
            s3_uri: S3 URI in format s3://bucket/key
            
        Returns:
            Content as string
            
        Raises:
            S3URIError: If URI is invalid
            S3OperationError: If S3 operation fails
        """
        bucket, key = self._parse_s3_uri(s3_uri)
        
        try:
            logger.info(f"Reading from S3: {s3_uri}")
            response = self.s3_client.get_object(Bucket=bucket, Key=key)
            content = response["Body"].read().decode("utf-8")
            logger.info(f"Successfully read {len(content)} characters from {s3_uri}")
            return content
        except ClientError as e:
            error_code = e.response.get("Error", {}).get("Code", "Unknown")
            error_msg = e.response.get("Error", {}).get("Message", str(e))
            logger.error(f"Failed to read from {s3_uri}: {error_code} - {error_msg}")
            raise S3OperationError(f"Failed to read from {s3_uri}: {error_code} - {error_msg}")
        except NoCredentialsError:
            logger.error("AWS credentials not found")
            raise S3OperationError("AWS credentials not found")
        except Exception as e:
            logger.error(f"Unexpected error reading from {s3_uri}: {str(e)}")
            raise S3OperationError(f"Unexpected error reading from {s3_uri}: {str(e)}")

    def write(self, s3_uri: str, content: Union[str, bytes], content_type: Optional[str] = None) -> bool:
        """Write content to S3 URI synchronously.
        
        Args:
            s3_uri: S3 URI in format s3://bucket/key
            content: Content to write (string or bytes)
            content_type: MIME type of content (auto-detected if None)
            
        Returns:
            True if successful
            
        Raises:
            S3URIError: If URI is invalid
            S3OperationError: If S3 operation fails
        """
        bucket, key = self._parse_s3_uri(s3_uri)
        
        # Convert string to bytes if needed
        if isinstance(content, str):
            content_bytes = content.encode("utf-8")
            if content_type is None:
                content_type = "text/plain; charset=utf-8"
        else:
            content_bytes = content
            if content_type is None:
                content_type = "application/octet-stream"
        
        try:
            logger.info(f"Writing {len(content_bytes)} bytes to S3: {s3_uri}")
            
            put_kwargs = {
                "Bucket": bucket,
                "Key": key,
                "Body": content_bytes,
                "ContentType": content_type
            }
            
            self.s3_client.put_object(**put_kwargs)
            logger.info(f"Successfully wrote to {s3_uri}")
            return True
        except ClientError as e:
            error_code = e.response.get("Error", {}).get("Code", "Unknown")
            error_msg = e.response.get("Error", {}).get("Message", str(e))
            logger.error(f"Failed to write to {s3_uri}: {error_code} - {error_msg}")
            raise S3OperationError(f"Failed to write to {s3_uri}: {error_code} - {error_msg}")
        except NoCredentialsError:
            logger.error("AWS credentials not found")
            raise S3OperationError("AWS credentials not found")
        except Exception as e:
            logger.error(f"Unexpected error writing to {s3_uri}: {str(e)}")
            raise S3OperationError(f"Unexpected error writing to {s3_uri}: {str(e)}")

    async def aread(self, s3_uri: str) -> str:
        """Read content from S3 URI asynchronously.
        
        Args:
            s3_uri: S3 URI in format s3://bucket/key
            
        Returns:
            Content as string
            
        Raises:
            S3URIError: If URI is invalid
            S3OperationError: If S3 operation fails
        """
        bucket, key = self._parse_s3_uri(s3_uri)
        
        session = aioboto3.Session()
        try:
            logger.info(f"Async reading from S3: {s3_uri}")
            async with session.client("s3", region_name=self.region) as s3_client:
                response = await s3_client.get_object(Bucket=bucket, Key=key)
                content = await response["Body"].read()
                content_str = content.decode("utf-8")
                logger.info(f"Successfully read {len(content_str)} characters from {s3_uri}")
                return content_str
        except ClientError as e:
            error_code = e.response.get("Error", {}).get("Code", "Unknown")
            error_msg = e.response.get("Error", {}).get("Message", str(e))
            logger.error(f"Failed to async read from {s3_uri}: {error_code} - {error_msg}")
            raise S3OperationError(f"Failed to async read from {s3_uri}: {error_code} - {error_msg}")
        except NoCredentialsError:
            logger.error("AWS credentials not found")
            raise S3OperationError("AWS credentials not found")
        except Exception as e:
            logger.error(f"Unexpected error async reading from {s3_uri}: {str(e)}")
            raise S3OperationError(f"Unexpected error async reading from {s3_uri}: {str(e)}")

    async def awrite(self, s3_uri: str, content: Union[str, bytes], content_type: Optional[str] = None) -> bool:
        """Write content to S3 URI asynchronously.
        
        Args:
            s3_uri: S3 URI in format s3://bucket/key
            content: Content to write (string or bytes)
            content_type: MIME type of content (auto-detected if None)
            
        Returns:
            True if successful
            
        Raises:
            S3URIError: If URI is invalid
            S3OperationError: If S3 operation fails
        """
        bucket, key = self._parse_s3_uri(s3_uri)
        
        # Convert string to bytes if needed
        if isinstance(content, str):
            content_bytes = content.encode("utf-8")
            if content_type is None:
                content_type = "text/plain; charset=utf-8"
        else:
            content_bytes = content
            if content_type is None:
                content_type = "application/octet-stream"
        
        session = aioboto3.Session()
        try:
            logger.info(f"Async writing {len(content_bytes)} bytes to S3: {s3_uri}")
            
            async with session.client("s3", region_name=self.region) as s3_client:
                put_kwargs = {
                    "Bucket": bucket,
                    "Key": key,
                    "Body": content_bytes,
                    "ContentType": content_type
                }
                
                await s3_client.put_object(**put_kwargs)
                logger.info(f"Successfully wrote to {s3_uri}")
                return True
        except ClientError as e:
            error_code = e.response.get("Error", {}).get("Code", "Unknown")
            error_msg = e.response.get("Error", {}).get("Message", str(e))
            logger.error(f"Failed to async write to {s3_uri}: {error_code} - {error_msg}")
            raise S3OperationError(f"Failed to async write to {s3_uri}: {error_code} - {error_msg}")
        except NoCredentialsError:
            logger.error("AWS credentials not found")
            raise S3OperationError("AWS credentials not found")
        except Exception as e:
            logger.error(f"Unexpected error async writing to {s3_uri}: {str(e)}")
            raise S3OperationError(f"Unexpected error async writing to {s3_uri}: {str(e)}")

    def exists(self, s3_uri: str) -> bool:
        """Check if object exists at S3 URI.
        
        Args:
            s3_uri: S3 URI in format s3://bucket/key
            
        Returns:
            True if object exists, False otherwise
        """
        bucket, key = self._parse_s3_uri(s3_uri)
        
        try:
            self.s3_client.head_object(Bucket=bucket, Key=key)
            return True
        except ClientError as e:
            error_code = e.response.get("Error", {}).get("Code", "Unknown")
            if error_code == "404":
                return False
            logger.warning(f"Error checking existence of {s3_uri}: {error_code}")
            return False
        except Exception as e:
            logger.warning(f"Unexpected error checking existence of {s3_uri}: {str(e)}")
            return False

    async def aexists(self, s3_uri: str) -> bool:
        """Check if object exists at S3 URI asynchronously.
        
        Args:
            s3_uri: S3 URI in format s3://bucket/key
            
        Returns:
            True if object exists, False otherwise
        """
        bucket, key = self._parse_s3_uri(s3_uri)
        
        session = aioboto3.Session()
        try:
            async with session.client("s3", region_name=self.region) as s3_client:
                await s3_client.head_object(Bucket=bucket, Key=key)
                return True
        except ClientError as e:
            error_code = e.response.get("Error", {}).get("Code", "Unknown")
            if error_code == "404":
                return False
            logger.warning(f"Error checking existence of {s3_uri}: {error_code}")
            return False
        except Exception as e:
            logger.warning(f"Unexpected error checking existence of {s3_uri}: {str(e)}")
            return False