from __future__ import annotations

import asyncio
import boto3
import aioboto3
from boto3.dynamodb.conditions import Key
from botocore.exceptions import ClientError
from db.database import Database

from decimal import Decimal
from dataclasses import is_dataclass, asdict
from enum import Enum
from uuid import UUID
from datetime import datetime, date
from pathlib import Path
import base64
import math
import sys
import logging

logger = logging.getLogger(__name__)


class ExceedDynamoSizeLimit(Exception):
    """Raised when data exceeds DynamoDB's item size limit (400KB)."""

    pass


def _pydantic_dump(obj):
    if hasattr(obj, "model_dump") and callable(obj.model_dump):
        try:
            return obj.model_dump()
        except Exception:
            pass

    return None


def _to_decimal(n: float | int | Decimal | str):
    if isinstance(n, Decimal):
        return n
    if isinstance(n, (int,)):
        return Decimal(n)
    if isinstance(n, float):
        if math.isfinite(n):
            return Decimal(str(n))
        # NaN/Inf are not representable; convert to string or None
        return str(n)
    if isinstance(n, str):
        # best effort: try to make Decimal, else keep string
        try:
            return Decimal(n)
        except Exception:
            return n
    return n


def to_dynamodb_value(obj):
    """
    Recursively convert Python objects into DynamoDB-serializable values.
    Target types:
      - str, bool, None
      - Decimal (for numbers)
      - list / dict (containing the same)
      - (optional) set of homogeneous str/Decimal/bytes (converted to list here for safety)
    """
    # Short-circuit for common primitives
    if obj is None or isinstance(obj, (str, bool)):
        return obj

    # Numbers → Decimal
    if isinstance(obj, (int, float, Decimal)):
        return _to_decimal(obj)

    # Dates/times → ISO strings
    if isinstance(obj, (datetime, date)):
        # Always store as UTC ISO strings or just ISO; adjust if you prefer
        return obj.isoformat()

    # UUID → string
    if isinstance(obj, UUID):
        return str(obj)

    # Enum → its value (prefer value, else name)
    if isinstance(obj, Enum):
        return to_dynamodb_value(obj.value if hasattr(obj, "value") else obj.name)

    # Paths → string
    if isinstance(obj, Path):
        return str(obj)

    # Bytes/bytearray → base64-encoded bytes
    if isinstance(obj, (bytes, bytearray)):
        # You can return raw bytes (B type) to DynamoDB as well; here we base64 to be explicit
        return base64.b64encode(bytes(obj)).decode("ascii")

    # Sets → list (to avoid DynamoDB set constraints)
    if isinstance(obj, set):
        return [to_dynamodb_value(x) for x in obj]

    # Tuples/lists → list
    if isinstance(obj, (list, tuple)):
        return [to_dynamodb_value(x) for x in obj]

    # Dicts → dict
    if isinstance(obj, dict):
        return {k: to_dynamodb_value(v) for k, v in obj.items()}

    # Dataclasses → asdict then recurse
    if is_dataclass(obj):
        return {k: to_dynamodb_value(v) for k, v in asdict(obj).items()}

    # Pydantic / attrs-like → dict then recurse
    dumped = _pydantic_dump(obj)
    if dumped is not None:
        return {k: to_dynamodb_value(v) for k, v in dumped.items()}

    # Objects with __dict__ → dict then recurse
    if hasattr(obj, "__dict__"):
        try:
            return {
                k: to_dynamodb_value(v)
                for k, v in vars(obj).items()
                if not k.startswith("_")
            }
        except Exception:
            pass

    # Fallback: stringify
    logger.warning(
        f"Warning: converting unsupported type {type(obj)} to string for DynamoDB storage"
    )
    return str(obj)


def to_dynamodb_item(item: dict) -> dict:
    """
    High-level wrapper for full items: ensures all floats → Decimal and
    all nested custom objects → DynamoDB-safe primitives.
    """

    if isinstance(item, list):
        return [to_dynamodb_value(v) for v in item]
    elif isinstance(item, dict):
        return {k: to_dynamodb_value(v) for k, v in item.items()}
    else:
        raise TypeError(
            f"Item must be a dict or list at the top level. Got {type(item)}"
        )


class DynamoDB(Database):
    """Class for DynamoDB operations.

    DynamoDB does not allow storage of certain datatypes, so all data must be converted to allowable formats (e.g float->decimal) before storage.
    """

    def __init__(self, table_name, region="ap-southeast-1", pk="pk", sk="sk"):
        self.dynamodb = boto3.resource("dynamodb", region_name=region)
        self.table = self.dynamodb.Table(table_name)
        self.region = region
        self.table_name = table_name
        self.pk = pk
        self.sk = sk

        self.healthcheck()
        logger.info("DynamoDB initialized for table {self.table} in {self.region}")

    def create_item(self, item: dict):
        if self.pk not in item or self.sk not in item:
            raise ValueError(
                f"Item must contain both '{self.pk}' and '{self.sk}' keys."
            )
        try:
            self.table.put_item(Item=to_dynamodb_item(item))
            return True
        except ClientError as e:
            error_type = e.response["Error"]["Code"]
            error_msg = e.response["Error"]["Message"]
            logger.error(
                f"Create failed for PK: {item.get(self.pk, 'unknown')}; SK: {item.get(self.sk, 'unknown')}: {error_msg}"
            )
            if (
                error_type == "ValidationException"
                and "Item size has exceeded the maximum allowed size" in error_msg
            ):
                pk_val = item.get(self.pk, "unknown")
                sk_val = item.get(self.sk, "unknown")
                logger.info(
                    f"Raising ExceedDynamoSizeLimit for PK: {pk_val}; SK: {sk_val}"
                )
                raise ExceedDynamoSizeLimit(
                    f"Item size exceeds DynamoDB's 400KB limit: {error_msg}"
                )
            return False
        except Exception as e:
            pk_val = item.get(self.pk, "unknown")
            sk_val = item.get(self.sk, "unknown")
            logger.error(
                f"Create encountered an unexpected error {type(e)}: {str(e)}; PK: {pk_val}; SK: {sk_val}"
            )
            raise

    def delete_item(self, pk: str, sk):
        try:
            self.table.delete_item(Key={self.pk: pk, self.sk: sk})
            return True
        except ClientError as e:
            logger.error("Delete failed:", e.response["Error"]["Message"])
            return False

    def update_item(self, pk: str, sk, updates: dict):
        try:
            # Convert values to Decimal-safe versions
            updates = to_dynamodb_item(updates)
            update_expr = "SET " + ", ".join(f"#{k} = :{k}" for k in updates)
            expr_attr_names = {f"#{k}": k for k in updates}
            expr_attr_vals = {f":{k}": v for k, v in updates.items()}

            resp = self.table.update_item(
                Key={self.pk: pk, self.sk: sk},
                UpdateExpression=update_expr,
                ExpressionAttributeNames=expr_attr_names,
                ExpressionAttributeValues=expr_attr_vals,
                ReturnValues="ALL_NEW",
            )
            return resp.get("Attributes")
        except ClientError as e:
            error_type = e.response["Error"]["Code"]
            error_msg = e.response["Error"]["Message"]
            logger.error(f"Update failed for PK: {pk}; SK: {sk}: {error_msg}")
            if (
                error_type == "ValidationException"
                and "Item size has exceeded the maximum allowed size" in error_msg
            ):
                logger.info(f"Raising ExceedDynamoSizeLimit for PK: {pk}; SK: {sk}")
                raise ExceedDynamoSizeLimit(
                    f"Item size exceeds DynamoDB's 400KB limit: {error_msg}"
                )
            raise
        except Exception as e:
            logger.error(
                f"Update encountered an unexpected error {type(e)}: {str(e)}; PK: {pk}; SK: {sk}"
            )
            raise

    def get_item(self, pk: str, sk):
        try:
            resp = self.table.get_item(Key={self.pk: pk, self.sk: sk})
            return resp.get("Item")
        except ClientError as e:
            logger.error("Get failed:", e.response["Error"]["Message"])
            return None

    def get_by_pk(self, pk: str):
        try:
            resp = self.table.query(KeyConditionExpression=Key(self.pk).eq(pk))
            return resp.get("Items", [])
        except ClientError as e:
            logger.error("Query failed:", e.response["Error"]["Message"])
            return []

    async def acreate_item(self, item: dict):
        if self.pk not in item or self.sk not in item:
            raise ValueError(
                f"Item must contain both '{self.pk}' and '{self.sk}' keys."
            )
        session = aioboto3.Session()
        try:
            async with session.resource(
                "dynamodb", region_name=self.region
            ) as dynamo_resource:
                table = await dynamo_resource.Table(self.table_name)
                await table.put_item(Item=to_dynamodb_item(item))
            return True
        except ClientError as e:
            error_type = e.response["Error"]["Code"]
            error_msg = e.response["Error"]["Message"]
            if (
                error_type == "ValidationException"
                and "Item size has exceeded the maximum allowed size" in error_msg
            ):
                pk_val = item.get(self.pk, "unknown")
                sk_val = item.get(self.sk, "unknown")
                logger.info(
                    f"Raising ExceedDynamoSizeLimit for PK: {pk_val}; SK: {sk_val}"
                )
                raise ExceedDynamoSizeLimit(
                    f"Item size exceeds DynamoDB's 400KB limit: {error_msg}"
                )
            pk_val = item.get(self.pk, "unknown")
            sk_val = item.get(self.sk, "unknown")
            logger.error(
                f"Async Create failed for PK: {pk_val}; SK: {sk_val}: {error_msg}"
            )
            return False
        except Exception as e:
            pk_val = item.get(self.pk, "unknown")
            sk_val = item.get(self.sk, "unknown")
            logger.error(
                f"Async Create encountered an unexpected error {type(e)}: {str(e)}; PK: {pk_val}; SK: {sk_val}"
            )
            raise

    async def adelete_item(self, pk: str, sk):
        session = aioboto3.Session()
        try:
            async with session.resource(
                "dynamodb", region_name=self.region
            ) as dynamo_resource:
                table = await dynamo_resource.Table(self.table_name)
                await table.delete_item(Key={self.pk: pk, self.sk: sk})
            return True
        except ClientError as e:
            logger.error(
                "Async Delete failed:",
                e.response.get("Error", {}).get("Message", str(e)),
            )
            return False

    async def aupdate_item(self, pk: str, sk, updates: dict):
        session = aioboto3.Session()
        try:
            updates = to_dynamodb_item(updates)
            update_expr = "SET " + ", ".join(f"#{k} = :{k}" for k in updates)
            expr_attr_names = {f"#{k}": k for k in updates}
            expr_attr_vals = {f":{k}": v for k, v in updates.items()}

            async with session.resource(
                "dynamodb", region_name=self.region
            ) as dynamo_resource:
                table = await dynamo_resource.Table(self.table_name)
                resp = await table.update_item(
                    Key={self.pk: pk, self.sk: sk},
                    UpdateExpression=update_expr,
                    ExpressionAttributeNames=expr_attr_names,
                    ExpressionAttributeValues=expr_attr_vals,
                    ReturnValues="ALL_NEW",
                )
                return resp.get("Attributes")
        except ClientError as e:
            error_type = e.response["Error"]["Code"]
            error_msg = e.response["Error"]["Message"]
            if (
                error_type == "ValidationException"
                and "Item size has exceeded the maximum allowed size" in error_msg
            ):
                logger.info(f"Raising ExceedDynamoSizeLimit for PK: {pk}; SK: {sk}")
                raise ExceedDynamoSizeLimit(
                    f"Item size exceeds DynamoDB's 400KB limit: {error_msg}"
                )
            logger.error(f"Async Update failed for PK: {pk}; SK: {sk}: {error_msg}")
            return None
        except Exception as e:
            logger.error(
                f"Async Update encountered an unexpected error {type(e)}: {str(e)}; PK: {pk}; SK: {sk}"
            )
            raise

    def append_to_list(self, pk: str, sk: str, attr: str, values):
        """Safely append one or more values to a list attribute using list_append."""
        try:
            if not isinstance(values, list):
                values = [values]
            resp = self.table.update_item(
                Key={self.pk: pk, self.sk: sk},
                UpdateExpression=f"SET #{attr} = list_append(if_not_exists(#{attr}, :empty), :vals)",
                ExpressionAttributeNames={f"#{attr}": attr},
                ExpressionAttributeValues={
                    ":vals": to_dynamodb_value(values),
                    ":empty": [],
                },
                ReturnValues="ALL_NEW",
            )
            return resp.get("Attributes")
        except ClientError as e:
            error_type = e.response["Error"]["Code"]
            error_msg = e.response["Error"]["Message"]
            if (
                error_type == "ValidationException"
                and "Item size has exceeded the maximum allowed size" in error_msg
            ):
                logger.info(f"Raising ExceedDynamoSizeLimit for PK: {pk}; SK: {sk}")
                raise ExceedDynamoSizeLimit(
                    f"Item size exceeds DynamoDB's 400KB limit: {error_msg}"
                )
            logger.error(f"Append failed for PK: {pk}; SK: {sk}: {error_msg}")
            return None
        except Exception as e:
            logger.error(
                f"Append encountered an unexpected error {type(e)}: {str(e)}; PK: {pk}; SK: {sk}"
            )
            raise

    async def aappend_to_list(self, pk: str, sk, attr: str, values):
        """Async version of append_to_list."""

        if not isinstance(values, list):
            values = [values]
        session = aioboto3.Session()
        try:
            async with session.resource(
                "dynamodb", region_name=self.region
            ) as dynamo_resource:
                table = await dynamo_resource.Table(self.table_name)
                resp = await table.update_item(
                    Key={self.pk: pk, self.sk: sk},
                    UpdateExpression=f"SET #{attr} = list_append(if_not_exists(#{attr}, :empty), :vals)",
                    ExpressionAttributeNames={f"#{attr}": attr},
                    ExpressionAttributeValues={
                        ":vals": to_dynamodb_value(values),
                        ":empty": [],
                    },
                    ReturnValues="ALL_NEW",
                )
                return resp.get("Attributes")
        except ClientError as e:
            error_type = e.response["Error"]["Code"]
            error_msg = e.response["Error"]["Message"]
            if (
                error_type == "ValidationException"
                and "Item size has exceeded the maximum allowed size" in error_msg
            ):
                logger.info(f"Raising ExceedDynamoSizeLimit for PK: {pk}; SK: {sk}")
                raise ExceedDynamoSizeLimit(
                    f"Item size exceeds DynamoDB's 400KB limit: {error_msg}"
                )
            raise
        except Exception as e:
            logger.error(
                f"Async Append encountered an unexpected error {type(e)}: {str(e)}; PK: {pk}; SK: {sk}"
            )
            raise

    async def aget_item(self, pk: str, sk):
        session = aioboto3.Session()
        try:
            async with session.resource(
                "dynamodb", region_name=self.region
            ) as dynamo_resource:
                table = await dynamo_resource.Table(self.table_name)
                resp = await table.get_item(Key={self.pk: pk, self.sk: sk})
                return resp.get("Item")
        except ClientError as e:
            logger.error(
                "Async Get failed:", e.response.get("Error", {}).get("Message", str(e))
            )
            return None

    async def aget_by_pk(self, pk: str):
        session = aioboto3.Session()
        try:
            async with session.resource(
                "dynamodb", region_name=self.region
            ) as dynamo_resource:
                table = await dynamo_resource.Table(self.table_name)
                resp = await table.query(KeyConditionExpression=Key(self.pk).eq(pk))
                return resp.get("Items", [])
        except ClientError as e:
            logger.error(
                "Async Query failed:",
                e.response.get("Error", {}).get("Message", str(e)),
            )
            return []

    def healthcheck(self) -> bool:
        try:
            self.table.load()
        except ClientError as e:
            logger.error("Healthcheck failed: %s", e.response["Error"]["Message"])
            raise
