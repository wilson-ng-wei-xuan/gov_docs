import logging
from typing import List, Union, Dict, Callable
from schema.task import VulnType, WorkflowStage
from schema.state import PentestNode, NodeStatus
from schema.recon import ReconOutput, KatanaAnalysisOutput
from schema.common import FinalTestingResult
from tools.state_management import GLOBAL_STATE_HANDLER
from schema.task_functions import TASK_FUNCTIONS

logger = logging.getLogger(__name__)


def route_to_dorking_agent(node: PentestNode, session_id: str) -> List[PentestNode]:
    if not isinstance(node.result, KatanaAnalysisOutput):
        msg = (
            f"Expected KatanaAnalysisOutput from {node.label}, got {type(node.result)}"
        )
        logger.error(msg)
        raise ValueError(msg)

    return [
        PentestNode(
            label=WorkflowStage.run_dorking_agent,
            function=TASK_FUNCTIONS[WorkflowStage.run_dorking_agent],
            inputs={"katana_output": node.result, "session_id": session_id},
        )
    ]


def route_to_fingerprint_agent(node: PentestNode, session_id: str) -> List[PentestNode]:
    if not isinstance(node.result, KatanaAnalysisOutput):
        msg = (
            f"Expected KatanaAnalysisOutput from {node.label}, got {type(node.result)}"
        )
        logger.error(msg)
        raise ValueError(msg)

    return [
        PentestNode(
            label=WorkflowStage.run_fingerprint_agent,
            function=TASK_FUNCTIONS[WorkflowStage.run_fingerprint_agent],
            inputs={"katana_analysis_output": node.result, "session_id": session_id},
        )
    ]


def route_to_recon_agent(node: PentestNode, session_id: str) -> List[PentestNode]:
    print("routing to recon")
    if not isinstance(node.result, KatanaAnalysisOutput):
        msg = (
            f"Expected KatanaAnalysisOutput from {node.label}, got {type(node.result)}"
        )
        logger.error(msg)
        raise ValueError(msg)

    return [
        PentestNode(
            label=WorkflowStage.run_recon_agent,
            function=TASK_FUNCTIONS[WorkflowStage.run_recon_agent],
            inputs={"katana_analysis_output": node.result, "session_id": session_id},
        )
    ]


def route_individual_exploit_tasks(
    node: PentestNode, session_id: str
) -> List[PentestNode]:
    if not isinstance(node.result, ReconOutput):
        msg = f"Expected ReconOutput from {node.label}, got {type(node.result)}"
        logger.error(msg)
        raise ValueError(msg)

    next_tasks: List[PentestNode] = []
    for recon_output in node.result.assessments:
        for tag_recon_info in recon_output.get_tag_recon_outputs():
            vuln_type = tag_recon_info.tag
            if vuln_type == VulnType.SQL:
                next_tasks.append(
                    PentestNode(
                        label=WorkflowStage.run_sqli_agent,
                        function=TASK_FUNCTIONS[WorkflowStage.run_sqli_agent],
                        inputs={
                            "tag_recon_info": tag_recon_info,
                            "session_id": session_id,
                        },
                    )
                )
            elif vuln_type == VulnType.XSS:
                next_tasks.append(
                    PentestNode(
                        label=WorkflowStage.run_xss_agent,
                        function=TASK_FUNCTIONS[WorkflowStage.run_xss_agent],
                        inputs={
                            "tag_recon_info": tag_recon_info,
                            "session_id": session_id,
                        },
                    )
                )
            elif vuln_type == VulnType.XXE:
                next_tasks.append(
                    PentestNode(
                        label=WorkflowStage.run_xxe_agent,
                        function=TASK_FUNCTIONS[WorkflowStage.run_xxe_agent],
                        inputs={
                            "tag_recon_info": tag_recon_info,
                            "session_id": session_id,
                        },
                    )
                )
            elif vuln_type == VulnType.OPEN_REDIRECT:
                next_tasks.append(
                    PentestNode(
                        label=WorkflowStage.run_open_redirect_agent,
                        function=TASK_FUNCTIONS[WorkflowStage.run_open_redirect_agent],
                        inputs={
                            "tag_recon_info": tag_recon_info,
                            "session_id": session_id,
                        },
                    )
                )
            else:
                logger.error(f"Unknown vulnerability type: {vuln_type}")

    logger.info(
        f"route_individual_exploit_tasks: Created {len(next_tasks)} exploit tasks: {[task.label for task in next_tasks]}"
    )
    return next_tasks


def route_to_attack_mapper(
    node: PentestNode, session_id: str, final_ind_exploit: bool
) -> List[PentestNode]:
    if node.is_activated and not isinstance(node.result, FinalTestingResult):
        msg = f"Expected FinalTestingResult from {node.label}, got {type(node.result)}"
        logger.error(msg)
        raise ValueError(msg)

    next_tasks: List[PentestNode] = []
    if final_ind_exploit:
        exploit_results = []
        global_state = GLOBAL_STATE_HANDLER.get_session(session_id)
        goal = global_state.goal

        # # TODO: what is this??
        # if "test" in goal:
        #     goal = None

        for exploit_task_name in [
            "run_xss_agent",
            "run_open_redirect_agent",
            "run_xxe_agent",
            "run_sqli_agent",
        ]:
            task_results = [
                n.result for n in global_state.nodes if n.label == exploit_task_name
            ]
            exploit_results.extend(task_results)

        if len(exploit_results) > 0:
            next_tasks.append(
                PentestNode(
                    label=WorkflowStage.run_attack_mapper_agent,
                    function=TASK_FUNCTIONS[WorkflowStage.run_attack_mapper_agent],
                    inputs={
                        "exploits": exploit_results,
                        "session_id": session_id,
                        "goal": goal,
                    },
                )
            )
    return next_tasks


def exploit_task_router(node, session_id, tasks_queue):
    # Check if this is the final exploit task by examining remaining tasks in queue
    # and completed exploit tasks in global state
    global_state = GLOBAL_STATE_HANDLER.get_session(session_id)

    # Define all possible exploit task types
    exploit_task_types = {
        "run_xss_agent",
        "run_sqli_agent",
        "run_xxe_agent",
        "run_open_redirect_agent",
    }

    # Count remaining exploit tasks in queue (not yet started)
    remaining_exploit_tasks = sum(
        1 for task in tasks_queue if task.label in exploit_task_types
    )

    # Count completed exploit tasks in global state
    completed_exploit_tasks = sum(
        1
        for n in global_state.nodes
        if n.label in exploit_task_types
        and n.status in [NodeStatus.COMPLETED, NodeStatus.FAILED, NodeStatus.SKIPPED]
    )

    # This is the final exploit task if no more exploit tasks remain in queue
    is_final_exploit = remaining_exploit_tasks == 0

    logger.info(
        f"Exploit task router: {node.label} completed. "
        f"Remaining exploit tasks in queue: {remaining_exploit_tasks}, "
        f"Completed exploit tasks: {completed_exploit_tasks}, "
        f"Is final exploit: {is_final_exploit}"
    )

    return route_to_attack_mapper(node, session_id, is_final_exploit)


TASK_ROUTER = {
    "run_katana": lambda node, session_id, **kwargs: route_to_recon_agent(
        node, session_id
    ),
    # "run_katana": lambda node, session_id, **kwargs: route_to_dorking_agent(node, session_id),
    # "run_dorking_agent": lambda node, session_id, **kwargs: route_to_fingerprint_agent(node, session_id),
    "run_fingerprint_agent": lambda node, session_id, **kwargs: route_to_recon_agent(
        node, session_id
    ),
    "run_dorking_agent": lambda node, session_id, **kwargs: route_to_fingerprint_agent(
        node, session_id
    ),
    "run_recon_agent": lambda node,
    session_id,
    **kwargs: route_individual_exploit_tasks(node, session_id),
    "run_xss_agent": lambda node,
    session_id,
    tasks_queue,
    **kwargs: exploit_task_router(node, session_id, tasks_queue),
    "run_open_redirect_agent": lambda node,
    session_id,
    tasks_queue,
    **kwargs: exploit_task_router(node, session_id, tasks_queue),
    "run_xxe_agent": lambda node,
    session_id,
    tasks_queue,
    **kwargs: exploit_task_router(node, session_id, tasks_queue),
    "run_sqli_agent": lambda node,
    session_id,
    tasks_queue,
    **kwargs: exploit_task_router(node, session_id, tasks_queue),
    # "run_attack_mapper_agent": lambda node, session_id, **kwargs: [
    #     Task(
    #         name="run_reporter_agent",
    #         result=None,
    #         additional_instructions="SAMPLE REPORTER ADDITIONAL INSTRUCTIONS",
    #         status=TaskStatus.PENDING,
    #         stage=WorkflowStage.RECON,
    #         retry_counter=0,
    #     )
    # ],
}
