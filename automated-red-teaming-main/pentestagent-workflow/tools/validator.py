import json
import re
from agno.utils.log import logger
from agno.tools import Toolkit
from typing import Dict, Any, List, Callable
from schema.request_response import *
from schema.task import VulnType
from schema.xss import XSSType
from schema.open_redirect import RedirectType
from schema.xxe import XXEType
from tools.web_requester.web_requester import WebRequesterTool
import subprocess, os, socket, time, signal, uuid
from pydantic import parse_obj_as
from flask import Flask
from urllib.parse import unquote, unquote_plus
from datetime import datetime, timedelta
from urllib.parse import urlparse, urlunparse
import requests
from requests.exceptions import ProxyError, ConnectionError, Timeout, RequestException
import asyncio
from playwright.async_api import async_playwright
import aiohttp
import ssl
from tools.shell_tools.safe_shell_tool import SafeShellTool
from tools.comparison import findDynamicContent, removeDynamicContent, removeReflectiveValues, comparison
from schema.validator import ValidatorResult, ValidatorResultList

PORT = 5000
HOST = "localhost"
APPNAME = "./tools/validator"
app = Flask(APPNAME)
WEBHOOK = os.getenv("WEBHOOK") or "ctni6t3d2d.execute-api.ap-southeast-1.amazonaws.com"
WEBHOOK_RESULT = os.getenv("WEBHOOK_RESULT") or "01339jdko3.execute-api.ap-southeast-1.amazonaws.com/status"
WEBHOOK_API_KEY = os.getenv("WEBHOOK_API_KEY") or "Nephila_Maya!!"
debug_dynamic = True
#PROXIES = "172.31.112.1:8080"
PROXIES = None

##### Custom Subclasses for tools
class ValidatorTool(Toolkit):
    """
    Version of ShellTools where you can explicitly forbid specific commands
    """

    def __init__(self, forbidden: List[str] = [], *args, **kwargs):
        # TODO: Include other default forbidden commands if necessary
        pass
    
    async def validate(self, request_response_list: RequestResponseList = None, vuln_type: str = None, vuln_param_payload: dict = None, mal_payload: str = None) -> str:
        """
        Validate a potential vulnerability by delegating to the appropriate validator
        based on the given vulnerability type.

        Args:
            request_response_list (RequestResponseList): 
                A list of request/response objects to analyze for evidence.
            vuln_type (str): 
                The type of vulnerability to validate (e.g., SQL, XSS, XXE, SSRF, OPEN_REDIRECT).
            vuln_param_payload (dict, optional): 
                The parameter-to-payload mapping used in the test (if applicable).
            mal_payload (str, optional): 
                The malicious payload string used in the request (mainly for SQLi).

        Returns:
            str: The validation result, usually a structured string or object
                from the respective validator function. Returns None if 
                arguments are missing or vuln_type is invalid.
        """
        if request_response_list == None or vuln_type == None:
            logger.error(f"One of the argument is None. request_response_list is: {request_response_list} and vuln_type is {vuln_type}.")
            return
        if vuln_type.lower() == VulnType.SQL.lower():
            return await validate_sqli(request_response_list, vuln_param_payload, mal_payload)
        elif vuln_type.lower() == VulnType.XSS.lower():
            return await validate_xss(request_response_list, vuln_param_payload)
        elif vuln_type.lower() == VulnType.XXE.lower():
            return await validate_xxe(request_response_list, vuln_param_payload)
        elif vuln_type.lower() == VulnType.SSRF.lower():
            return await validate_ssrf(request_response_list, vuln_param_payload)
        elif vuln_type.lower() == VulnType.OPEN_REDIRECT.lower():
            return await validate_or(request_response_list, vuln_param_payload)
        else:
            logger.error("vuln_type is not a valid value.")
            return

async def validate_sqli_request(request, payload, param_name, mal_payload):
    results = []

    def clean_payload_from_string(s):
        if mal_payload:
            return s.replace(mal_payload, "") if isinstance(s, str) else s
        else:
            return s.replace(payload, "") if isinstance(s, str) else s

    def clean_headers(headers):
        return {
            clean_payload_from_string(k): clean_payload_from_string(v)
            for k, v in headers.items()
        }

    def filter_valid_responses(responses):
        return [
            rr for rr in responses
            if rr.response and rr.response.response_status_code != 0
        ]

    async def send_request(webrequester, url, method, headers, body):
        raw_response = await webrequester.arun_web_requester(url, method, headers, body)
        return parse_obj_as(List[RequestResponsePair], json.loads(raw_response))

    cleaned_url = clean_payload_from_string(request.request_url)
    cleaned_headers = clean_headers(request.request_headers)
    cleaned_body = clean_payload_from_string(request.request_body)

    webrequester = WebRequesterTool(use_vpn=False, proxies=PROXIES)

    # Send two requests to check for dynamic behavior
    responses_1 = await send_request(webrequester, cleaned_url, request.request_method, cleaned_headers, cleaned_body)
    responses_2 = await send_request(webrequester, cleaned_url, request.request_method, cleaned_headers, cleaned_body)

    responses_1 = filter_valid_responses(responses_1)
    responses_2 = filter_valid_responses(responses_2)

    # TODO: this is still not detecting the right number of responses
    if len(responses_1) != len(responses_2):
        logger.error("Sending 2 same requests gives different number of responses")
        return False

    for i, (pair1, pair2) in enumerate(zip(responses_1, responses_2)):
        resp1_body = pair1.response.response_body if pair1.response else None
        resp2_body = pair2.response.response_body if pair2.response else None

        # Artificially simulate dynamic behavior (debugging)
        if debug_dynamic and resp2_body:
            resp2_body = resp2_body.replace("iTdcQLdhilorfQsoxwYdUx39Ev8f-pgcBu51zsXdT2o1", uuid.uuid4().hex)
            resp2_body = resp2_body.replace("/wEdAANEZDZk90mUdhFMPeum3BZIHxqdRe3Ts9FuiYr+eBdnxp+I/HPZ86NEZcbXwR9jxA7opVEulydnRnlymEvGVJYw/HgeLWyLuDisiNlnw+z7ig==", uuid.uuid4().hex)

        comparison_result = findDynamicContent(resp1_body, resp2_body)

        # Re-send original payloaded request to validate injection
        original_responses = await send_request(webrequester, request.request_url, request.request_method, request.request_headers, request.request_body)

        for resp_payload in original_responses:
            payload_body = resp_payload.response.response_body if resp_payload.response else None

            if comparison_result is True:  # Response is dynamic
                logger.info("Response seems to be dynamic")
                cleaned_resp1 = removeDynamicContent(resp1_body)
                cleaned_payload = removeDynamicContent(removeReflectiveValues(payload_body, payload)) if payload_body else None

            elif comparison_result is False:  # Not dynamic
                logger.info("Response does not seem to be dynamic")
                cleaned_resp1 = resp1_body
                cleaned_payload = removeReflectiveValues(payload_body, payload) if payload_body else None

            else:  # comparison_result is None
                logger.info("Response seems to be empty")
                results.append({
                    "type": VulnType.SQL,
                    "vulnerable": False,
                    "param": param_name,
                    "payload": payload,
                    "request_original": pair1.request,
                    "response_original": pair1.response,
                    "request_payload": resp_payload.request,
                    "response_payload": resp_payload.response,
                    "notes": "Response seems to be empty"
                })
                continue

            #logger.info(f"cleaned_resp1: {cleaned_resp1}")
            #logger.info(f"cleaned_payload: {cleaned_payload}")
            if cleaned_payload and comparison(cleaned_payload, False, None, cleaned_resp1):
                logger.info(f"[SQLi] It does not seem to be vulnerable to SQLi")
                results.append({
                    "type": VulnType.SQL,
                    "vulnerable": False,
                    "param": param_name,
                    "payload": payload,
                    "request_original": pair1.request,
                    "response_original": pair1.response,
                    "request_payload": resp_payload.request,
                    "response_payload": resp_payload.response,
                    "notes": f"[SQLi] It does not seem to be vulnerable to SQLi"
                })

                
            else:
                logger.info(f"✅ [SQLi] Payload {payload} seems to have worked")
                results.append({
                    "type": VulnType.SQL,
                    "vulnerable": True,
                    "param": param_name,
                    "payload": payload,
                    "request_original": pair1.request,
                    "response_original": pair1.response,
                    "request_payload": resp_payload.request,
                    "response_payload": resp_payload.response,
                    "notes": f"✅ [SQLi] Payload {payload} seems to have worked"
                })
                
    return results

async def validate_sqli(request_response_list, vuln_param_payload, mal_payload):
    """
    Validates potential SQLi payloads by sending follow-up requests and comparing responses.
    """
    final_results = []

    for req_resp in request_response_list.req_resp_list:
        if not req_resp.response or not req_resp.response.response_body:
            continue

        for param_name, payload in vuln_param_payload.items():
            # Check if payload is in URL, headers, or body
            if (
                payload in req_resp.request.request_url or
                payload in req_resp.request.request_body or
                payload in str(req_resp.request.request_headers)
            ):
                logger.info(f"[SQLi] Payload \"{payload}\" found in request. Validating...")
                check_results = await validate_sqli_request(req_resp.request, payload, param_name, mal_payload)
                final_results.append(check_results)

    return final_results

# TODO: ADD STORED XSS CHECK
async def validate_xss(request_response_list, vuln_param_payload) -> list:
    """
    Checks request/response objects for reflected XSS payloads.
    Returns a list of confirmed vulnerable entries.
    """
    valid = False
    result = ValidatorResultList([])
    for request_response in request_response_list.req_resp_list:
        if request_response.response and request_response.response.response_body:
            for param_name, payload in vuln_param_payload.items():
                # Validate it ourselves
                if payload in request_response.request.request_url or payload in request_response.request.request_body or payload in request_response.request.request_headers:
                    logger.info(f"[XSS] Payload \"{payload}\" found in the request URL, header or body, checking...")
                    valid = await validate_xss_request_browser(request_response.request, payload, param_name)
                    if valid:
                        logger.info(f"✅ [XSS] Payload \"{payload}\". Payload triggered a popup")
                        result.root.append(ValidatorResult(
                            vulnerability = VulnType.XSS,
                            type = [XSSType.REFLECTED, XSSType.DOM_BASED],
                            vulnerable = True,
                            param = param_name,
                            payload = payload,
                            request_response = request_response,
                            notes = "Payload triggered a popup"
                        ))

                # Validate agent's requests and responses
                if payload in request_response.response.response_body or unquote(payload) in request_response.response.response_body or unquote_plus(payload) in request_response.response.response_body:
                    logger.info(f"✅ [XSS] Payload \"{payload}\" found in the response body")
                    valid = await validate_xss_response_browser(request_response.response.response_body)
                    if valid:
                        logger.info(f"✅ [XSS] Payload \"{payload}\" found in the response body and triggered popup box in browser")
                        result.root.append(ValidatorResult(
                            vulnerability = VulnType.XSS,
                            type = [XSSType.REFLECTED],
                            vulnerable = True,
                            param = param_name,
                            payload = payload,
                            request_response = request_response,
                            notes = "Payload appeared in HTTP response and it triggered a popup box"
                        ))
                    else:
                        logger.info(f"[XSS] Payload \"{payload}\" found in the response body but did not trigger popup box")
                        result.root.append(ValidatorResult(
                            vulnerability = VulnType.XSS,
                            type = [XSSType.REFLECTED],
                            vulnerable = False,
                            param = param_name,
                            payload = payload,
                            request_response = request_response,
                            notes = "Payload appeared in HTTP response but did not trigger popup box"
                        ))
        else:
            logger.error(f"[XSS] Payload \"{payload}\". HTTP response is None, check again")
            result.root.append(ValidatorResult(
                            vulnerability = VulnType.XSS,
                            type = [XSSType.ERROR],
                            vulnerable = False,
                            param = param_name,
                            payload = payload,
                            request_response = request_response,
                            notes = "HTTP response is None, check again"
                        ))
    return result

async def validate_xss_response_browser(response) -> bool:
    result = False
    fn = f"static/{uuid.uuid4().hex}.html"
    url = f"file:///app/{fn}"
    with open(fn, 'w', encoding='utf-8') as of:
        of.write(str(response))

    try:
        logger.info(f"response: {response}")
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context(ignore_https_errors=True)
            page = await context.new_page()
            alerts_triggered = []

            # Use proper async handler
            async def handle_dialog(dialog):
                alerts_triggered.append(dialog.message)
                await dialog.dismiss()

            # Capture alert(), prompt(), confirm()
            page.on("dialog", handle_dialog)
            await page.goto(url, wait_until='networkidle')

            # Give time for scripts to run
            await asyncio.sleep(2)

            if alerts_triggered:
                logger.info(f"XSS Triggered: {alerts_triggered}")
                result = True
            else:
                logger.info("No XSS alerts triggered.")
                result = False

            await browser.close()

    except Exception as e:
        logger.error(f"An error occurred: {e}")

    finally:
        os.unlink(fn)
        
    return result

async def validate_xss_request_browser(request: RequestDetails, payload, param_name) -> bool:
    result = False
    webrequester = WebRequesterTool(use_vpn=False)
    request_result = await webrequester.arun_web_requester(request.request_url, request.request_method, request.request_headers, request.request_body)
    request_result = json.loads(request_result)
    request_result = parse_obj_as(List[RequestResponsePair], request_result)
    for request_response in request_result:
        response = request_response.response
        if response:
            result = await validate_xss_response_browser(response.response_body)
            if result:
                return result
        else:
            return result
    return result

# Utility to decode response bytes to str safely
def _safe_text(b: bytes) -> str:
    try:
        return b.decode('utf-8', errors='replace')
    except Exception:
        return str(b)
    
# Minimal evidence matcher for file-like results (e.g., /etc/passwd)
XXE_BODY_PATTERNS = [
    re.compile(r"root:.*:0:0:"),          # /etc/passwd hint
    re.compile(r"<!DOCTYPE\s+(?!HTML)[\s\S]*?>", re.I),
    re.compile(r"<\?xml"),                # XML content echoes
]

async def validate_xxe(request_response_list, vuln_param_payload):
    """
    Validate whether an XXE (XML External Entity) injection attempt was successful.

    This function examines a list of request/response objects for evidence that an XXE payload
    executed or caused file disclosure.

    Parameters
    ----------
    request_response_list : RequestResponseList
        An object holding multiple request/response pairs (e.g. request_response_list.req_resp_list).
        Each `request_response` is expected to have:
            - response.response_body : bytes
            - response.response_headers : dict-like (keys are case-insensitive)
            - response.url : str (optional)
            - response.status : int
            - request_body : bytes or str (optional)
    vuln_param_payload : str | dict
        The payload(s) submitted during testing.
        - If a string, treated as the full payload.
        - If a dict, keys are parameter names and values are the corresponding payloads.

    Returns
    -------
    ValidatorResultList
        A structured result object containing one or more `ValidatorResult` entries, each describing:
            - vulnerability : VulnType (XXE)
            - type : list[XXEType]
            - vulnerable : bool
            - param : str | None
            - payload : str | None
            - request_response : original response object
            - notes : str with explanation

    Detection logic
    ---------------
    1. Checks Content-Type headers for XML indicators (application/xml, text/xml, etc.).
    2. If the payload was reflected in the body, mark as potential file read XXE.
    3. Scans the response body for heuristic patterns (e.g. /etc/passwd entries, <!DOCTYPE not HTML, <?xml).
    4. If the payload contains an HTTP/HTTPS URL, attempts OOB (out-of-band) validation via webhook.
    5. Adds a "not vulnerable" marker if no evidence is found.

    Notes
    -----
    - This function does not stop after the first finding; it may append multiple results.
    - Uses `_safe_text` to decode response bodies safely.
    - Out-of-band validation is attempted if payloads contain a URL, using `webhook_validation`.
    """
    for request_response in request_response_list.req_resp_list:
        body_text = _safe_text(request_response.response.response_body or b"")
        content_type_headers = request_response.response.response_headers.get("Content-Type", "").lower()
        #headers_text = " | ".join(f"{k}:{v}" for k, v in request_response.response.response_headers.items())
        result = ValidatorResultList([])

        # 0) Exact marker check (in-band)
        """
        if marker:
            if marker in body_text or marker in headers_text or (response.url and marker in response.url):
                evidence.append(f"Marker '{marker}' found in response body/headers/url.")
                return {"vulnerable": True, "evidence": evidence, "oob": None, "notes": "In-band marker found."}
        """

        if "text/xml" in content_type_headers or "application/xml" in content_type_headers or "plain/xml" in content_type_headers:
            result.root.append(ValidatorResult(
                vulnerability = VulnType.XXE,
                type = [XXEType.XML_HEADER],
                vulnerable = False,
                param = None,
                payload = vuln_param_payload,
                request_response = request_response,
                notes = f"The response seems to be in XML format"
            ))

        if isinstance(vuln_param_payload, str):
            try:
            # 1) Submitted payload reflected back (simple heuristic)
            # Some payloads are XML fragments that get reflected. Search for short substrings to avoid noise.
                # choose a short representative substring if payload is long
                substr = vuln_param_payload
                if len(substr) > 60:
                    # try to pick an inner token, remove whitespace
                    s = re.sub(r"\s+", " ", substr)
                    substr = s[:48]
                if substr and substr.strip() and substr.strip() in body_text:
                    logger.info("Submitted payload appears to be reflected in response body.")
                    result.root.append(ValidatorResult(
                        vulnerability = VulnType.XXE,
                        type = [XXEType.FILE_READ],
                        vulnerable = True,
                        param = None,
                        payload = vuln_param_payload,
                        request_response = request_response,
                        notes = f"Submitted payload appears to be reflected in response body. There is no parameter name, likely the injection point is the whole request body."
                    ))
                    # continue to try OOB if available - but we can already mark as likely successful
            except Exception:
                pass

            # 2) Look for file-like contents or XML constructs that indicate entity expansion
            for pat in XXE_BODY_PATTERNS:
                if pat.search(body_text):
                    logger.info(f"Heuristic pattern matched: {pat.pattern}")
                    result.root.append(ValidatorResult(
                        vulnerability = VulnType.XXE,
                        type = [XXEType.FILE_READ],
                        vulnerable = True,
                        param = None,
                        payload = vuln_param_payload,
                        request_response = request_response,
                        notes = f"Heuristic pattern matched: {pat.pattern}. There is no parameter name, likely the injection point is the whole request body."
                    ))
                    break

            # 3) If an OOB id and checker are provided, consult the OOB service
            #result = ValidatorResultList([])
            if "https://" in vuln_param_payload or "http://" in vuln_param_payload:
                try:
                    webrequester = WebRequesterTool(use_vpn=False, proxies=PROXIES)
                    result1 = await webhook_validation(request_response, vuln_param_payload, webrequester, None, VulnType.XXE)
                    result.root.append(result1)
                except Exception as e:
                    # don't fail the validation entirely just because OOB check failed
                    logger.info(f"OOB check failed or errored: {e}")
                    result.root.append(ValidatorResult(
                        vulnerability = VulnType.XXE,
                        type = [XXEType.WEBHOOK],
                        vulnerable = False,
                        param = None,
                        payload = vuln_param_payload,
                        request_response = request_response,
                        notes = f"OOB check failed or errored: {e}"
                    ))
            
        elif isinstance(vuln_param_payload, dict):
            for param_name, payload in vuln_param_payload.items():
                try:
                # 1) Submitted payload reflected back (simple heuristic)
                # Some payloads are XML fragments that get reflected. Search for short substrings to avoid noise.
                    # choose a short representative substring if payload is long
                    substr = payload
                    if len(substr) > 60:
                        # try to pick an inner token, remove whitespace
                        s = re.sub(r"\s+", " ", substr)
                        substr = s[:48]
                    if substr and substr.strip() and substr.strip() in body_text:
                        logger.info("Submitted payload appears to be reflected in response body.")
                        result.root.append(ValidatorResult(
                            vulnerability = VulnType.XXE,
                            type = [XXEType.FILE_READ],
                            vulnerable = True,
                            param = None,
                            payload = payload,
                            request_response = request_response,
                            notes = f"Submitted payload appears to be reflected in response body."
                        ))
                        # continue to try OOB if available - but we can already mark as likely successful
                except Exception:
                    pass

                # 2) Look for file-like contents or XML constructs that indicate entity expansion
                for pat in XXE_BODY_PATTERNS:
                    if pat.search(body_text):
                        logger.info(f"Heuristic pattern matched: {pat.pattern}")
                        result.root.append(ValidatorResult(
                        vulnerability = VulnType.XXE,
                        type = [XXEType.FILE_READ],
                        vulnerable = True,
                        param = None,
                        payload = payload,
                        request_response = request_response,
                        notes = f"Heuristic pattern matched: {pat.pattern}."
                    ))
                        break

                # 3) If an OOB id and checker are provided, consult the OOB service
                if "https://" in payload or "http://" in payload:
                    try:
                        webrequester = WebRequesterTool(use_vpn=False)
                        result1 = await webhook_validation(request_response, payload, webrequester, param_name, VulnType.XXE)
                        result.root.append(result1)

                    except Exception as e:
                        # don't fail the validation entirely just because OOB check failed
                        logger.info(f"OOB check failed or errored: {e}")
                        result.root.append(ValidatorResult(
                            vulnerability = VulnType.XXE,
                            type = [XXEType.WEBHOOK],
                            vulnerable = False,
                            param = None,
                            payload = payload,
                            request_response = request_response,
                            notes = f"OOB check failed or errored: {e}"
                        ))
        else:
            result.root.append(ValidatorResult(
            vulnerability = VulnType.XXE,
            type = [XXEType.ERROR],
            vulnerable = False,
            param = None,
            payload = None,
            request_response = request_response,
            notes = "Vulnerable parameter and payload are not str or dict type."
        ))

    if not result.root or (len(result.root) == 1 and result.root[0].type == [XXEType.XML_HEADER]):
    # 6) Nothing found
        result.root.append(ValidatorResult(
            vulnerability = VulnType.XXE,
            type = [XXEType.NOT_VULNERABLE],
            vulnerable = False,
            param = None,
            payload = None,
            request_response = request_response,
            notes = "No in-band evidence or OOB callback was found. Claim not validated."
        ))
    return result

async def validate_ssrf(request_response_list, vuln_param_payload):
    """
    Reads a JSONL file as a list of parsed JSON objects.
    """
    webrequester = WebRequesterTool(use_vpn=False)
    result = ValidatorResultList([])
    for param_name, payload in vuln_param_payload.items():
        for req_resp in request_response_list.req_resp_list:
            response = req_resp.response
            if not response or not response.response_body:
                logger.error(f"[SSRF] Payload \"{payload}\". Response is empty")
                result.root.append(ValidatorResult(
                    vulnerability = VulnType.OPEN_REDIRECT,
                    type = RedirectType.ERROR,
                    vulnerable = False,
                    param = param_name,
                    payload = payload,
                    request_response = req_resp,
                    notes = "Response is empty"
                ))
                continue
            partial_result = await webhook_validation(req_resp, payload, webrequester, param_name, VulnType.SSRF) or []
            result.root.extend(partial_result.root)
    return result

async def validate_or_request_browser(request, payload) -> bool:
    result = False
    final_domain = ""
    payload_domain = urlparse(payload).netloc.lower()
    matched_domains = set()

    try:
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context(ignore_https_errors=True)
            page = await context.new_page()

            # Track all network requests
            page.on("request", lambda req: matched_domains.add(f"{urlparse(req.url).scheme.lower()}://{urlparse(req.url).netloc.lower()}"))

            # Go to the initial URL
            await page.goto(request.request_url, wait_until='networkidle')

            # Allow time for redirects or JS-based navigations
            await asyncio.sleep(2)

            final_domain = urlparse(page.url).netloc.lower()
            final_scheme = urlparse(page.url).scheme.lower()
            logger.info(f"Visited URL: {request.request_url}")
            logger.info(f"Final URL after redirect: {final_scheme}://{final_domain}")

            # Logging all matched domains for debug
            logger.info(f"All contacted domains: {matched_domains}")

            # Check if payload domain appears in final or intermediate requests
            if (
                payload_domain in final_domain or
                final_domain in payload_domain or
                payload_domain in matched_domains
            ):
                logger.info(f"✅ [Open Redirect] Payload domain found in requests : {payload_domain}")
                result = True
            else:
                logger.info("No open redirect detected.")

            await browser.close()

    except Exception as e:
        logger.error(f"An error occurred: {e}")

    return result

async def is_payload_in_redirect_sink(payload, body):
    """
    Checks if payload is reflected in places likely to cause a redirect.
    """
    result = []
    decoded_payloads = list(set([payload, unquote(payload), unquote_plus(payload)]))
    for p in decoded_payloads:
        redirect_patterns = [
            (RedirectType.HREF, rf'href=["\'].*{re.escape(p)}.*["\']'),
            (RedirectType.WINDOW_LOCATION, rf'window\.location(?:\.href)?\s*=\s*["\'].*{re.escape(p)}.*["\']'),
            (RedirectType.DOCUMENT_LOCATION, rf'document\.location\s*=\s*["\'].*{re.escape(p)}.*["\']'),
            (RedirectType.WINDOW_OPEN, rf'window\.open\(["\'].*{re.escape(p)}.*["\']'),
            (RedirectType.META_REFRESH, rf'<meta\s+http-equiv=["\']refresh["\'].*content=["\']\d+;\s*url=.*{re.escape(p)}.*["\']'),
            #(RedirectType.HTTP_REFRESH_HEADER, rf'Refresh:\s*\d+;\s*url=["\']?.*{re.escape(p)}.*["\']?')
        ]

        for label, pattern in redirect_patterns:
            if re.search(pattern, body, flags=re.IGNORECASE):
                #print(f"[MATCH] Payload matched redirect sink: {label}")
                result.append(label)
    if result:
        return result
    else:
        return None

async def validate_or_response(location_header, refresh_header, request_response, param_name, payload, body, who):
    result = ValidatorResultList([])
    msg = f"in the HTTP response given by {'the AI agent' if who == 'agent' else 'manually sending request'}"
    decoded_payloads = list(set([payload, unquote(payload), unquote_plus(payload)]))
    location_header_result = False
    refresh_header_result = False

    # Check Location header
    if location_header:
        for p in decoded_payloads:
            if p in location_header:
                location_header_result = True

    # Check Refresh header
    if refresh_header:
        for p in decoded_payloads:
            if p in refresh_header:
                refresh_header_result = True
    
    # Check body for known sinks
    if body:
        logger.info(f"payload: {payload}")
        sink_result = await is_payload_in_redirect_sink(payload, body)
        sink_type = sink_result if sink_result else RedirectType.BODY_REFLECTION
        if location_header_result:
            sink_type.append(RedirectType.LOCATION_HEADER)
        if refresh_header_result:
            sink_type.append(RedirectType.REFRESH_HEADER)
        if sink_result:
            logger.info(f"✅ [Open Redirect] Payload \"{payload}\" found in a \"{sink_result}\" {msg}")
            result.root.append(ValidatorResult(
                vulnerability = VulnType.OPEN_REDIRECT,
                type = [RedirectType.WEBHOOK_REQUEST],
                vulnerable = True,
                param = param_name,
                payload = payload,
                request_response = request_response,
                notes = f"✅ Payload \"{payload}\" found in \"{sink_result}\" {msg}"
            ))
        else:
            logger.info(f"[Open Redirect] Payload \"{payload}\" not found in HTTP response header or body")
            result.root.append(ValidatorResult(
                vulnerability = VulnType.OPEN_REDIRECT,
                type = [RedirectType.NOT_VULNERABLE], # TODO: Standardize type for not vulnerable
                vulnerable = False,
                param = param_name,
                payload = payload,
                request_response = request_response,
                notes = f"Payload \"{payload}\" not found in HTTP response header or body"
            ))
    return result

async def replace_param_value_universal(data: str, param_name: str, new_value: str) -> str:
    # Pattern: handles both form-urlencoded and JSON (quoted or unquoted)
    patterns = [
        # Form-urlencoded: param=original
        rf'({re.escape(param_name)}=)[^&\s]*',

        # JSON double-quoted: "param":"original"
        rf'("{re.escape(param_name)}"\s*:\s*")[^"]*(")',

        # JSON single-quoted: 'param':'original'
        rf"('{re.escape(param_name)}'\s*:\s*')[^']*(')",

        # JSON unquoted value (e.g. "param": 123 or true/null)
        rf'("{re.escape(param_name)}"\s*:\s*)[^,\s\}}]+',
    ]

    for pattern in patterns:
        data = re.sub(pattern, lambda m: m.group(1) + new_value + (m.group(2) if len(m.groups()) > 1 else ''), data)

    return data

async def replace_payload_value_universal(data: str, payload: str, new_value: str) -> str:
    data = data.replace(payload, new_value)
    return data

async def wait_for_webhook(uid: str, type: VulnType, max_attempts=3, delay=4, debug=False) -> bool:
    """
    Checks if the UID appears in the webhook result, retrying up to 3 times.

    :param uid: UUID to check in the webhook result
    :param max_attempts: Number of retry attempts
    :param delay: Delay between attempts in seconds
    :return: True if UID found in webhook result; False otherwise
    """
    if not uid:
        return False
    conn = aiohttp.TCPConnector(
                family=socket.AF_INET,
                verify_ssl=False,
            )

    ssl_context = ssl.create_default_context()
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE

    for attempt in range(max_attempts):
        await asyncio.sleep(delay)
        try:
            async with aiohttp.ClientSession(connector=conn,connector_owner=False) as session:
                async with session.get(WEBHOOK_RESULT, headers={
                    "x-api-key": WEBHOOK_API_KEY,
                    "Connection": "close",
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36"
                    }, 
                    raise_for_status=False,
                    ssl=ssl_context) as response:
                    text = await response.text()
                    if debug:
                        logger.debug(f"[Webhook Attempt {attempt+1}] Response: {text}")
                    if uid in text:
                        logger.info(f"✅ [{type}] Webhook UID {uid} found in webhook.")
                        return True
        except aiohttp.ClientError as e:
            logger.error(f"Webhook attempt {attempt+1} failed: {e}")
    return False

async def validate_xss_with_browser(request: RequestDetails, payload: str) -> bool:
    """
    Launch browser and track network requests to detect payload redirection.
    """
    payload_domain = urlparse(payload).netloc.lower()
    visited_domains = set()
    #result = []

    try:
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context(ignore_https_errors=True)
            page = await context.new_page()

            page.on("request", lambda req: visited_domains.add(urlparse(req.url).netloc.lower()))
            await page.goto(request.request_url, wait_until='networkidle')
            await asyncio.sleep(2)  # Allow dynamic JS redirects

            final_url = page.url
            final_domain = urlparse(final_url).netloc.lower()

            logger.info(f"Visited: {request.request_url} → Final: {final_url}")
            logger.info(f"Intermediate domains visited: {visited_domains}")

            # Direct URL match
            if final_url.lower() in payload.lower() or payload.lower() in final_url.lower():
                logger.info(f"✅ [Open Redirect] Final URL exactly matches the payload: {payload}")
                return RedirectType.BROWSER_FINAL_URL

            # DOM-based check (already present)
            if payload_domain in final_domain or payload_domain in visited_domains or final_domain in payload_domain:
                return RedirectType.BROWSER_DOM

    except Exception as e:
        logger.error(f"Browser validation failed: {e}")
        return False
    return False

async def validate_or_with_browser(request: RequestDetails, payload: str) -> bool:
    """
    Launch browser and track network requests to detect payload redirection.
    """
    payload_domain = urlparse(payload).netloc.lower()
    visited_domains = set()
    #result = []

    try:
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context(ignore_https_errors=True)
            page = await context.new_page()

            page.on("request", lambda req: visited_domains.add(urlparse(req.url).netloc.lower()))
            await page.goto(request.request_url, wait_until='networkidle')
            await asyncio.sleep(2)  # Allow dynamic JS redirects

            final_url = page.url
            final_domain = urlparse(final_url).netloc.lower()

            logger.info(f"Visited: {request.request_url} → Final: {final_url}")
            logger.info(f"Intermediate domains visited: {visited_domains}")

            # Direct URL match
            if final_url.lower() in payload.lower() or payload.lower() in final_url.lower():
                logger.info(f"✅ [Open Redirect] Final URL exactly matches the payload: {payload}")
                return RedirectType.BROWSER_FINAL_URL

            # DOM-based check (already present)
            if payload_domain in final_domain or payload_domain in visited_domains or final_domain in payload_domain:
                return RedirectType.BROWSER_DOM

    except Exception as e:
        logger.error(f"Browser validation failed: {e}")
        return False
    return False

async def validate_or(request_response_list, vuln_param_payload):
    result = ValidatorResultList([])
    webrequester = WebRequesterTool(use_vpn=False)

    for param_name, payload in vuln_param_payload.items():
        for req_resp in request_response_list.req_resp_list:
            response = req_resp.response
            if not response or not response.response_body:
                logger.error(f"[Open Redirect] Payload \"{payload}\". Response is empty")
                result.root.append(ValidatorResult(
                    vulnerability = VulnType.OPEN_REDIRECT,
                    type = [RedirectType.ERROR],
                    vulnerable = False,
                    param = param_name,
                    payload = payload,
                    request_response = req_resp,
                    notes = "Response is empty"
                ))
                continue

            # 1. Agent response validation
            partial_result = await validate_or_response(
                response.response_headers.get("Location") or response.response_headers.get("location"),
                response.response_headers.get("Refresh") or response.response_headers.get("refresh"),
                req_resp,
                param_name,
                payload,
                response.response_body,
                "agent"
            )
            result.root.extend(partial_result.root)

            # 2. Browser-based check
            result1 = await validate_or_with_browser(req_resp.request, payload)
            if result1 == RedirectType.BROWSER_FINAL_URL:
                logger.info(f"✅ Payload \"{payload}\" found in the final URL of redirection: {RedirectType.BROWSER_FINAL_URL}")
                result.root.append(ValidatorResult(
                    vulnerability = VulnType.OPEN_REDIRECT,
                    type = [RedirectType.BROWSER_FINAL_URL],
                    vulnerable = True,
                    param = param_name,
                    payload = payload,
                    request_response = req_resp,
                    notes = f"✅ Payload \"{payload}\" found in the final URL of redirection: {RedirectType.BROWSER_FINAL_URL}"
                ))
            elif result1 == RedirectType.BROWSER_DOM:
                logger.info(f"✅ Payload \"{payload}\" found in one of the multiple requests, might be DOM-based: {RedirectType.BROWSER_DOM}")
                result.root.append(ValidatorResult(
                    vulnerability = VulnType.OPEN_REDIRECT,
                    type = [RedirectType.BROWSER_DOM],
                    vulnerable = True,
                    param = param_name,
                    payload = payload,
                    request_response = req_resp,
                    notes = f"✅ Payload \"{payload}\" found in one of the multiple requests, might be DOM-based: {RedirectType.BROWSER_DOM}"
                ))
            else:
                logger.info(f"Payload \"{payload}\". Browser validation failed")
                result.root.append(ValidatorResult(
                    vulnerability = VulnType.OPEN_REDIRECT,
                    type = [RedirectType.ERROR],
                    vulnerable = False,
                    param = param_name,
                    payload = payload,
                    request_response = req_resp,
                    notes = "Browser validation failed"
                ))
            
            # 3. Request-based check
            raw_response = await webrequester.arun_web_requester(req_resp.request.request_url, req_resp.request.request_method, req_resp.request.request_headers, req_resp.request.request_body)
            parsed_responses = parse_obj_as(List[RequestResponsePair], json.loads(raw_response))
            for pr in parsed_responses:
                logger.info(f"response_url: {pr.response.response_url}")
                partial_result = await validate_or_response(
                    pr.response.response_headers.get("Location") or pr.response.response_headers.get("location"),
                    pr.response.response_headers.get("Refresh") or pr.response.response_headers.get("refresh"),
                    pr,
                    param_name,
                    payload,
                    pr.response.response_body,
                    "self"
                )
                result.root.extend(partial_result.root)

            partial_result = await webhook_validation(req_resp, payload, webrequester, param_name, VulnType.OPEN_REDIRECT) or []
            result.root.extend(partial_result.root)

    return result or ValidatorResultList([
    ValidatorResult(
        vulnerability=VulnType.OPEN_REDIRECT,
        type=[RedirectType.NOT_VULNERABLE],  # since type is a List
        vulnerable=False,
        param=param_name,
        payload=None,
        request_response=None,
        notes=""
    )
])

async def check_intranet_domain(hostname: str):
    if hostname:
        parts = hostname.split(".")
        last_section = parts[-1]

        # Check if last section has digits or is less than 2 characters
        if len(last_section) < 2 or any(c.isdigit() for c in last_section):
            print(f"Domain '{hostname}' has a weird TLD/extension: '{last_section}'. This is likely an intranet hostname.")
            return True
        else:
            print(f"Domain '{hostname}' looks normal. This is likely an internet hostname.")
            return False
    
async def webhook_validation(req_resp, payload, webrequester, param_name, type):
    def is_plain_url(payload: str) -> bool:
        parsed = urlparse(payload.strip())
        return parsed.netloc#all([parsed.scheme in ("http", "https"), parsed.netloc])

    # 4. Webhook validation via request
    result = ValidatorResultList([])
    uid = str(uuid.uuid4().hex)
    

    plain_url = is_plain_url(payload)
    logger.info(f"plain_url: {plain_url}")
    if plain_url:
        logger.info("is_plain_url")
        parsed = urlparse(payload)._replace(netloc=urlparse(WEBHOOK).netloc)
        webhook_payload = urlunparse(parsed) + f"?{uid}"
        modified_url = await replace_payload_value_universal(req_resp.request.request_url, parsed, webhook_payload)
        modified_body = await replace_payload_value_universal(req_resp.request.request_body, parsed, webhook_payload)
    else:
        for url in re.findall(r'(https?://[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)*(?::\d+)?)', payload):
            logger.info(f"url: {url}")
            parsed = urlparse(url)  # prepend scheme so urlparse can parse netloc
            # check if last section of extension contains digits, if yes, likely intranet
            await check_intranet_domain(parsed.hostname)
        #payload = payload.replace(parsed.netloc, webhook_payload) + f"?{uid}"
        webhook_payload = WEBHOOK + f"?{uid}"

        #modified_url = await replace_param_value_universal(req_resp.request.request_url, param_name, webhook_payload)
        #modified_body = await replace_param_value_universal(req_resp.request.request_body, param_name, webhook_payload)

        modified_url = await replace_payload_value_universal(req_resp.request.request_url, parsed.hostname, webhook_payload)
        modified_body = await replace_payload_value_universal(req_resp.request.request_body, parsed.hostname, webhook_payload)
        logger.info(f"modified_body: {modified_body}")
    
    
    raw_response = await webrequester.arun_web_requester(modified_url, req_resp.request.request_method, req_resp.request.request_headers, modified_body)
    parsed_responses = parse_obj_as(List[RequestResponsePair], json.loads(raw_response))

    if type == VulnType.OPEN_REDIRECT:
        for pr in parsed_responses:
            logger.info(f"response_url: {pr.response.response_url}")
            partial_result = await validate_or_response(
                pr.response.response_headers.get("Location") or pr.response.response_headers.get("location"),
                pr.response.response_headers.get("Refresh") or pr.response.response_headers.get("refresh"),
                pr,
                param_name,
                webhook_payload,
                pr.response.response_body,
                "self"
            )
            result.root.extend(partial_result.root)

    if await wait_for_webhook(uid, type):
        logger.info(f"✅ [{type}] Payload \"{payload}\". Redirection found in the final URL of redirection")
        result.root.append(ValidatorResult(
            vulnerability = type,
            type = [RedirectType.WEBHOOK_REQUEST],
            vulnerable = True,
            param = param_name,
            payload = webhook_payload,
            request_response = req_resp,
            notes = "Redirection found in the final URL of redirection"
        ))

    # 5. Webhook validation via browser
    uid = str(uuid.uuid4().hex)
    webhook_payload = urlunparse(parsed) + f"?{uid}"
    logger.info(f"webhook_payload: {webhook_payload}")
    #req_resp.request.request_url = await replace_param_value_universal(req_resp.request.request_url, param_name, webhook_payload)
    #req_resp.request.request_body = await replace_param_value_universal(req_resp.request.request_body, param_name, webhook_payload)

    req_resp.request.request_url = await replace_payload_value_universal(req_resp.request.request_url, payload, webhook_payload)
    req_resp.request.request_body = await replace_payload_value_universal(req_resp.request.request_body, payload, webhook_payload)

    result1 = await validate_or_with_browser(req_resp.request, webhook_payload)
    if result1 == RedirectType.BROWSER_FINAL_URL:
        logger.info(f"✅ [{type}] Payload \"{payload}\". Redirection found in the final URL of redirection")
        result.root.append(ValidatorResult(
            vulnerability = type,
            type = [RedirectType.BROWSER_FINAL_URL],
            vulnerable = True,
            param = param_name,
            payload = webhook_payload,
            request_response = req_resp,
            notes = "Redirection found in the final URL of redirection"
        ))
    elif result1 == RedirectType.BROWSER_DOM:
        logger.info(f"✅ [{type}] Payload \"{payload}\". Redirection found in one of the multiple requests, might be DOM-based")
        result.root.append(ValidatorResult(
            vulnerability = type,
            type = [RedirectType.BROWSER_DOM],
            vulnerable = True,
            param = param_name,
            payload = webhook_payload,
            request_response = req_resp,
            notes = "Redirection found in one of the multiple requests, might be DOM-based"
        ))
    else:
        logger.error(f"[{type}] Payload \"{payload}\". Browser validation failed")
        result.root.append(ValidatorResult(
            vulnerability = type,
            type = [RedirectType.ERROR],
            vulnerable = False,
            param = param_name,
            payload = webhook_payload,
            request_response = req_resp,
            notes = "Browser validation failed"
        ))

    if await wait_for_webhook(uid, type):
        logger.info(f"✅ [{type}] Payload \"{payload}\". Redirection found in the final URL of redirection")
        result.root.append(ValidatorResult(
            vulnerability = type,
            type = [RedirectType.WEBHOOK_BROWSER],
            vulnerable = True,
            param = param_name,
            payload = webhook_payload,
            request_response = req_resp,
            notes = "Redirection found in the final URL of redirection"
        ))

    return result

async def report_parser():
    pass