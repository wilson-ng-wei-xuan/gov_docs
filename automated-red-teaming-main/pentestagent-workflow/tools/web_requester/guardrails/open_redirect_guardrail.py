import re
import copy
from urllib.parse import parse_qs, urlparse
from tools.web_requester.guardrails.common import WebRequesterGuardrail
from typing import Any, List, Optional, Dict
from tools.guardrails.common import SafetyResult, precheck_for


SAFE_DOMAINS = ["example.com", "localhost"]

# Guardrail

class OpenRedirectWebRequesterGuardRail(WebRequesterGuardrail):
    """
    GuardRail for OpenRedirect Web Requests. Applies pre-checks to validate OpenRedirect payloads
    before sending them to the WebRequester. Post-processing steps can also be configured.

    Args:
        pre_flags (set[str] | str, optional):
            Which pre-check functions to enable. Options are:
            - "all" (default): enable all pre-check functions.
            - "none": disable all pre-check functions.
            - set of strings: choose specific checks, e.g. {"file_modification", "dos"}.

            Available pre-checks:
                - "domain_check": Verifies that only safe domains are redirected to

        post_flags (set[str] | str, optional):
            Which post-processing functions to enable. Options are:
            - "all" (default): enable all post-processing functions.
            - "none": disable all post-processing functions.
            - set of strings: choose specific steps (currently none are defined).

            Available post-processors: None
    """

    def __init__(
        self,
        pre_flags: set[str] | str = "all",
        post_flags: set[str] | str = "all",
        safe_domains: Optional[List[str]] = None,
    ):  
        if safe_domains is None:
            safe_domains = SAFE_DOMAINS
        self.safe_domains = safe_domains

        # Function to check if redirect parameter points somewhere unsafe
        @precheck_for("run_web_requester", "arun_web_requester")
        async def open_redirect_domain_check(
            url: str,
            method: str = "GET",
            headers: Optional[Dict[str, str]] = None,
            data: Any = None
        ) -> SafetyResult:
            """
            Checks if a redirect parameter points to an unsafe external domain.
            """

            parsed_url = urlparse(url)
            query_params = parse_qs(parsed_url.query)  # returns dict {param: [val1, val2]}

            # Iterate through all query parameters
            for param_values in query_params.values():
                for value in param_values:

                    # Skip empty values
                    if not value:
                        continue

                    # Parse the candidate as URL
                    parsed_candidate = urlparse(value)
                    domain = parsed_candidate.netloc

                    # If there is a domain, check if it's in SAFE_DOMAINS
                    # TODO: Undo domain check once more extensive
                    # if domain and not any(domain.endswith(sd) for sd in self.safe_domains):
                    #     return f"Unsafe: open-redirect target points to external domain '{domain} -- Try {self.safe_domains[0]} '"
        

        # Map string names to functions
        VALID_PRE = {
            "domain_check": open_redirect_domain_check,
        }

        VALID_POST = {
        }

        # Normalize flags
        if isinstance(pre_flags, str):
            pre_funcs = set() if pre_flags.lower() == "none" else set(VALID_PRE.keys())
        else:
            pre_funcs = copy.deepcopy(pre_flags)

        if isinstance(post_flags, str):
            post_funcs = set() if post_flags.lower() == "none" else set(VALID_POST.keys())
        else:
            post_funcs = copy.deepcopy(post_flags)
        
        pre_check = [func for name, func in VALID_PRE.items() if name in pre_funcs]
        post_process = [func for name, func in VALID_POST.items() if name in post_funcs]

        super().__init__(pre_flags=pre_flags, post_flags=post_flags, pre_check=pre_check, post_process=post_process, name="open_redirect_web")