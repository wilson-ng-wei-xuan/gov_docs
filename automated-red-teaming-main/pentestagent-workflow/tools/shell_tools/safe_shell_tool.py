import re
import os
import signal
import asyncio
from agno.utils.log import logger
from agno.tools import Toolkit
from typing import List, Optional
from tools.guardrails.common import precheck_for, truncate_output, redact_sensitive_info, sqli_mod_check, sqli_interaction_check, sqli_dos, SafetyResult
from tools.guardrails.base import Guardrail, GuardedToolkit
from server.interactions import get_user_input
from tools.common import tag_summarizer_payload

# Global Constants
MAX_SHELL_TIMEOUT = int(os.getenv("MAX_SHELL_TIMEOUT", 60))
MAX_SQLI_DELAY = int(os.getenv("MAX_SQLI_DELAY", 90))

# Whitelisted commands mapped to banned flags
WHITELIST_CMDS = {
    "echo": set(),
    "cat": set(),
    "head": set(),
    "grep": {"-r", "-R"},
    "curl": {"-o", "-O", "-k", "-K", "--output", "--remote-name"}
}

# Commands that are not strictly disallowed, rather there are alternative tools that are preferred
ALTERNATE_CMDS = {
    "wget": "WebRequester",
}

# Blacklisted commands
BLACKLIST_CMDS = set([
    "rm", "rmdir","mv","cp","scp","chmod","chown", "chgrp", "touch","dd", # File modification
    "reboot", "kill", "pkill", "killall", "bg", "fg", "ps", "systemctl" # Process and system
    "sh", "bash", "zsh", "dash", "exec", "eval", "sudo", "su", "source", # Shells and execution related
    "perl", "ruby", "php", "node", "lua", "awk", # Scripting related
    "env", "groups", # Identification related
])

# Path names that are sensitive
SENSITIVE_PATHS = [
    r"root", r"shadow", r"proc", r"env" 
]

# Prechecking Functions
@precheck_for("run_shell_command", "arun_shell_command")
async def shell_edge_case_check(command: List[str], *args, **kwargs) -> SafetyResult:
    """
    Checks for edge cases such as an empty command

    Args:
        command (List[str]): The command to run as a list of strings

    Returns:
        SafetyResult: None, if the safety checks pass. Else, returns the error messager for the agent
    """

    if not command:
        return "Error: Empty command"
    
    return None

@precheck_for("run_shell_command", "arun_shell_command")
async def shell_macro_safety_check_async(command: List[str], *args, **kwargs) -> SafetyResult:
    """
    Checks for unsafe shell constructs in a command list.

    Args:
        command (List[str]): Command tokens as passed by Agno agent.

    Returns:
        SafetyResult: None if safe, else an error message.
    """
    
    concat_ops = {"&", "&&", "||", ";", "|&"}

    # Regex to capture commands containing subshells that could potentially be harmful
    subshell_patterns = [re.compile(r"\$\("), re.compile(r"`")]

    # Check for concatenation / chaining
    for tok in command:
        if tok in concat_ops or tok[-1] == ";":
            return f"Unsafe: Found concatenation/chaining operator `{tok}`. " \
                   f"Split into individual tool calls."

    # Check for subshell / command substitution
    for tok in command:
        if any(p.search(tok) for p in subshell_patterns):
            return f"Unsafe: Found subshell/command substitution in `{tok}`. " \
                   f"Disallowed tool call."

    # If nothing suspicious
    return None

@precheck_for("run_shell_command", "arun_shell_command")
async def shell_list_safety_check_async(command: List[str], *args, **kwargs) -> SafetyResult:
    """
    Checks for whether the commands lie in whitelist/blacklist. If neither, should request for user confirmation

    Args:
        command (List[str]): The command to run as a list of strings

    Returns:
        SafetyResult: None, if the safety checks pass. Else, returns the error messager for the agent
    """

    # 1) Check if there are any forbidden commands
    if any(cmd in BLACKLIST_CMDS for cmd in command):
        return "Unsafe: Disallowed commands"
    
    primary_cmd = command[0]

    # 2) Check if the primary command has alternative preferred tools to be used
    if primary_cmd in ALTERNATE_CMDS:
        return f"Unsafe: Primary command is disallowed for current tool. Use {ALTERNATE_CMDS[primary_cmd]} tool instead (if available)"
    
    # 3) Check if the primary command has been whitelisted (and the flags are valid)
    if primary_cmd in WHITELIST_CMDS:
        if any((cmd.startswith("-") and cmd in WHITELIST_CMDS.get(primary_cmd, [])) for cmd in command):
            return "Unsafe: Primary command uses a disallowed flag"
    else:
        try:
            user_resp = await get_user_input(f"Requesting user permission to execute shell: {command} [Y/N]:", is_binary_choice=True)
            user_resp = user_resp.lower()
            
            if user_resp == "y":
                return None
            
            return "Unsafe: Command rejected by user"
                
        except Exception as e:
            logger.warning(f"Received error {e} during safety check")

            # NOTE: Should there be some specific form of error handling here
            return "Unsafe: Safety check failed to complete"

    return None

@precheck_for("run_shell_command", "arun_shell_command")
async def shell_unsafe_paths_safety_check_async(command: List[str], *args, **kwargs) -> SafetyResult:
    """
    Checks for unsafe paths

    Args:
        command (List[str]): The command to run as a list of strings

    Returns:
        SafetyResult: None, if the safety checks pass. Else, returns the error messager for the agent
    """
    path_regex = re.compile(r"/[A-Za-z0-9_\-./]+")
    for cmd in command:
        if any((path_regex.search(cmd) and re.search(sensitive_path, cmd)) for sensitive_path in SENSITIVE_PATHS):
            return "Unsafe: Detected sensitive path in command"
    
# Postchecking Functions
@precheck_for("run_shell_command", "arun_shell_command")
async def shell_payload_safety(command: List[str], *args, **kwargs) -> SafetyResult:
    possible_payload_indices = []
    for i in range(len(command)):
        if command[i] in {"-d", "--data", "--data-rwa"}:
            # Usually what follows is going to be the data
            possible_payload_indices.append(min(len(command), i))
        elif command[i].startswith("http"):
            # A URL and might contain the payload
            possible_payload_indices.append(i)

    res = []
    for i in possible_payload_indices:
        payload = command[i]
        
        # Mod check
        res.append(sqli_mod_check(payload=payload))
        res.append(sqli_interaction_check(payload=payload))
        res.append(sqli_dos(payload=payload))
    
    if res:
        return "\n".join([msg for msg in res if msg is not None])

    return None

# Default Guardrail, Guarded Toolkit that uses all the tools and has the same timeouts for everything
class ShellGuardRail(Guardrail):
    def __init__(
        self,
        pre_flags: set[str] | str = "all",
        post_flags: set[str] | str = "all",
    ):
        """
        Initialize a ShellGuardRail instance with configurable pre-check and post-processing steps.

        Args:
            pre_flags (set[str] | str, optional):
                Which pre-check functions to enable. Options are:
                - "all" (default): enable all pre-check functions.
                - "none": disable all pre-check functions.
                - set of strings: choose specific checks, e.g. {"edge_case", "path_safety"}.

                Available pre-checks:
                    - "edge_case"
                    - "macro_safety"
                    - "list_safety"
                    - "path_safety"

            post_flags (set[str] | str, optional):
                Which post-processing functions to enable. Options are:
                - "all" (default): enable all post-processing functions.
                - "none": disable all post-processing functions.
                - set of strings: choose specific steps, e.g. {"truncate_output"}.

                Available post-processors:
                    - "redact_sensitive"
                    - "truncate_output"
        """

        #NOTE Populate this (and the docstring) with the necessary strings describing any new functions you might add
        VALID_PRE = {
            "edge_case": shell_edge_case_check,
            "macro_safety": shell_macro_safety_check_async,
            "list_safety": shell_list_safety_check_async,
            "path_safety": shell_unsafe_paths_safety_check_async,
        }

        VALID_POST = {
            "redact_sensitive": redact_sensitive_info,
            "truncate_output": truncate_output,
        }

        # Normalize flags
        if isinstance(pre_flags, str):
            pre_flags = set() if pre_flags.lower() == "none" else set(VALID_PRE.keys())
        if isinstance(post_flags, str):
            post_flags = set() if post_flags.lower() == "none" else set(VALID_POST.keys())


        pre_check = [func for name, func in VALID_PRE.items() if name in pre_flags]
        post_process = [func for name, func in VALID_POST.items() if name in post_flags]

        super().__init__(pre_checking=pre_check, post_processing=post_process)


class ShellGuardedToolkit(GuardedToolkit):
    def __init__(self, pre_flags: set[str] | str = "all", post_flags: set[str] | str = "all", timeout: int = MAX_SHELL_TIMEOUT, *args, **kwargs):
        super().__init__(base_tool=SafeShellTool(timeout=timeout, *args, **kwargs),
                         guardrail=ShellGuardRail(pre_flags=pre_flags, post_flags=post_flags), 
                         tool_timeout=timeout)

# Safe Tool class (Async)

class SafeShellTool(Toolkit):
    """
    Version of ShellTools where you can explicitly forbid specific commands
    """

    def __init__(self, name: str = "safe_shell_tools", forbidden: List[str] = [], timeout: int = None, *args, **kwargs):
        self.timeout = timeout
        super().__init__(name=name, tools=[self.arun_shell_command], *args, **kwargs)

    @tag_summarizer_payload(summarizer_type="rolling", payload_type="shell_output")
    async def arun_shell_command(self, command: List[str]) -> str:
        """Asynchronously runs a shell command and returns the output or error.

        Args:
            command (List[str]): The command to run. This will be a list of the tokens in the command

        Returns:
            str: The output of the command.
        """

        try:
            process = await asyncio.create_subprocess_exec(
                *command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                preexec_fn=os.setsid  # only works on Unix (Linux/Mac)
            )

            if self.timeout:
                stdout, stderr = await asyncio.wait_for(process.communicate(), self.timeout)
            
            else:
                stdout, stderr = await process.communicate()
            
            response = stdout.decode()
            err_response = stderr.decode()
        except asyncio.CancelledError:
            # Kill the whole process group
            os.killpg(os.getpgid(process.pid), signal.SIGTERM)
            raise
        except asyncio.TimeoutError:
            return "Timeout (ShellTool): Process failed to complete"
        except Exception as e:
            return "Unsafe: Failed to execute command (command issue)"
        
        return response

    @tag_summarizer_payload(summarizer_type="rolling", payload_type="shell_output")
    def run_shell_command(self, command: List[str]) -> str:
        """Synchronously runs a shell command and returns the output or error.

        Args:
            command (List[str]): The command to run. This will be a list of the tokens in the command

        Returns:
            str: The output of the command.
        """
        
        try:
            loop = asyncio.get_running_loop()
            in_loop = True
        except RuntimeError:
            in_loop = False

        if not in_loop:
            return asyncio.run(self.arun_shell_command(command))
        else:
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor(max_workers=1) as ex:
                fut = ex.submit(lambda: asyncio.run(self.arun(command)))
                return fut.result()