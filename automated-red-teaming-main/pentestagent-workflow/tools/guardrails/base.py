import inspect
import asyncio
import os
from typing import Callable, List, Optional, Any
from functools import wraps
from agno.tools import Toolkit
from agno.utils.log import logger

# Global Constants and Enums
MAX_TIMEOUT = int(os.getenv("MAX_TIMEOUT", 60))

class Guardrail:
    """
    Custom guardrail in which we can pass a list of pre-checks and post-processing functions.
    """
    def __init__(self, name: str = "default", pre_checking: List[Callable] = [], post_processing: List[Callable] = []):
        """
        Args:
            name (str): Guardrail identifier.
            pre_checking (List[Callable]): Async functions to run (in order) prior to function call on function input. Each function should return None if the checks pass, or an error message if it fails.
            post_processing (List[Callable]): Async functions to run (in order) after function call on function output. Each function should return the output string after processing (may be an error message).

        Raises:
            TypeError: If pre_checking or post_processing are not async functions.
        """
        self.name = name
        self.pre_checking = pre_checking
        self.post_processing = post_processing

        # Verify that functions are async
        for fn in pre_checking:
            if not inspect.iscoroutinefunction(fn):
                raise TypeError("Guardrail pre-checks must be async functions.")
        
        for fn in post_processing:
            if not inspect.iscoroutinefunction(fn):
                raise TypeError("Guardrail post-processing functions must be async.")

    async def pre_check(self, tool_name: str, *args, **kwargs) -> Optional[str]:
        """
        Takes in arguments and performs a check against every function in self.pre_checking. Returns an error message if any check fails.

        Args:
            Arguments to tool function.
        
        Returns:
            Optional[str]: Error message if any, else None.
        """
        error_messages = []
        for fn in self.pre_checking:
            
            try:
                applies_to = getattr(fn, "_applies_to", set())

                for applicable_fns in applies_to:

                    # Check if the current tool should be checked by fn
                    if tool_name.startswith(applicable_fns):

                        # If so, perform the check and break out of loop
                        fn_check = await fn(*args, **kwargs)
                        if fn_check is not None:
                            error_messages.append(fn_check)
                        
                        break       
                    
            except Exception as e:
                logger.warning(f"Received error {e} during pre-check")
        
        if error_messages:
            return "\n".join(error_messages)

        return None

    async def post_process(self, tool_response: Any) -> Any:
        """
        Takes the response from the tool and passes it through post-processing functions sequentially.

        Args:
            tool_response (str): Output from the tool call.
        
        Returns:
            str: Post-processed result, which may also be an error message.
        """
        for fn in self.post_processing:
            tool_response = await fn(tool_response)

        return tool_response


class GuardedToolkit(Toolkit):
    """
    A Toolkit formed by combining a custom Guardrail with any existing toolkit.  
    Wraps all tools of the original toolkit with pre- and post-checks, as well as timeout handling.
    """
    def __init__(self, base_tool: Toolkit, guardrail: Guardrail = Guardrail(), custom_name_suffix: Optional[str] = None, tool_timeout: int = MAX_TIMEOUT, *args, **kwargs):
        self.base_tool = base_tool
        self.guardrail = guardrail
        self.tool_timeout = tool_timeout

        self.safe_tool_name = f"safe-{base_tool.name}-{guardrail.name}"
        self.safe_tools = [self.wrap_tool_call(tool_func=fn, custom_name_suffix=custom_name_suffix) for fn in base_tool.tools]

        super().__init__(name=self.safe_tool_name, tools=self.safe_tools, *args, **kwargs)
    
    async def arun(self, *args, **kwargs) -> str:
        """
        Default way to run the primary tool inside the original toolkit (assumes it is the first tool).

        Returns:
            str: Response from running the primary tool.
        """
        return await self.tools[0](*args, **kwargs)
                   
    def wrap_tool_call(self, tool_func: Callable, custom_name_suffix: Optional[str] = None) -> Callable:
        """
        Wraps a tool function with pre- and post-processing checks and timeout handling.

        Args:
            tool_func (Callable): The tool function to be wrapped.
        
        Returns:
            Callable: The wrapped function.
        """
        @wraps(tool_func)
        async def safe_func(*args, **kwargs):            
            pre_check = await self.guardrail.pre_check(tool_func.__name__, *args, **kwargs)
            if pre_check is not None:
                return pre_check
            
            try:
                if not inspect.iscoroutinefunction(tool_func):
                    return "This is a synchronous tool. Call the asynchronous version of this tool."
                
                logger.info(f"Tool timeout set to {self.tool_timeout} seconds.")
                
                tool_resp = await asyncio.wait_for(tool_func(*args, **kwargs), self.tool_timeout)
                
                post_processing_resp = await self.guardrail.post_process(tool_response=tool_resp)
                
                return post_processing_resp
            
            except asyncio.TimeoutError:
                error_msg = "Timeout: Tool may be hanging or taking too long."
                logger.warning(error_msg)
                return error_msg
            
            except Exception as e:
                logger.warning(f"Unable to run {self.name}: {e}")
                raise

        if custom_name_suffix is not None:
            safe_func.__name__ = f"{tool_func.__name__}_{custom_name_suffix}"
        return safe_func
