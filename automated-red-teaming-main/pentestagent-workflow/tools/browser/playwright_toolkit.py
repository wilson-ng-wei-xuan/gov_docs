import os, asyncio, re, time
from typing import Optional, Dict, Any, List, Tuple
from playwright.async_api import async_playwright, Playwright, Browser, BrowserContext, Locator
from agno.tools import Toolkit
from agno.utils.log import logger
from urllib.parse import urlparse, urlunparse
from server.sink import _push_chunk_to_sink
from config.context import current_sink, current_session_id, current_node
from agno.run.response import ToolCallStartedEvent, ToolCallCompletedEvent
from agno.models.response import ToolExecution
from tools.slack_bot import send_to_slack

class PlaywrightToolkit(Toolkit):
    """
    Agent-friendly Playwright wrapper for **authentication**.

    Args:
      headless (bool): Launch headless Chromium. Default: True
      slow_mo_ms (int): Slow actions (ms) for stability/observability. Default: 0
      nav_timeout_ms (int): Default locator/wait timeout (ms). Default: 30000
      storage_state_path (str|None): Path to Playwright storage state JSON
      use_proxy (bool): Use proxy server. Default: False
      proxy_url (str): Proxy URL. Default: None
      manual_run (bool): Whether Playwright is run manually or called by agent. If manual_run=False, it is run by agent.
      novnc_url (str): URL to access Chromium browser.

    Exposed tools:
      • `alogin(...) -> None`: Performs autonomous login, falling back to manual login if autonomous login fails. Saves cookies to storage state path.
      • `resume(...) -> None`: Resumes from manual login.
      • `stop(...) -> None`: Stops playwright.
    """

    # Only keep links whose HREF contains these (case-insensitive)
    LOGIN_TOKENS = [
        "login", "log-in", "log_in", "logon",
        "signin", "sign-in", "sign_in", "signon",
    ]
    USER_FIELD_TOKENS = ["user", "email", "login", "account", "username"]
    # Match "login" / "log in" / "log-in" / "signin" / "sign in" / "sign-in" / "submit"
    RE_SUBMIT = re.compile(r"(?:log[\s-]*in|sign[\s-]*in|submit)", re.I)

    def __init__(
        self,
        headless: bool = True,
        slow_mo_ms: int = 0,
        nav_timeout_ms: int = 60000,
        storage_state_path: Optional[str] = None,
        use_proxy: bool = False,
        proxy_url: Optional[str] = None,
        manual_run: bool = False,
        novnc_url: str = None,
        **kwargs
    ):
        """
        Initialize the PlaywrightToolkit and register its tools.

        Configures default launch/interaction settings and prepares internal caches
        for a shared Playwright driver, Browser, and BrowserContext. This method does
        **not** start Playwright or launch a browser; creation happens lazily in
        helper methods such as ``_ensure_context()``.

        Args:
            headless (bool, optional):
                Launch Chromium headless when creating a browser. Default: True.
            slow_mo_ms (int, optional):
                Milliseconds to slow actions for stability/observability. Default: 0.
            nav_timeout_ms (int, optional):
                Default timeout (ms) applied to locator waits and navigations. Default: 30000.
            storage_state_path (Optional[str], optional):
                Path to a Playwright storage state JSON (cookies/localStorage).
                When provided, contexts created later may **load** from this file,
                and teardown logic may **save** back to it to persist session state.
            use_proxy (bool, optional):
                Use proxy server. Default: False.
            proxy_url (Optional[str], optional):
                Proxy URL. Default: None.
            manual_run (bool): Whether Playwright is run manually or called by agent. If manual_run=False, it is run by agent.
            novnc_url (str): URL to access Chromium browser.

            **kwargs:
                Forwarded to the base ``Toolkit`` initializer.

        Returns:
            None
        """
        super().__init__(name="playwright_toolkit", tools=[self.alogin], **kwargs)
        self.headless = headless
        self.slow_mo_ms = slow_mo_ms
        self.nav_timeout_ms = nav_timeout_ms
        self.storage_state_path = storage_state_path
        self.use_proxy = use_proxy
        self.proxy_url = proxy_url
        self.manual_run = manual_run
        self.novnc_url = novnc_url

        self._pause_evt: asyncio.Event = asyncio.Event()
        self._pw: Optional[Playwright] = None
        self._browser: Optional[Browser] = None
        self._context: Optional[BrowserContext] = None

    # ----------- lifecycle -----------

    async def _is_context_alive(self) -> bool:
        """
        Check whether the cached Playwright `BrowserContext` is still usable.

        This probes liveness by invoking `context.cookies()`—a lightweight call
        that raises exceptions if the context (or its parent browser/Playwright instance) has
        been closed or crashed. Any exception is treated as "not alive".

        Returns:
            bool: `True` if a context exists and the liveness probe succeeds,
                  otherwise `False`.
        """
        if not self._context:
            return False
        try:
            # no-op that throws if closed
            await self._context.cookies()
            return True
        except Exception:
            return False

    async def _start_playwright(self):
        """
        Ensure a single Playwright driver is running.

        Starts and caches a shared Playwright instance (via
        `async_playwright().start()`) on `self._pw` for the lifetime of
        this toolkit. Safe and idempotent: if an instance is already started,
        this method is a no-op.

        Call this before creating any `Browser` or `BrowserContext`.
        Pair with `_stop_playwright()` to cleanly release resources.

        Returns:
            None

        Raises:
            Exception: Propagates any errors raised while starting Playwright.
        """
        if self._pw is None:
            # start ONCE for the lifetime of the toolkit
            self._pw = await async_playwright().start()

    async def _stop_playwright(self):
        """
        Best-effort teardown of the Playwright runtime.

        Performs a graceful shutdown in this order:
          1) If a cached `BrowserContext` exists, persist its
             `storage_state` to `self.storage_state_path` (if set),
             then close the context (closing all open pages).
          2) If a cached `Browser` exists, close it.
          3) If a cached Playwright driver (`self._pw`) exists, stop it.

        All shutdown steps are wrapped in try/except and failures are ignored
        (best-effort cleanup). Internal references (`_context`, `_browser`,
        `_pw`) are nulled so subsequent operations must call
        `_start_playwright()` / `_ensure_context()` again.

        Notes:
            - Persisting `storage_state` captures cookies/localStorage for
              later reuse and will overwrite any existing file at the path.
            - Calling this method closes any open tabs and invalidates the
              current session for this toolkit instance.

        Returns:
            None
        """
        try:
            if self._context:
                # save storage_state
                if self.storage_state_path:
                    await self._context.storage_state(path=self.storage_state_path)
                await self._context.close()
        except Exception:
            pass
        self._context = None

        try:
            if self._browser:
                await self._browser.close()
        except Exception:
            pass
        self._browser = None

        if self._pw:
            await self._pw.stop()
            self._pw = None

    async def _ensure_context(self) -> BrowserContext:
        """
        Get a usable Playwright `BrowserContext`, creating one if needed.

        Behavior:
            - Ensures the Playwright driver is started (calls `_start_playwright()`).
            - If a cached context exists and is alive (`_is_context_alive()`), returns it.
            - Otherwise launches a fresh Chromium `Browser` and creates a **non-persistent**
              context. If `self.storage_state_path` exists, it is passed as
              `storage_state` to restore cookies/localStorage for this context.
            - Sets the context default timeout to `self.nav_timeout_ms` and caches it on
              `self._context` (and the browser on `self._browser`).

        Side effects:
            - May overwrite `self._browser` and `self._context` with new instances.
            - Does **not** save state; persistence is handled elsewhere (e.g. `_stop_playwright`).

        Returns:
            BrowserContext: A live, ready-to-use context.

        Raises:
            Exception: Propagates errors from launching the browser or creating the context.
        """
        await self._start_playwright()

        # Reuse only if alive
        if await self._is_context_alive():
            return self._context

        # Fresh create
        launch_kwargs = dict(headless=self.headless, slow_mo=self.slow_mo_ms,
                             args=["--disable-dev-shm-usage", "--no-sandbox", "--start-maximized"])
        if self.use_proxy and self.proxy_url:
            launch_kwargs["proxy"] = {"server": self.proxy_url}

        self._browser = await self._pw.chromium.launch(**launch_kwargs)

        ctx_kwargs: Dict[str, Any] = {"ignore_https_errors": True, "viewport": None}
        if self.storage_state_path and os.path.exists(self.storage_state_path):
            ctx_kwargs["storage_state"] = self.storage_state_path

        self._context = await self._browser.new_context(**ctx_kwargs)
        self._context.set_default_timeout(self.nav_timeout_ms)
        return self._context

    # ----------- helper -----------

    async def _manual_pause(self, timeout: float | None = None):
        # clear and wait until someone calls resume()
        self._pause_evt.clear()
        if timeout:
            await asyncio.wait_for(self._pause_evt.wait(), timeout=timeout)
        else:
            await self._pause_evt.wait()

    def _normalize(self, u: str) -> str:
        """Lowercase scheme/host, strip default ports/fragments; keep path+query."""
        p = urlparse(u)
        netloc = p.netloc.lower()
        if p.scheme == "http" and netloc.endswith(":80"):
            netloc = netloc[:-3]
        if p.scheme == "https" and netloc.endswith(":443"):
            netloc = netloc[:-4]
        return urlunparse((p.scheme.lower(), netloc, p.path, "", p.query, ""))

    def _same_org(self, base_host: str, other_host: str) -> bool:
        """
        Treat subdomains as same org: foo.example.com ~ bar.example.com.
        Heuristic: strip leading 'www.' and compare suffix.
        """
        b = base_host.lower().lstrip("www.")
        o = other_host.lower()
        return o == b or o.endswith("." + b)

    async def _find_login_links(
            self,
            url: str,
    ) -> List[str]:
        """
        Load the page with Playwright and return absolute URLs for <a href> that
        clearly look like login links (by href token match).

        Returns a de-duplicated list (order preserved by DOM order).
        """
        ctx = await self._ensure_context()
        page = await ctx.new_page()
        await page.goto(url, wait_until="domcontentloaded", timeout=self.nav_timeout_ms)
        hrefs: List[str] = await page.eval_on_selector_all(
            "a[href]",
            """els => els.map(a => {
                try { return a.href || a.getAttribute('href') || null; }
                catch { return null; }
            }).filter(Boolean)"""
        )

        await page.close()

        base_host = urlparse(url).netloc.lower()
        seen = set()
        results: List[str] = []

        for href in hrefs:
            p = urlparse(href)
            if p.scheme not in {"http", "https"}:
                continue
            # treat subdomains as same org.
            if not self._same_org(base_host, p.netloc):
                continue
            low = href.lower()
            if any(tok in low for tok in self.LOGIN_TOKENS):
                norm = self._normalize(href)
                if norm not in seen:
                    seen.add(norm)
                    results.append(href)

        return results

    async def _first_visible(self, loc: Locator) -> Optional[Locator]:
        """Return the first element in `loc` that is both visible and enabled; None if none.
            Silently skips elements that throw (e.g., detached during checks)."""
        n = await loc.count()
        for i in range(n):
            el = loc.nth(i)
            try:
                if await el.is_visible() and await el.is_enabled():
                    return el
            except Exception:
                continue
        return None

    async def _find_fields_in_form(self, form: Locator) -> Tuple[Optional[Locator], Optional[Locator]]:
        """Return (username_input, password_input) if both are visible inside this form."""
        pwd = await self._first_visible(form.locator('input[type="password"]'))
        if not pwd:
            return None, None

        # likely username/email field inside the same form
        user = await self._first_visible(form.locator(
            'input[autocomplete="username" i], '
            'input[type="email"], '
            'input[type="text"], '
            + ", ".join(
                f'input[name*="{t}" i], input[id*="{t}" i], input[aria-label*="{t}" i], input[placeholder*="{t}" i]'
                for t in self.USER_FIELD_TOKENS
            )
        ))

        return user, pwd

    async def _submit_form(self, form: Optional[Locator], pwd: Locator, timeout_ms: int) -> bool:
        """Click a submit control inside `form` by text variants (login/sign in/submit),
        fallback to type=submit, else press Enter in the password field."""
        if form and await form.count():
            # 1) Buttons/links whose accessible name matches our variants
            for loc in (
                    form.get_by_role("button", name=self.RE_SUBMIT),
                    form.get_by_role("link", name=self.RE_SUBMIT),
            ):
                n = await loc.count()
                for i in range(n):
                    el = loc.nth(i)
                    try:
                        if await el.is_visible() and await el.is_enabled():
                            await el.click(timeout=timeout_ms)
                            return True
                    except Exception:
                        continue

            # 2) Classic submit controls
            submit = form.locator('button[type="submit"], input[type="submit"]')
            n = await submit.count()
            for i in range(n):
                el = submit.nth(i)
                try:
                    if await el.is_visible() and await el.is_enabled():
                        await el.click(timeout=timeout_ms)
                        return True
                except Exception:
                    continue

        # 3) Final fallback
        try:
            await pwd.press("Enter")
            return True
        except Exception:
            return False

    async def _check_login_status(self, verify_url: str, verify_str) -> bool:
        ctx = await self._ensure_context()
        new_page = await ctx.new_page()
        await new_page.goto(verify_url, wait_until="domcontentloaded", timeout=self.nav_timeout_ms)
        content = await new_page.content()
        await new_page.close()
        if verify_str in content:
            logger.info("Login verified!")
            return True

        return False

    async def _manual_push_to_sink(self, event_type: str, tool_name: str, tool_args: dict[str, str], result: Optional[str] = None) -> None:
        sink = current_sink.get()
        if event_type == "tool_start":
            chunk = ToolCallStartedEvent(
                tool=ToolExecution(
                    tool_name=tool_name,
                    tool_args=tool_args,
                )
            )
        elif event_type == "tool_end":
            chunk = ToolCallCompletedEvent(
                tool=ToolExecution(
                    tool_name=tool_name,
                    tool_args=tool_args,
                    result= result,
                )
            )
        try:
            metadata = {
                    'session_id': current_session_id.get(),
                    'node_id': 'global-state',
                    "novnc_url": self.novnc_url
                }
            await _push_chunk_to_sink(chunk=chunk, sink=sink, metadata=metadata)
        except Exception as e:
            logger.error(f"Error pushing chunk to sink: {e}")
            raise

    # ----------- main operations -----------

    async def stop(self):
        await self._stop_playwright()

    def resume(self):
        # call this when the user clicks “Resume”
        self._pause_evt.set()

    async def alogin(self, url: str, verify_url: str, verify_str: str, username: str, password: str) -> str:
        """
        Open `url` on `Playwright Chromium browser.

        Args:
            url (str): URL to open.
            verify_url (str): URL to verify that we logged in successfully. Retrieve this from global state.
            verify_str (str): String to verify that we logged in successfully. Retrieve this from global state.
            username (str): Username to login with. Retrieve this from global state.
            password (str): Password to login with. Retrieve this from global state.
        """
        if self.manual_run:
            await self._manual_push_to_sink("tool_start", "Playwright.alogin_autonomous",
                                      {"url": url, "verify_url": verify_url, "verify_str": verify_str, "username": username})

        ctx = await self._ensure_context()
        page = await ctx.new_page()

        # Pre-check to see if we are already logged in or not:
        logged_in = await self._check_login_status(verify_url, verify_str)

        if logged_in:
            return ("We are already logged in. You might have access a pre-auth endpoint. "
                    "Please set use_cookies to False when using WebRequesterTool to access this URL and try again.")

        # 1. Autonomous approach
        all_login_links = await self._find_login_links(url)
        logger.info(f"Found {len(all_login_links)} login links. Login links: {all_login_links}")

        if len(all_login_links) > 0:
            for login_link in all_login_links:
                await page.goto(login_link, wait_until="domcontentloaded", timeout=self.nav_timeout_ms)

                # search only main frame + same-origin iframes (kept simple)
                page_origin = urlparse(page.url).netloc.lower()
                frames = [page.main_frame] + [f for f in page.frames if
                                              urlparse(f.url or "").netloc.lower() == page_origin]

                for f in frames:
                    forms = f.locator("form")
                    count = await forms.count()
                    for i in range(count):
                        form = forms.nth(i)
                        user, pwd = await self._find_fields_in_form(form)
                        if not (user and pwd):
                            continue

                        await user.click(timeout=self.nav_timeout_ms)
                        await user.fill(username, timeout=self.nav_timeout_ms)
                        await pwd.click(timeout=self.nav_timeout_ms)
                        await pwd.fill(password, timeout=self.nav_timeout_ms)

                        submit_action = await self._submit_form(form, pwd, self.nav_timeout_ms)
                        if submit_action:
                            logger.info("Submitted!")
                            logged_in = await self._check_login_status(verify_url, verify_str)
                            if logged_in:
                                # Save browser cookies
                                if self.storage_state_path:
                                    await ctx.storage_state(path=self.storage_state_path)

                                if self.manual_run:
                                    await self._manual_push_to_sink("tool_end", "Playwright.alogin_autonomous",
                                                                    {"url": url, "verify_url": verify_url,
                                                                     "verify_str": verify_str, "username": username})
                                return "Successfully logged in!"

        # If we reach this code block, it means autonomous login failed
        logger.info("Failed to login autonomously. Will fall back to manual approach")

        # send notif to Slack Channel

        if 'localhost' not in self.novnc_url and '127.0.0.1' not in self.novnc_url:
           await send_to_slack(f"Please login manually at {self.novnc_url}.")

        if self.manual_run:
            logger.info(f"Awaiting user to login manually at {self.novnc_url}...")
            await self._manual_push_to_sink("tool_start", "Playwright.alogin_manual",
                                            {"url": url, "verify_url": verify_url, "verify_str": verify_str,
                                             "username": username})

        # 2. Fallback: Manual Approach
        await page.goto(url, wait_until="domcontentloaded", timeout=self.nav_timeout_ms)
        await self._manual_pause(timeout=600.0)

        # Save browser cookies
        if self.storage_state_path:
            await ctx.storage_state(path=self.storage_state_path)

        if self.manual_run:
            await self._manual_push_to_sink("tool_end", "Playwright.alogin_manual",
                                            {"url": url, "verify_url": verify_url, "verify_str": verify_str,
                                             "username": username})

        return "Successfully logged in!"

async def run_authentication(pw: PlaywrightToolkit, url: str, verify_url: str, verify_str: str, username: str, password: str) -> Any:
    logger.info("in run_authentication")
    await pw.alogin(url, verify_url=verify_url, verify_str=verify_str, username=username, password=password)

    return url
