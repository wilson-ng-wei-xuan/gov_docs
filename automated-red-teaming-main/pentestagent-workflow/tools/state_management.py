from __future__ import annotations

import json
from copy import deepcopy
from abc import ABC, abstractmethod
from typing import Dict, TYPE_CHECKING
from config.globals import USE_DB, DYNAMO_DB
from db.dynamo import DynamoDB
import logging

if TYPE_CHECKING:
    from schema.state import PentestTree

logger = logging.getLogger(__name__)


class SessionHandler(ABC):
    def __init__(self):
        self.sessions: Dict[str, "PentestTree"] = {}

    @abstractmethod
    def create_session(self, session_id: str, goal: str, target: str):
        pass

    @abstractmethod
    def get_session(self, session_id: str) -> "PentestTree":
        pass

    @abstractmethod
    def update_session(self, session_id: str, pentest_tree: "PentestTree"):
        pass

    @abstractmethod
    def delete_session(self, session_id: str):
        pass

    @abstractmethod
    def _save_session(self, session_id: str):
        pass


class LocalGlobalStateHandler(SessionHandler):
    def create_session(self, session_id: str, goal: str, target: str):
        if session_id in self.sessions:
            raise ValueError(f"Session with ID {session_id} already exists.")

        from schema.state import PentestTree

        pentest_tree = PentestTree(
            goal=goal,
            target=target,
            session_id=session_id,
        )
        self.sessions[session_id] = pentest_tree

    def get_session(self, session_id: str) -> "PentestTree":
        if session_id not in self.sessions:
            raise ValueError(f"Session with ID {session_id} does not exist.")
        return self.sessions[session_id]

    def update_session(self, session_id: str, pentest_tree: "PentestTree"):
        pass

    #     if session_id not in self.sessions:
    #         raise ValueError(f"Session with ID {session_id} does not exist.")
    #     self.sessions[session_id] = pentest_tree
    #     self.save_session(session_id)

    def _save_session(self, session_id: str):
        pass

    #     # For local handler, this does nothing
    #     pass

    def delete_session(self, session_id: str):
        if session_id in self.sessions:
            del self.sessions[session_id]

    async def acreate_session(self, session_id: str, goal: str, target: str):
        if session_id in self.sessions:
            raise ValueError(f"Session with ID {session_id} already exists.")

        from schema.state import PentestTree

        pentest_tree = PentestTree(
            goal=goal,
            target=target,
            session_id=session_id,
        )
        self.sessions[session_id] = pentest_tree

    async def aget_session(self, session_id: str) -> "PentestTree":
        if session_id not in self.sessions:
            raise ValueError(f"Session with ID {session_id} does not exist.")
        return self.sessions[session_id]

    async def aupdate_session(self, session_id: str, pentest_tree: "PentestTree"):
        pass

    #     if session_id not in self.sessions:
    #         raise ValueError(f"Session with ID {session_id} does not exist.")
    #     self.sessions[session_id] = pentest_tree
    #     self.save_session(session_id)

    async def _asave_session(self, session_id: str):
        pass

    #     # For local handler, this does nothing
    #     pass

    async def adelete_session(self, session_id: str):
        if session_id in self.sessions:
            del self.sessions[session_id]


class DBGlobalStateHandler(SessionHandler):
    def __init__(self):
        if USE_DB is False:
            raise ValueError("DBGlobalStateHandler requires USE_DB to be True.")
        super().__init__()
        self.db: DynamoDB | None = DYNAMO_DB

    def create_session(self, session_id: str, goal: str, target: str):
        if session_id in self.sessions:
            raise ValueError(f"Session with ID {session_id} already exists.")

        from schema.state import PentestTree

        pentest_tree = PentestTree(
            goal=goal,
            target=target,
            session_id=session_id,
        )

        item = pentest_tree.model_dump()
        item.update({"node_id": "global-state", "history":[]})
        self.db.create_item(item=item)
        self.sessions[session_id] = pentest_tree
        logger.info(f"Successfully created session {session_id} in DB.")

    def get_session(self, session_id: str) -> "PentestTree":
        if session_id not in self.sessions:
            try:
                session = self.load_session_from_db(session_id)
            except Exception as e:
                raise ValueError(
                    f"Failed to retrieve {session_id} from local memory or database. It may not exist. Error: {e}"
                )
        return self.sessions[session_id]

    def load_session_from_db(self, session_id: str) -> "PentestTree":
        try:
            from schema.state import PentestTree

            data = self.db.get_item(pk=session_id, sk="global-state")
            pentest_tree = PentestTree.from_json_data(data)
            logger.debug(f"Loaded {data}; rehydrated as {pentest_tree}")
            self.sessions[session_id] = pentest_tree
        except Exception as e:
            raise ValueError(f"Error retrieving session with ID {session_id}: {e}")

        logger.info(f"Successfully retrieved session {session_id} from DB.")
        return self.sessions[session_id]

    def update_session(self, session_id: str, pentest_tree: "PentestTree"):
        logger.debug(
            f"Updating state with {json.dumps(pentest_tree.model_dump(), indent=2)}"
        )
        self.sessions[session_id] = pentest_tree
        self._save_session(session_id)
        logger.info(f"Successfully updated session {session_id} in DB.")

    def _save_session(self, session_id: str):
        if session_id not in self.sessions:
            raise ValueError(f"Session with ID {session_id} does not exist.")
        pentest_tree = self.sessions[session_id]
        item = pentest_tree.model_dump()

        if "session_id" in item:
            del item["session_id"]

        self.db.update_item(pk=session_id, sk="global-state", updates=item)

    def delete_session(self, session_id: str):
        if session_id in self.sessions:
            del self.sessions[session_id]
        self.db.delete_item(pk=session_id, sk="global-state")

    async def acreate_session(self, session_id: str, goal: str, target: str):
        if session_id in self.sessions:
            raise ValueError(f"Session with ID {session_id} already exists.")

        from schema.state import PentestTree

        pentest_tree = PentestTree(
            goal=goal,
            target=target,
            session_id=session_id,
        )

        item = pentest_tree.model_dump()
        item.update({"node_id": "global-state"})
        await self.db.acreate_item(item=item)
        self.sessions[session_id] = pentest_tree
        logger.info(f"Successfully created session {session_id} in DB.")

    async def aget_session(self, session_id: str) -> "PentestTree":
        if session_id not in self.sessions:
            try:
                session = await self.aload_session_from_db(session_id)
            except Exception as e:
                raise ValueError(
                    f"Failed to retrieve {session_id} from local memory or database. It may not exist. Error: {e}"
                )
        return self.sessions[session_id]

    async def aload_session_from_db(self, session_id: str) -> "PentestTree":
        try:
            from schema.state import PentestTree

            data = await self.db.aget_item(pk=session_id, sk="global-state")
            pentest_tree = PentestTree.from_json_data(data)
            logger.debug(f"Loaded {data}; rehydrated as {pentest_tree}")
            self.sessions[session_id] = pentest_tree
        except Exception as e:
            raise ValueError(f"Error retrieving session with ID {session_id}: {e}")

        logger.info(f"Successfully retrieved session {session_id} from DB.")
        return self.sessions[session_id]

    async def aupdate_session(self, session_id: str, pentest_tree: "PentestTree"):
        logger.debug(
            f"Updating state with {json.dumps(pentest_tree.model_dump(), indent=2)}"
        )
        self.sessions[session_id] = pentest_tree
        await self._asave_session(session_id)
        logger.info(f"Successfully updated session {session_id} in DB.")

    async def _asave_session(self, session_id: str):
        if session_id not in self.sessions:
            raise ValueError(f"Session with ID {session_id} does not exist.")
        pentest_tree = self.sessions[session_id]
        item = pentest_tree.model_dump()

        if "session_id" in item:
            del item["session_id"]

        await self.db.aupdate_item(pk=session_id, sk="global-state", updates=item)

    async def adelete_session(self, session_id: str):
        if session_id in self.sessions:
            del self.sessions[session_id]
        await self.db.adelete_item(session_id)


GLOBAL_STATE_HANDLER = (
    LocalGlobalStateHandler() if not USE_DB else DBGlobalStateHandler()
)
