import asyncio
from copy import deepcopy
import time
import uuid
from agno.tools import Toolkit
from agno.utils.log import logger
from agno.agent import Agent
from tools.tool_retrieval.vector_db import vector_db
from typing import Any, Callable, Dict, List, Optional, Union
from custom_agents.summarizer import SUMMARY_MODEL, ToolSummarizer, SUMMARIZER_TYPE, get_encoding_for_model, get_session_summarizer, normalize_message_content
from tools.guardrails.common import PAYLOAD_TYPE
from agno.models.message import Message
# from tools.tool_retrieval.sample_outputs.fire_ext_exploit_output import fire_ext_output
import os

MAX_TOKENS = int(os.getenv("MAX_TOKENS", 50000))
MAX_CHUNK_SIZE = int(os.getenv("MAX_CHUNK_SIZE", 4000))


def get_num_tokens(text: str, model: str) -> int:
    """
    Estimate the number of tokens in a given text for a specified model.

    Args:
        text (str): The input text string to tokenize.
        model (str): The model identifier for which the encoding should be used.

    Returns:
        int: The estimated number of tokens in the text.
    """
    enc = get_encoding_for_model(model)
    return len(enc.encode(normalize_message_content(text)))


def get_summarizer_type(function_name: str, agent: Agent) -> SUMMARIZER_TYPE:
    """
    Retrieve the summarizer type associated with a registered tool function.

    Args:
        function_name (str): The name of the function/tool.
        agent (Agent): The agent containing registered tools.

    Returns:
        SUMMARIZER_TYPE: The summarizer type for the tool. Defaults to STANDARD if not found.
    """
    def recursive_find(name: str, tool: Union[Callable, Toolkit]) -> Optional[SUMMARIZER_TYPE]:
        if isinstance(tool, Callable):
            return tool.__summarizer_type__ if tool.__name__ == name and hasattr(tool, "__summarizer_type__") else None
        elif isinstance(tool, Toolkit):
            for sub_tool in tool.tools:
                temp = recursive_find(name=name, tool=sub_tool)
                if temp is not None:
                    return temp
            return None
        else:
            raise ValueError("Unhandled case")

    for tool in agent.tools:
        res = recursive_find(name=function_name, tool=tool)
        if res is not None:
            return res

    return SUMMARIZER_TYPE.STANDARD


def get_payload_type(function_name: str, agent: Agent) -> PAYLOAD_TYPE:
    """
    Retrieve the payload type associated with a registered tool function.

    Args:
        function_name (str): The name of the function/tool.
        agent (Agent): The agent containing registered tools.

    Returns:
        PAYLOAD_TYPE: The payload type for the tool. Defaults to TEXT if not found.
    """
    def recursive_find(name: str, tool: Union[Callable, Toolkit]) -> Optional[PAYLOAD_TYPE]:
        if isinstance(tool, Callable):
            return tool.__payload_type__ if tool.__name__ == name and hasattr(tool, "__payload_type__") else None
        elif isinstance(tool, Toolkit):
            for sub_tool in tool.tools:
                temp = recursive_find(name=name, tool=sub_tool)
                if temp is not None:
                    return temp
            return None
        else:
            raise ValueError("Unhandled case")

    for tool in agent.tools:
        res = recursive_find(name=function_name, tool=tool)
        if res is not None:
            return res

    return PAYLOAD_TYPE.TEXT


async def output_storage_hook(function_name: str, function_call: Callable, arguments: Dict[str, Any], agent: Agent, *args, **kwargs) -> Dict[str, Any]:
    """
    Hook for executing a tool function, summarizing its output, and storing results.

    Args:
        function_name (str): The name of the tool function.
        function_call (Callable): The callable tool function.
        arguments (Dict[str, Any]): Arguments to pass to the tool function.
        agent (Agent): The agent executing the tool.

    Returns:
        Dict[str, Any]: A dictionary containing the output ID, summarized content,
        and a flag indicating whether summarization occurred.
    """
    try:
        start = time.time()
        if asyncio.iscoroutinefunction(function_call):
            result = await function_call(**arguments)
        else:
            result = function_call(**arguments)
        end = time.time()


        session = agent.run_messages.messages if agent else []
        summarizer_type = get_summarizer_type(function_name=function_name, agent=agent)
        payload_type = get_payload_type(function_name=function_name, agent=agent)

        output_id = str(uuid.uuid4())
        summarized_result = await tool_output_storage(
            summarizer_type=summarizer_type,
            session=session,
            payload_type=payload_type,
            raw_output=result,
            output_id=output_id,
        )

        return {
            "output_id": output_id,
            "content": summarized_result,
            "is_summarized": len(summarized_result) < len(result),
            "execution_time": f"{end - start:.4f} seconds",
            "num_raw_output_characters": len(result),
        }

    except:
        raise


async def tool_output_storage(
    summarizer_type: SUMMARIZER_TYPE = SUMMARIZER_TYPE.MAP_REDUCE,
    session: List[Message] = [],
    payload_type: PAYLOAD_TYPE = PAYLOAD_TYPE.TEXT,
    raw_output: str = "",
    output_id: str = "",
) -> str:
    """
    Process and store the output of a tool function, including optional summarization.

    This function handles:
        1. Token counting of raw output.
        2. Chunking of output if too large.
        3. Summarization of raw output.
        4. Storage of chunks in the vector database.

    Args:
        summarizer_type (SUMMARIZER_TYPE, optional): Summarizer strategy to use. Defaults to MAP_REDUCE.
        session (List[Message], optional): Conversation session messages for context. Defaults to [].
        payload_type (PAYLOAD_TYPE, optional): The type of payload (e.g., TEXT, WEB_PAGE). Defaults to TEXT.
        raw_output (str, optional): The raw output string from the tool. Defaults to "".
        output_id (str, optional): Unique identifier for the tool output. Defaults to "".

    Returns:
        str: Summarized version of the tool output.
    """
    num_tokens = get_num_tokens(raw_output, SUMMARY_MODEL.id)
    chunking_function = payload_type.get_chunking_function()

    if num_tokens > MAX_TOKENS:
        logger.info("Start by summarizing the session to provide context")

        session_summarizer = get_session_summarizer(summarizer=SUMMARIZER_TYPE.STANDARD)
        session_summary = await session_summarizer.arun(conversation=deepcopy(session))
        session_summary = session_summary.summary

        logger.info(f"Summarizing tool output with id {output_id} - ({summarizer_type, payload_type})")

        chunks = chunking_function(raw_output=raw_output)
        summarizer = ToolSummarizer(summarizer_type=summarizer_type, payload_type=payload_type)
        res_msg = str(await summarizer.arun(raw_output=raw_output, session_summary=session_summary))

        chunks.append(res_msg)
    else:
        chunks = [raw_output]
        res_msg = raw_output

    for i in range(len(chunks)):
        vector_db.upsert_chunk(output_id=output_id, chunk_id=str(i), content=chunks[i])

    return res_msg


class ToolRetrieval(Toolkit):
    """
    Toolkit for retrieving stored tool output chunks from the vector database.
    """

    def __init__(self, name: str = "tool_retrieval", vector_store=None, *args, **kwargs):
        """
        Initialize the ToolRetrieval toolkit.

        Args:
            name (str, optional): The name of the toolkit. Defaults to "tool_retrieval".
            vector_store (optional): Custom vector store instance. Defaults to shared vector_db.
        """
        self.vector_db = vector_store or vector_db
        super().__init__(name=name, tools=[self.get_chunk_data, self.get_num_chunks, self.search_chunks], *args, **kwargs)

    async def get_num_chunks(self, output_id: str) -> str:
        """
        Get the total number of chunks belonging to the output with id output_id

        Args:
            output_id (str): The ID of the tool call whose chunks to retrieve.

        Returns:
            str: The total number of chunks as a string. Returns "0" if no chunks exist.
        """
        chunks = self.vector_db.get_chunks(output_id)
        return str(len(chunks))

    async def search_chunks(self, output_id: str, keyword: str) -> str:
        """
        Search which chunks contain instances of the keyword in the raw output. Returns a list of valid chunks

        Args:
            output_id (str): The ID of the tool call whose chunks to search.
            keyword (str): The keyword to search for (case-insensitive).

        Returns:
            str: Returns the chunk_ids that contain the relevant
        """
        
        chunks = self.vector_db.get_chunks(output_id)
        if not chunks:
            return ""

        matching_chunks = []
        for chunk_id, data in chunks.items():
            content = str(data.get("content", ""))
            if keyword.lower() in content.lower():
                matching_chunks.append(chunk_id)
        return str(matching_chunks)

    async def get_chunk_data(self, output_id: str, chunk_id: int) -> str:
        """
        Retrieve the content of a specific chunk.

        Args:
            output_id (str): The ID of the tool call.
            chunk_id (int): The ID of the chunk to retrieve.

        Returns:
            str: The content of the chunk. Returns an empty string if not found.
        """
        chunks = self.vector_db.get_chunks(output_id)
        if not chunks:
            return ""

        data = chunks.get(str(chunk_id))
        if not data:
            return ""

        return str(data.get("content", ""))


# if __name__ == '__main__':
#     import asyncio
#     raw_output = fire_ext_output
#     print("Running experiment on summarizer type")
#
#     results = []
#     for summarizer in [SUMMARIZER_TYPE.MAP_REDUCE, SUMMARIZER_TYPE.ROLLING]:
#         id = str(uuid.uuid4())
#         res = asyncio.run(tool_output_storage(summarizer_type=summarizer, payload_type=PAYLOAD_TYPE.WEB_PAGE, raw_output=raw_output, output_id=id))
#         results.append((summarizer, res))
#
#     with open("tools/tool_retrieval/experiments/fire_ext_summarization.txt", "w") as f:
#         for summarizer, res in results:
#             f.write(f"Mode: {summarizer}\n\n")
#             f.write(res)
#             f.write("=" * 10 + "[DONE]" + "=" * 10 + "\n")