import asyncio
import unittest
from unittest.mock import patch, MagicMock, AsyncMock
from collections import deque
from main import (
    run_task, route_indiv_exploit_tasks, run_pentest_workflow, initialize_new_session,
    Task, TaskStatus, VulnType, WorkflowStage
)
from schema.recon import ReconOutput, ReconEndpointOutput

class TestPentestWorkflow(unittest.TestCase):

    def setUp(self):
        self.session_id = "test-session"
        self.task = Task(name="run_katana", status=TaskStatus.PENDING, stage=WorkflowStage.RECON)

    @patch("main.update_task_in_global_state")
    @patch("main.run_katana")
    def test_run_task_sync_success(self, mock_katana, mock_update):
        # run_katana is sync function mocked to return "success"
        mock_katana.return_value = "success"
        asyncio.run(run_task(self.task, self.session_id))
        self.assertEqual(self.task.status, TaskStatus.COMPLETED)
        self.assertEqual(self.task.result, "success")
        self.assertTrue(mock_update.called)

    @patch("main.update_task_in_global_state")
    @patch("main.run_katana")
    def test_run_task_async_success(self, mock_katana, mock_update):
        # run_katana async mocked function
        mock_katana.return_value = "async success"
        asyncio.run(run_task(self.task, self.session_id))
        self.assertEqual(self.task.status, TaskStatus.COMPLETED)
        self.assertEqual(self.task.result, "async success")
        self.assertTrue(mock_update.called)

    def test_route_indiv_exploit_tasks_valid(self):
        output = ReconOutput(assessments=[ReconEndpointOutput(url="http://example.com",
                                                              vulnerabilities={}, tags=[VulnType.SQL], )])
        task = Task(
            name="run_recon_agent",
            status=TaskStatus.COMPLETED,
            stage=WorkflowStage.RECON,
            result=output
        )
        next_tasks = route_indiv_exploit_tasks(task)
        print(next_tasks)
        self.assertEqual(len(next_tasks), 1)
        self.assertEqual(next_tasks[0].name, "run_sql_agent")
        self.assertEqual(next_tasks[0].args, ["http://example.com"])

    def test_route_indiv_exploit_tasks_invalid_result(self):
        task = Task(name="run_recon_agent", status=TaskStatus.COMPLETED, stage=WorkflowStage.RECON, result="not a dict")
        with self.assertRaises(ValueError):
            route_indiv_exploit_tasks(task)

    @patch("main.add_task_in_global_state")
    @patch("main.run_task", new_callable=AsyncMock)
    async def test_run_pentest_workflow_happy_path(self, mock_run_task, mock_add):
        tasks_queue = deque()
        task = Task(name="run_katana", status=TaskStatus.PENDING)
        tasks_queue.append(task)

        # Make run_task succeed and set status COMPLETED
        async def fake_run_task(task):
            task.status = TaskStatus.COMPLETED
            task.result = "res"
        mock_run_task.side_effect = fake_run_task

        await run_pentest_workflow(self.session_id, tasks_queue)

        # We expect the initial task to be run, and new tasks added to the queue from TASK_ROUTER
        mock_run_task.assert_called()
        mock_add.assert_called()

    @patch("main.create_session")
    @patch("main.save_current_global_state")
    @patch("main.Prompt.ask")
    def test_initialize_new_session_success(self, mock_prompt, mock_save, mock_create):
        mock_create.return_value = None  # create_session doesn't return anything
        mock_prompt.side_effect = ["http://target.com", "Test goal"]

        tasks_queue = deque()
        session_id = initialize_new_session(tasks_queue)

        self.assertTrue(session_id)
        self.assertEqual(len(tasks_queue), 1)
        self.assertEqual(tasks_queue[0].name, "run_katana")
        mock_save.assert_called()

    @patch("main.create_session")
    @patch("main.Prompt.ask")
    def test_initialize_new_session_exit(self, mock_prompt, mock_create):
        mock_create.return_value = None
        mock_prompt.side_effect = ["exit"]

        tasks_queue = deque()
        session_id = initialize_new_session(tasks_queue)
        self.assertEqual(session_id, "")

    @patch("main.create_session", side_effect=Exception("DB error"))
    def test_initialize_new_session_create_session_fail(self, mock_create):
        tasks_queue = deque()
        session_id = initialize_new_session(tasks_queue)
        self.assertEqual(session_id, "")

if __name__ == "__main__":
    unittest.main()
