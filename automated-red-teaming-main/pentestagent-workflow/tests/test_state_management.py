import unittest
from unittest.mock import patch, MagicMock, mock_open
import json
from tools.state_management import (
    init_db,
    create_session,
    get_session_history,
    save_session_history,
    get_current_global_state,
    save_current_global_state,
    add_task_in_global_state,
    update_task_in_global_state,
)
from schema.state import GlobalState
from schema.task import Task, TaskStatus, WorkflowStage

class TestStateManagement(unittest.TestCase):

    @patch("tools.state_management.sqlite3.connect")
    def test_init_db_calls_create_table(self, mock_connect):
        mock_conn = MagicMock()
        mock_connect.return_value.__enter__.return_value = mock_conn

        init_db()

        mock_conn.execute.assert_called()
        called_sql = mock_conn.execute.call_args[0][0]
        self.assertIn("CREATE TABLE IF NOT EXISTS sessions", called_sql)

    @patch("tools.state_management.sqlite3.connect")
    def test_create_session_inserts(self, mock_connect):
        mock_conn = MagicMock()
        mock_connect.return_value.__enter__.return_value = mock_conn

        create_session("sess1")

        mock_conn.execute.assert_called()
        args = mock_conn.execute.call_args[0]
        self.assertIn("INSERT INTO sessions", args[0])
        self.assertEqual(args[1][0], "sess1")

    @patch("tools.state_management.sqlite3.connect")
    def test_get_session_history_returns_history(self, mock_connect):
        mock_conn = MagicMock()
        mock_cursor = MagicMock()
        mock_cursor.fetchone.return_value = ('{"session_id":"sess1"}',)
        mock_conn.execute.return_value = mock_cursor
        mock_connect.return_value.__enter__.return_value = mock_conn

        history = get_session_history("sess1")
        self.assertEqual(history, '{"session_id":"sess1"}')

    @patch("tools.state_management.open", new_callable=mock_open)
    @patch("tools.state_management.sqlite3.connect")
    def test_save_session_history_updates_and_writes_file(self, mock_connect, mock_file):
        mock_conn = MagicMock()
        mock_connect.return_value.__enter__.return_value = mock_conn

        save_session_history("sess1", '{"data":"val"}')

        mock_conn.execute.assert_called()
        args = mock_conn.execute.call_args[0]
        self.assertIn("UPDATE sessions", args[0])
        self.assertEqual(args[1][2], "sess1")

        mock_file.assert_called_once_with("tmp/sess1_output.json", "w")
        handle = mock_file()
        handle.write.assert_called_once_with('{"data":"val"}')

    @patch("tools.state_management.get_session_history")
    @patch("schema.state.GlobalState.model_validate_json")
    def test_get_current_global_state_returns_object(self, mock_validate_json, mock_get_history):
        mock_get_history.return_value = '{"goal": "test"}'
        mock_obj = MagicMock(spec=GlobalState)
        mock_validate_json.return_value = mock_obj

        result = get_current_global_state("sess1")
        self.assertEqual(result, mock_obj)
        mock_validate_json.assert_called_once_with('{"goal": "test"}')

    @patch("tools.state_management.get_session_history")
    def test_get_current_global_state_success(self, mock_get_history):
        # Prepare a fake JSON string that models a valid GlobalState
        fake_json = '{"goal": "test goal", "target": "http://test.com", "session_id": "test-session-id",  "task_list": {}, "task_name_index": {}}'
        mock_get_history.return_value = fake_json

        result = get_current_global_state("sess1")

        # Assert result is a GlobalState instance with expected fields
        self.assertIsInstance(result, GlobalState)
        self.assertEqual(result.goal, "test goal")
        self.assertEqual(result.target, "http://test.com")

    @patch("tools.state_management.get_session_history")
    def test_get_current_global_state_no_session(self, mock_get_history):
        # Simulate no session history found
        mock_get_history.return_value = None

        with self.assertRaises(Exception) as context:
            get_current_global_state("sess1")

        self.assertIn("No session history found", str(context.exception))

    @patch("tools.state_management.save_current_global_state")
    @patch("tools.state_management.get_current_global_state")
    def test_add_task_in_global_state(self, mock_get_state, mock_save_state):
        # Prepare a mock GlobalState instance
        mock_state = MagicMock(spec=GlobalState)
        mock_get_state.return_value = mock_state

        # Prepare a dummy Task
        task = Task(
            name="test_task",
            status=TaskStatus.PENDING,
            stage=WorkflowStage.RECON
        )

        add_task_in_global_state("sess1", task)

        # Assert add_task is called on the GlobalState instance with the task
        mock_state.add_task.assert_called_once_with(task)

        # Assert save_current_global_state is called with correct params
        mock_save_state.assert_called_once_with("sess1", mock_state)

    @patch("tools.state_management.save_current_global_state")
    @patch("tools.state_management.get_current_global_state")
    def test_update_task_in_global_state(self, mock_get_state, mock_save_state):
        # Prepare a mock GlobalState instance with update_task method
        mock_state = MagicMock(spec=GlobalState)
        mock_get_state.return_value = mock_state

        # Prepare a dummy Task with model_dump method returning dict
        task = MagicMock(spec=Task)
        task.model_dump.return_value = {
            "uuid": "some-uuid",
            "name": "test_task",
            "status": "completed",
            "stage": "recon",
        }
        task.name = "test_task"

        update_task_in_global_state("sess1", task)

        # Assert update_task is called with unpacked dict from model_dump()
        mock_state.update_task.assert_called_once_with(**task.model_dump.return_value)

        # Assert save_current_global_state is called with correct params
        mock_save_state.assert_called_once_with("sess1", mock_state)

if __name__ == "__main__":
    unittest.main()
