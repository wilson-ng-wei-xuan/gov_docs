import pytest
import asyncio
import shlex
import os
from agno.tools import Toolkit
from typing import List, Optional
from tools.guardrails.base import GuardedToolkit
from tools.shell_tools.safe_shell_tool import ShellGuardRail, ShellGuardedToolkit

MAX_TOOL_OUTPUT_BYTES = int(os.getenv("MAX_TOOL_OUTPUT_BYTES", "2000"))

# Helper Class
class SafetyTestKit(Toolkit):

    def __init__(self, force_output: Optional[str] = None, create_length: Optional[int] = None, force_timeout: Optional[int] = None):
        
        self.force_output = force_output
        self.create_length = create_length
        self.force_timeout = force_timeout

        super().__init__(name="HelperClass", tools=[self.arun])
    
    async def arun(self, temp: List[str]=[]) -> str:
        if self.create_length:
            return "t" * self.create_length
        
        if self.force_output:
            return self.force_output
        
        if self.force_timeout:
            asyncio.sleep(self.force_timeout)

        return "".join(temp)


##### TESTING PRE CHECKS #####
# Testing safe commands
safe_commands = [
    "echo hello",
    "cat tests/tools/temp.txt",
    "head -n 10 tests/tools/temp.txt",
    'grep "testing" tests/tools/temp.txt',
    "echo root",
    "echo hello > tests/tools/temp.txt"
]

@pytest.mark.asyncio
@pytest.mark.parametrize("cmd", safe_commands)
async def test_safe_commands(cmd):
    """Safe commands should pass the safety checker."""

    toolkit = ShellGuardedToolkit()
    
    result = await toolkit.arun(shlex.split(cmd))
    assert not result.startswith("Unsafe"), f"TestSafeCommands: {cmd} incorrectly raised an error"

# Testing unsafe commands
# Each tuple: (command, expected violation(s))
unsafe_commands = [
    # Concatenation
    ("echo hello; ls", "concatenation"),
    ("mkdir test && cd test", "concatenation"),
    ("false || echo fail", "concatenation"),
    ("sleep 10 &", "background"),  # background operator
    
    # Subshell / command substitution
    ("(echo hello; ls)", "subshell"),
    ("$(rm -rf /tmp/test)", "subshell"),
    ("echo `date`", "subshell"),
    
    # Mixed cases
    ("echo a & echo b; echo c && echo d || echo e", "Mixed"),
    ("(echo start && ls) | grep txt", "Mixed"),
    ("echo hello | ls > out.txt &", "Mixed"),

    # Unsafe flag
    ('grep -r "TODO" /tests/tools', "Unsafe flag")
]

@pytest.mark.asyncio
@pytest.mark.parametrize("cmd, expected_violation", unsafe_commands)
async def test_unsafe_commands(cmd, expected_violation):
    """
    All unsafe commands should be rejected
    """

    toolkit = ShellGuardedToolkit(post_flags="none")
    
    result = await toolkit.arun(shlex.split(cmd))
    assert result.startswith("Unsafe"), f"TestUnsafeCommand: {cmd} failed to raise an error despite {expected_violation}"


# Testing sensitive path detection
unsafe_paths = [
    ("cat /etc/shadow", ["/etc/shadow"]),
    ("grep 'root' /root/.bashrc", ["/root/.bashrc"]),
    ("cat /home/user/.ssh/authorized_keys /etc/shadow", ["/etc/shadow"]),
    ("cat '/etc/shadow'", ["/etc/shadow"]),
]

@pytest.mark.asyncio
@pytest.mark.parametrize("cmd, expected_path", unsafe_paths)
async def test_unsafe_sensitive_paths(cmd, expected_path):
    """
    Tests that commands with sensitive paths are not allowed to run
    """

    toolkit = ShellGuardedToolkit(post_flags="none")
    
    result = await toolkit.arun(shlex.split(cmd))
    assert result.startswith("Unsafe"), f"TestUnsafePath: {cmd} failed to raise an error despite sensitive path {expected_path}"

##### TESTING POST PROCESSING #####

# Testing Redaction
redact_messages = [
    ("password= testpasspasswordword","password"),
    ("paSSwOrD: testpasspasswordword", "paSSwOrD"),
    ("api-key: asdnfah13rinflaskmfdalmn", "api-key"),
    ("API_KEY= asdnfah13rinflaskmfdalmn", "api-key"),
]

@pytest.mark.asyncio
@pytest.mark.parametrize("redact_message, sensitive", redact_messages)
async def test_output_redaction(redact_message, sensitive):
    """Ensure that sensitive information is redacted"""

    tool = SafetyTestKit(force_output=redact_message)
    guardrail = ShellGuardRail(pre_flags="none")
    toolkit = GuardedToolkit(base_tool=tool, guardrail=guardrail)
    
    result = await toolkit.arun([])

    assert not sensitive in result, f"TestRedaction: {redact_message} was not successfully redacted: End {result}"
    

# Testing truncation
max_bytes_list = [
    100,
    1000,
    10000,
    100000
]

@pytest.mark.asyncio
@pytest.mark.parametrize("max_bytes", max_bytes_list)
async def test_output_truncation(max_bytes):
    """Ensure output is truncated to max bytes."""

    tool = SafetyTestKit(create_length=(max_bytes+5))
    guardrail = ShellGuardRail(pre_flags="none")
    toolkit = GuardedToolkit(base_tool=tool, guardrail=guardrail)
    
    result = await toolkit.arun([])

    if max_bytes + 5 <= MAX_TOOL_OUTPUT_BYTES:
        return
    
    assert result.startswith("Note: Tool result has been truncated from length"), f"TestOutputTruncation({max_bytes}): Output does not indicate truncation to agent"

    # Check actual truncation
    pos = result.find("\n")
    assert len(result[pos+1:]) <= max_bytes, f"TestOutputTruncation({max_bytes}): Output was not truncated"

