import json
from typing import List

import pytest
from unittest.mock import MagicMock, patch
from custom_agents.open_redirect.open_redirect_agent import _run_open_redirect_agent, run_open_redirect_agent, _is_js_redirect_with_payload, _detect_redirect, _check_open_redirects, check_open_redirects_get_and_post, RedirectType, OpenRedirectParamResult, \
    WebRequesterTool
from schema.common import ParamResultList, FinalTestingResult
from schema.request_response import RequestResponsePair, RequestDetails, ResponseDetails


@pytest.mark.parametrize("body, payload, expected", [
    ('<script>location.href = "https://yomamapapa.com"</script>', 'https://yomamapapa.com', True),
    ('<script>window.location = "https://yomamapapa.com"</script>', 'https://yomamapapa.com', True),
    ('<script>document.location = "https://yomamapapa.com"</script>', 'https://yomamapapa.com', True),
    ('<script>location.replace = "https://yomamapapa.com"</script>', 'https://yomamapapa.com', True),

    # False cases
    ('<script>alert("https://yomamapapa.com")</script>', 'https://yomamapapa.com', False),
    ('<script>var x = "https://yomamapapa.com"</script>', 'https://yomamapapa.com', False),
    ('<script>location.href = "https://notmypayload.com"</script>', 'https://yomamapapa.com', False),

    # Case insensitivity test
    ('<script>LOCATION.HREF = "https://yomamapapa.com"</script>', 'https://yomamapapa.com', True),
])
def test_is_js_redirect_with_payload(body, payload, expected):
    assert _is_js_redirect_with_payload(body, payload) == expected

PAYLOAD = "https://yomamapapa.com"
PARAM = "redirect"
METHOD = "GET"
TEST_URL = "https://example.com/page?redirect=https://yomamapapa.com"

@pytest.mark.parametrize("response_headers, response_body, expected_type", [
    # Location Header
    ({"Location": PAYLOAD}, "", RedirectType.LOCATION_HEADER),

    # Meta Refresh
    ({}, '<meta http-equiv="refresh" content="5; url=https://yomamapapa.com">', RedirectType.META_REFRESH),

    # JavaScript Redirect
    ({}, '<script>window.location = "https://yomamapapa.com"</script>', RedirectType.JS_REDIRECT),

    # HTTP Refresh Header
    ({"Refresh": f"0;url={PAYLOAD}"}, "", RedirectType.HTTP_REFRESH_HEADER),

    # Not Vulnerable
    ({}, "<html><body>No redirect here</body></html>", RedirectType.NOT_VULNERABLE)
])
def test_detect_redirect_variants(response_headers, response_body, expected_type):
    response = RequestResponsePair(
        request=RequestDetails(
            request_url=TEST_URL,
            request_method=METHOD,
            request_headers={"xxx": "xxx"},
            request_body=""
        ),
        response=ResponseDetails(
            response_headers=response_headers,
            response_body=response_body,
            response_url=TEST_URL,
            response_status_code=200,
        ),
        notes=[""],
        error=[""],
    )
    result: OpenRedirectParamResult = _detect_redirect(
        request_response=response,
        param=PARAM,
        payload=PAYLOAD,
    )

    assert result.redirect_type == expected_type
    assert result.param == PARAM
    assert result.payload == PAYLOAD
    assert result.endpoint_url == TEST_URL
    assert result.method == METHOD

    if expected_type == RedirectType.NOT_VULNERABLE:
        assert result.potentially_vulnerable is False
    else:
        assert result.potentially_vulnerable is True

def build_fake_response(
    response_body: str,
    response_headers: dict,
    response_status_code: int = 302,
    response_url: str = "https://victim.com/redirected",
    request_url: str = "https://victim.com/page?redirect=https%3A%2F%2Fyomamapapa.com",
    request_method: str = "GET",
    request_headers: dict = None,
    request_body: str = ""
) -> str:
    """
    Build a JSON-serialized response with one RequestResponsePair.
    Matches expected schema for _check_open_redirects.
    """
    if request_headers is None:
        request_headers = {"User-Agent": "unit-test"}

    response = {
        "request": {
            "request_url": request_url,
            "request_method": request_method,
            "request_headers": request_headers,
            "request_body": request_body,
        },
        "response": {
            "response_url": response_url,
            "response_status_code": response_status_code,
            "response_headers": response_headers,
            "response_body": response_body,
        },
        "notes": [],
        "error": []
    }

    return json.dumps([response])


@pytest.fixture
def mock_requester(*args, **kwargs):
    return MagicMock(spec=WebRequesterTool)


def test_check_open_redirects_detects_location_header(mock_requester):
    response_json = build_fake_response(
        response_body="<html></html>",
        response_headers={"Location": "https://yomamapapa.com"}
    )
    mock_requester.run.return_value = response_json

    result = _check_open_redirects(
        web_requester=mock_requester,
        target_url="https://victim.com/page?redirect=https%3A%2F%2Fyomamapapa.com",
        target_param="redirect",
        payload="https://yomamapapa.com"
    )

    assert isinstance(result, ParamResultList)
    assert result.param_result_list[0].redirect_type == RedirectType.LOCATION_HEADER

def test_check_open_redirects_get_and_post_runs_both(mock_requester, monkeypatch):
    monkeypatch.setattr("custom_agents.open_redirect.open_redirect_agent.WebRequesterTool", lambda *args, **kwargs: mock_requester)
    monkeypatch.setattr("custom_agents.open_redirect.open_redirect_agent.REDIRECT_PAYLOADS", ["https://yomamapapa.com", "//yomamapapa.com", "%2F%2Fyomamapapa.com"])

    # Simulate a meta refresh for GET, JS for POST
    def run_side_effect(url, method, data=None):
        if method == "GET":
            return build_fake_response(
                response_body='<meta http-equiv="refresh" content="0; url=https://yomamapapa.com">',
                response_headers={}
            )
        else:
            return build_fake_response(
                response_body='<script>window.location = "https://yomamapapa.com"</script>',
                response_headers={}
            )

    mock_requester.run.side_effect = run_side_effect

    result = check_open_redirects_get_and_post(
        target_url="https://victim.com/page",
        target_param="redirect",
        request_body="a=1&b=2"
    )

    assert isinstance(result, ParamResultList)
    types = {r.redirect_type for r in result.param_result_list}
    assert RedirectType.META_REFRESH in types
    assert RedirectType.JS_REDIRECT in types

# Dummy payloads and results for mocking
dummy_param_result = OpenRedirectParamResult(
    endpoint_url="https://example.com",
    method="GET",
    param="redirect",
    payload="https://evil.com",
    potentially_vulnerable=True,
    redirect_type=RedirectType.LOCATION_HEADER,
)

dummy_param_result_list = ParamResultList(param_result_list=[dummy_param_result])

class DummyAgentResponse:
    def __init__(self, content):
        self.content = content

@pytest.fixture
def mock_tag_recon_info_output():
    class TagReconInfo:
        vuln_param = "redirect"
        tags = ["OPEN_REDIRECT"]
        param_set = "redirect=https://example.com&other=1"
        url = "https://victim.com/?redirect=https://example.com&other=1"
        method = "GET"
        enctype = "application/x-www-form-urlencoded"

    return TagReconInfo()

@patch("custom_agents.open_redirect.open_redirect_agent.OpenRedirectAgent")
@patch("custom_agents.open_redirect.open_redirect_agent.ResponseFormatterAgent")
@patch("custom_agents.open_redirect.open_redirect_agent.check_open_redirects_get_and_post")
def test_run_open_redirect_agent_and_run_open_redirect_agent(
    mock_check_redirects,
    mock_response_formatter_agent_class,
    mock_open_redirect_agent_class,
        mock_tag_recon_info_output,
):
    # Mock the OpenRedirectAgent instance and its .run method
    mock_open_redirect_agent = MagicMock()
    mock_open_redirect_agent.run.return_value = DummyAgentResponse("raw agent output")
    mock_open_redirect_agent_class.return_value = mock_open_redirect_agent

    # Mock the ResponseFormatterAgent instance and its .run method
    mock_response_formatter_agent = MagicMock()
    # The formatter should convert raw output to ParamResultList
    mock_response_formatter_agent.run.return_value = DummyAgentResponse(dummy_param_result_list)
    mock_response_formatter_agent_class.return_value = mock_response_formatter_agent

    # Mock check_open_redirects_get_and_post to return dummy results
    mock_check_redirects.return_value = dummy_param_result_list

    # Run the high-level function
    result = run_open_redirect_agent(mock_tag_recon_info_output, session_id="session123")

    # Check that the returned object is the correct type
    assert isinstance(result, FinalTestingResult)

    # It should have param keys matching vuln_param_set keys
    assert "redirect" in result.final_param_result_list
    # The value under that key should be a ParamResultList with our dummy data
    param_results = result.final_param_result_list["redirect"]
    assert isinstance(param_results, List)
    assert len(param_results) > 0

    # Check that open_redirect_agent.run was called at least once
    mock_open_redirect_agent.run.assert_called()

    # Check that ResponseFormatterAgent.run was called
    mock_response_formatter_agent.run.assert_called()

    # Check that check_open_redirects_get_and_post was called for GET and POST
    mock_check_redirects.assert_called()

@pytest.mark.parametrize(
    "agent_content, expected",
    [
        (dummy_param_result_list, True),
        ("invalid content", False),
    ],
)
def test__run_open_redirect_agent_behavior(agent_content, expected):
    # Setup dummy agents
    dummy_agent = MagicMock()
    dummy_agent.run.return_value = DummyAgentResponse("ignored")

    dummy_formatter = MagicMock()
    dummy_formatter.run.return_value = DummyAgentResponse(agent_content)

    if expected:
        result = _run_open_redirect_agent("prompt", dummy_agent, dummy_formatter)
        assert isinstance(result, ParamResultList)
    else:
        with pytest.raises(ValueError):
            _run_open_redirect_agent("prompt", dummy_agent, dummy_formatter)
