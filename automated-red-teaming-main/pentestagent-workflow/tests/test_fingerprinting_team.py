import os
from textwrap import dedent

from agno.agent import Agent

from custom_models.litellm_with_retry import LiteLLMOpenAIWithRetry as LiteLLMOpenAI
from agno.tools.shell import ShellTools
from agno.tools.serper import SerperTools
from tools.katana import Katana

model = LiteLLMOpenAI(
        id=os.getenv("MODEL_ID"),  # Model ID to use
        base_url="https://litellm-stg.aip.gov.sg/v1",
        api_key=os.getenv("OPENAI_API_KEY"),
    )

fingerprinting_agent = Agent(
    name="Fingerprinting Agent",
    model=model,
    tools=[
            SerperTools(api_key=os.getenv("SERPER_API_KEY")), 
            ShellTools(cache_results=True)
    ],
    add_name_to_instructions=True,
    instructions=dedent("""
    You are a penetration testing assistant.

    Your task is to identify if a given list of URLs may be vulnerable to the following vulnerabilities:
    - SQL Injection (SQL)
    - Cross-site scripting (XSS)
    - XML External Entity Injection (XXE)
    - Server-Side Request Forgery (SSRF)
    - Insecure Deserialization (DESERIALISER)

    You must use two approaches:
    1. **Passive Recon** using Serper.dev (Google search API) to search for known vulnerabilities associated with each URL.
    2. **Active Recon** using shell-based tools like `curl`, `grep`, and `xargs` to send payloads and inspect responses.

    For each URL:
    - Generate appropriate Google dorks (e.g., `"<url>" "SQL injection"`, `"site:<host>" intitle:"vulnerable"`)
    - Use Serper to retrieve titles/snippets of top results
    - If relevant results exist (e.g., forums, bug bounty disclosures, CVEs), flag the vulnerability as “possible”

    Then:
    - Perform active scanning using curl or other CLI tools:
        - For SQLi: inject `' OR '1'='1` into parameters and look for SQL errors
        - For XSS: inject `<script>alert(1)</script>` and check for reflection in response
        - For XXE: send XML payloads with external entities and look for file inclusion results
        - For SSRF: test with a controlled external server and monitor if it’s accessed
        - For Deserialization: send crafted serialized payloads and observe application behavior

    Output the result in the following JSON format:

    ```json
    [
        {
            "url": "http://example.com/login",
            "vulnerabilities": {
            "SQL": {
                "passive_evidence": "Found forum post discussing SQL injection on /login",
                "active_test_result": "Response contains SQL syntax error",
                "status": "likely"
            },
            "XSS": {
                "passive_evidence": null,
                "active_test_result": "No reflection",
                "status": "unlikely"
            },
            ...
            }
        },
        ...
    ]
    ```

    You are allowed to:
        •	Use shell commands to issue HTTP requests and grep the output
        •	Use Serper.dev to perform passive Google searches

    Your output should help a human pentester prioritize targets based on both recon techniques.                        
"""),
    # save_response_to_file="cve_output.md",
    debug_mode=True,
    context=dedent("""
        If user input is required, call get_user_input.
    """),
    add_context=True,
)


katana_agent = Agent(
    name="Katana Agent",
    model=model,
    tools=[
            Katana(cache_results=True)  # Using Katana for active scanning
    ],
    add_name_to_instructions=True,
    instructions=dedent("""
                <task>
                Identify, as a JSON list, a list of full endpoints from katana_output that you think are worth analyzing further for web vulnerabilities.
                Prioritize recall over precision in your analysis - identify any endpoints that are **potentially** useful, it is okay if they are not.
                Also look out for and exclude any redundant or duplicated endpoints that are unlikely to contribute to the web vulnerability scan. 
                </task>
                
                <additional_instructions>
                Think step by step.
                Return only the json output and nothing else. For example:
                ```json 
                [
                    'http://link1.com'
                    'http://link1.com/endpoint1'
                    'http://link2.com'
                ]```
                </additional_instructions>
                """),
    # save_response_to_file="cve_output.md",
    debug_mode=True,
    context=dedent("""
        If user input is required, call get_user_input.
    """),
    add_context=True,
)

from agno.team.team import Team
from agno.tools.reasoning import ReasoningTools
from agno.tools.thinking import ThinkingTools

recon_team = Team(
    name="Penetration Testing Recon Team",
    mode="coordinate",
    model=model,
    members=[fingerprinting_agent, katana_agent],
    tools=[ReasoningTools(add_instructions=True), ThinkingTools(add_instructions=True)],
    instructions=dedent("""
        You are a team of penetration testing agents working together to identify potential vulnerabilities in web applications.
        Each agent has a specific role:
        - **Fingerprinting Agent**: Performs passive and active reconnaissance to identify potential vulnerabilities using Serper.dev and shell commands.
        - **Katana Agent**: Uses the Katana tool to identify endpoints worth analyzing for web vulnerabilities.
        You must collaborate effectively, sharing insights and findings to build a comprehensive understanding of the target web applications.
        Always use Katana to identify endpoints worth analyzing, then use the Fingerprinting Agent to analyze those endpoints for vulnerabilities.
        Your output should be a JSON list of endpoints identified for web vulnerabilities.
        Each endpoint should be accompanied by a brief description of why it is worth analyzing.
        Only use the following values in your tags: ["SQL", "XSS", "XXE", "SSRF", "Deserialization"]
        For example:
        ```json
        [
            {
                "url": "http://example.com/login",
                "description": "Login page for example.com.",
                "vulnerabilities": {
                    "SQL": {
                        "passive_evidence": "Found forum post discussing SQL injection on /login",
                        "active_test_result": "Response contains SQL syntax error",
                        "status": "likely"
                    },
                    "XSS": {
                        "passive_evidence": null,
                        "active_test_result": "No reflection",
                        "status": "unlikely"
                    }
                },  
                "tags": ["SQL", "XSS"],
            },
            {
                "url": "http://example.com/admin",
                "description": "Admin panel that may have insecure deserialization vulnerabilities.",
                "vulnerabilities": {
                    "Deserialization": {
                        "passive_evidence": "Found blog post discussing insecure deserialization in admin panels",
                        "active_test_result": "Response contains serialized object",
                        "status": "likely"
                    }
                },
                "tags": ["Deserialization"]
            }
        ]
        ```
    """),
    debug_mode=True,
    markdown=True,
    show_members_responses=True,
    enable_agentic_context=True,
    add_datetime_to_instructions=True,
    success_criteria="The team has provided a complete assessment of the target URLs, identifying endpoints worth analyzing for web vulnerabilities, and has outputted the results in the specified JSON format.",
)

recon_team.print_response("Identify the vulnerabilities in the target URLs https://webscraper.io/test-sites")