import json
import unittest
from unittest.mock import MagicMock, patch
from custom_agents.xss.xss_agent import _is_payload_reflected, _check_for_reflection, check_for_reflection, run_xss_agent, \
    XSSParamResult, XSSType
from schema.common import ParamResultList, ResultType
from schema.recon import VulnParamSet


class TestIsPayloadReflectedWithMock(unittest.TestCase):
    def test_reflected_in_header(self):
        payload = "<script>"
        mock_response = MagicMock()
        mock_response.response_headers = {
            "X-Test": f"This contains {payload}"
        }
        mock_response.response_body = "Clean body"

        req_resp_obj = MagicMock()
        req_resp_obj.response = mock_response

        result = _is_payload_reflected(payload, req_resp_obj)
        self.assertEqual(result, "Payload reflected in response header.")

    def test_reflected_in_body(self):
        payload = "<img src=x onerror=alert(1)>"
        mock_response = MagicMock()
        mock_response.response_headers = {"X-Test": "Nothing dangerous"}
        mock_response.response_body = f"Content: {payload}"

        req_resp_obj = MagicMock()
        req_resp_obj.response = mock_response

        result = _is_payload_reflected(payload, req_resp_obj)
        self.assertEqual(result, "Payload reflected in response body.")

    def test_not_reflected(self):
        payload = "<script>"
        mock_response = MagicMock()
        mock_response.response_headers = {"X-Test": "Safe"}
        mock_response.response_body = "Clean body"

        req_resp_obj = MagicMock()
        req_resp_obj.response = mock_response

        result = _is_payload_reflected(payload, req_resp_obj)
        self.assertIsNone(result)

class TestCheckForReflection(unittest.TestCase):
    @patch("custom_agents.xss.xss_agent._is_payload_reflected")
    @patch("custom_agents.xss.xss_agent.RequestResponsePair")
    def test_get_method_payload_reflected(self, mock_request_response_pair_class, mock_is_payload_reflected):
        # Setup
        payload = "<script>"
        target_url = "https://example.com"
        target_param = "vuln_param"
        method = "GET"

        # Mock web_requester
        mock_web_requester = MagicMock()
        mock_response = [{"mock": "object"}]
        mock_web_requester.run.return_value = json.dumps(mock_response)

        # Patch model_validate_json to return a fake RequestResponsePair
        mock_req_resp_obj = MagicMock()
        mock_req_resp_obj.request.request_url = target_url
        mock_req_resp_obj.request.request_method = method
        mock_request_response_pair_class.model_validate_json.return_value = mock_req_resp_obj

        # Patch _is_payload_reflected to simulate a finding
        mock_is_payload_reflected.return_value = "Payload reflected in response body."

        # Act
        result: XSSParamResult = _check_for_reflection(mock_web_requester, target_url, target_param, payload)

        # Assert
        self.assertTrue(result.potentially_vulnerable)
        self.assertEqual(result.payload, payload)
        self.assertEqual(result.param, target_param)
        self.assertEqual(result.method, method)
        self.assertEqual(result.notes, "Payload reflected in response body.")
        self.assertEqual(result.xss_type, XSSType.REFLECTED)

        mock_web_requester.run.assert_called_once_with(url=target_url, method=method)
        mock_is_payload_reflected.assert_called_once_with(payload, mock_req_resp_obj)
        mock_request_response_pair_class.model_validate_json.assert_called_once()

    @patch("custom_agents.xss.xss_agent._is_payload_reflected")
    @patch("custom_agents.xss.xss_agent.RequestResponsePair")
    def test_post_method_payload_reflected(self, mock_request_response_pair_class, mock_is_payload_reflected):
        payload = "<script>"
        target_url = "https://example.com/submit"
        target_param = "data"
        request_body = {"data": payload}
        method = "POST"

        # Mock web_requester
        mock_web_requester = MagicMock()
        mock_response = [{"mock": "post-object"}]
        mock_web_requester.run.return_value = json.dumps(mock_response)

        # Mock parsed response object
        mock_req_resp_obj = MagicMock()
        mock_req_resp_obj.request.request_url = target_url
        mock_req_resp_obj.request.request_method = method
        mock_request_response_pair_class.model_validate_json.return_value = mock_req_resp_obj

        # Simulate reflection
        mock_is_payload_reflected.return_value = "Payload reflected in response header."

        result = _check_for_reflection(mock_web_requester, target_url, target_param, payload, request_body)

        self.assertTrue(result.potentially_vulnerable)
        self.assertEqual(result.method, method)
        self.assertEqual(result.notes, "Payload reflected in response header.")
        mock_web_requester.run.assert_called_once_with(url=target_url, method="POST", data=request_body)

    def test_json_parsing_error_returns_safe_result(self):
        payload = "<script>"
        target_url = "https://example.com"
        target_param = "vuln_param"
        request_body = None  # triggers GET

        mock_web_requester = MagicMock()
        mock_web_requester.run.return_value = "INVALID JSON"

        result = _check_for_reflection(mock_web_requester, target_url, target_param, payload, request_body)

        self.assertFalse(result.potentially_vulnerable)
        self.assertEqual(result.notes.startswith("Request or JSON parsing failed"), True)

    @patch("custom_agents.xss.xss_agent._is_payload_reflected")
    @patch("custom_agents.xss.xss_agent.RequestResponsePair")
    def test_payload_not_reflected_returns_safe_result(self, mock_request_response_pair_class,
                                                       mock_is_payload_reflected):
        payload = "<script>"
        target_url = "https://example.com"
        target_param = "query"

        mock_web_requester = MagicMock()
        mock_response = [{"mock": "safe"}]
        mock_web_requester.run.return_value = json.dumps(mock_response)

        mock_req_resp_obj = MagicMock()
        mock_req_resp_obj.request.request_url = target_url
        mock_req_resp_obj.request.request_method = "GET"
        mock_request_response_pair_class.model_validate_json.return_value = mock_req_resp_obj

        mock_is_payload_reflected.return_value = None  # simulate not vulnerable

        result = _check_for_reflection(mock_web_requester, target_url, target_param, payload)

        self.assertFalse(result.potentially_vulnerable)
        self.assertEqual(result.notes, "Not vulnerable.")

    @patch("custom_agents.xss.xss_agent._check_for_reflection")
    @patch("custom_agents.xss.xss_agent.WebRequesterTool")
    def test_check_for_reflection_calls_check_twice_per_payload(self, mock_web_requester_tool_class,
                                                                mock_check_for_reflection):
        # Setup
        url = "https://example.com/path?existing=1"
        target_param = "vuln_param"
        request_body = {"foo": "bar"}

        # Mock web_requester instance (not actually used, just passed)
        mock_web_requester_tool_class.return_value = MagicMock()

        # Stub return values for each call to _check_for_reflection
        fake_result = MagicMock(spec=XSSParamResult)
        mock_check_for_reflection.return_value = fake_result

        with patch("custom_agents.xss.xss_agent.PAYLOADS", ["<payload1>", "<payload2>"]):
            result: ParamResultList = check_for_reflection(url, target_param, request_body)

        # Expect 2 payloads x 2 methods (GET + POST) = 4 calls
        self.assertEqual(len(result.param_result_list), 4)
        self.assertTrue(all(r is fake_result for r in result.param_result_list))

        # Assert _check_for_reflection called with expected arguments
        calls = mock_check_for_reflection.call_args_list
        self.assertEqual(len(calls), 4)

        # Each call: _check_for_reflection(web_requester, url, target_param, payload, request_body)
        get_calls = []
        post_calls = []

        for call in calls:
            args = call.args
            kwargs = call.kwargs

            has_request_body = False

            if len(args) >= 5 and args[4] is not None:
                has_request_body = True
            elif kwargs.get("request_body") is not None:
                has_request_body = True

            if has_request_body:
                post_calls.append(call)
            else:
                get_calls.append(call)

        self.assertEqual(len(get_calls), 2)
        self.assertEqual(len(post_calls), 2)

class TestRunXSSAgent(unittest.TestCase):
    @patch("custom_agents.xss.xss_agent.check_for_reflection")
    @patch("custom_agents.xss.xss_agent.ResponseFormatterAgent")
    @patch("custom_agents.xss.xss_agent.XSSAgent")
    def test_run_xss_agent_basic(self, mock_xss_agent_cls, mock_formatter_cls, mock_check_reflection):
        # -------------------------
        # Arrange: create dummy va_output
        # -------------------------
        dummy_tag_recon_info_output = MagicMock()
        dummy_tag_recon_info_output.url = "https://example.com/path"
        dummy_tag_recon_info_output.method = "POST"
        dummy_tag_recon_info_output.enctype = "application/x-www-form-urlencoded"
        dummy_tag_recon_info_output.vuln_param ="foo"
        dummy_tag_recon_info_output.tags = ["XSS"]
        dummy_tag_recon_info_output.param_set = "foo=bar"
        dummy_tag_recon_info_output.reason = ""

        # -------------------------
        # Mock check_for_reflection output
        # -------------------------
        mock_check_result = ParamResultList(param_result_list=[
            XSSParamResult(
                endpoint_url="https://example.com/path",
                method="GET",
                param="foo",
                payload="<payload>",
                potentially_vulnerable=True,
                xss_type=XSSType.REFLECTED,
                notes="Payload reflected in response body."
            )
        ])
        mock_check_reflection.return_value = mock_check_result

        # -------------------------
        # Mock xss_agent.run and response_formatter_agent.run
        # -------------------------
        mock_xss_agent = MagicMock()
        mock_xss_agent.run.return_value.content = "dummy-content"
        mock_xss_agent_cls.return_value = mock_xss_agent

        mock_formatter = MagicMock()
        mock_formatter.run.return_value.content = mock_check_result
        mock_formatter_cls.return_value = mock_formatter

        # -------------------------
        # Act
        # -------------------------
        result = run_xss_agent(dummy_tag_recon_info_output, session_id="test-session")

        # -------------------------
        # Assert
        # -------------------------
        self.assertEqual(result.endpoint, "https://example.com/path")
        self.assertIn("foo", result.final_param_result_list)
        self.assertEqual(len(result.final_param_result_list["foo"]), 2)

        basic_result = result.final_param_result_list["foo"][0]
        self.assertEqual(basic_result.result_type, ResultType.BASIC)
        self.assertEqual(basic_result.param_result_list, mock_check_result)

        advanced_result = result.final_param_result_list["foo"][1]
        self.assertEqual(advanced_result.result_type, ResultType.ADVANCED)
        self.assertEqual(advanced_result.param_result_list, mock_check_result)

        mock_xss_agent.run.assert_called_once()
        mock_formatter.run.assert_called_once()

