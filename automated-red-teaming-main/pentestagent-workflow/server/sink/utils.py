from copy import deepcopy
import logging
import asyncio
import inspect
from functools import wraps

from typing import Any, Optional, Dict,  Union, List
from config.context import current_sink, current_node, current_session_id
from config.globals import STREAM_RESPONSES
from server.sink.schema import StreamEvent, StreamSink, StreamType
from agno.models.message import Message
from agno.agent import RunResponseEvent

logger = logging.getLogger(__name__)

async def _push_chunk_to_sink(
    chunk: Union[RunResponseEvent, Message], sink: StreamSink, metadata: Optional[Dict[str, Any]]=None
):
    """Utility function to push RunResponseEvent/Message to sink based on the event type."""

    if metadata is None:
        metadata = {}
    else:
        # IMPORTANT: prevents accidental inplace additions to the metadata, which will grossly inflate the chat history size 
        metadata = deepcopy(metadata)
    
    event = (
        getattr(chunk, "event", None) if isinstance(chunk, RunResponseEvent)
        else getattr(chunk, "role", None) if isinstance(chunk, Message)
        else None
        )
    
    message_events = [
        StreamType.RUN_RESPONSE_CONTENT.value,
        StreamType.SYSTEM.value,
        StreamType.USER.value
        ]
    
    if event in message_events and getattr(chunk, "content", None):
        data = chunk.content
        if event == StreamType.RUN_RESPONSE_CONTENT.value:
            event_type = StreamType.RUN_RESPONSE_CONTENT
        elif event == StreamType.SYSTEM.value:
            event_type = StreamType.SYSTEM
        else:
            event_type = StreamType.USER
        await sink.send(
            StreamEvent(
                type=event_type, 
                data=data, 
                metadata=metadata
                )
                )

    elif event == StreamType.TOOLSTART.value:
        tool = getattr(getattr(chunk, "tool", None), "tool_name", "unknown_tool")
        tool_id = getattr(getattr(chunk, "tool", None), "tool_call_id", "unknown_id")
        args = getattr(getattr(chunk, "tool", None), "tool_args", {})

        if tool == 'get_user_input':
            # For now, the logic for pushing a initialization message for user input is handled by the tool itself
            pass
        else:
            data = f"[TOOL][{tool}] Beginning execution"
            metadata.update({"tool_name": tool, "tool_call_id": tool_id, "tool_args": args})
            await sink.send(StreamEvent(type=StreamType.TOOLSTART, data=data, metadata=metadata))

    elif event == StreamType.TOOLCOMPLETE.value:
        tool = getattr(getattr(chunk, "tool", None), "tool_name", "unknown_tool")
        tool_id = getattr(getattr(chunk, "tool", None), "tool_call_id", "unknown_id")
        result = getattr(getattr(chunk, "tool", None), "result", None)
        is_error = getattr(getattr(chunk, "tool", None), "tool_call_error", False)
        
        if tool == 'get_user_input':
            # Same as above, the logic for pushing a completion message for user input is handled by the tool itself
            pass
        else:
            data = f"[TOOL][{tool}] Execution {'failed' if is_error else 'completed'}"
            metadata.update({"tool_name": tool, "tool_call_id": tool_id, "tool_output": result, "tool_call_error": is_error})
            await sink.send(StreamEvent(type=StreamType.TOOLCOMPLETE, data=data, metadata=metadata))

async def consume_sink(sink: StreamSink):
    """Async function to consume messages from a sink with buffer and prints them to console. Use for debugging."""

    while True:
        message = await sink.get()
        t = message.type.value
        d = message.data
        if t == "RunResponseContent":
            print(d, end="", flush=True)
        else:
            print(f"\n{d}", flush=True)


def stream_status(
    module_name: Optional[str] = None,
    prefix: str = "[SYSTEM]",
    START_TYPE: StreamType = StreamType.INITIATE,
    END_TYPE: StreamType = StreamType.COMPLETE,
    input_metadata_fields: Optional[List] = None,
    log_output: bool=False,
):
    """
    Decorator that wraps async functions or generators to stream the start and end of their execution, along with optional input metadata and output logging.

    Args:
        module_name (Optional[str], default=None): Name of the module to associate with the stream.
        prefix (str, default="[SYSTEM]"): Prefix string for log messages.
        START_TYPE (StreamType, default=StreamType.INITIATE): Stream type for the start event.
        END_TYPE (StreamType, default=StreamType.COMPLETE): Stream type for the end event.
        input_metadata_fields (Optional[list], default=None): Fields to include from the function signature for logging purposes. Logged under the `input` field.
        log_output (bool, default=False): Whether to log the final output of the function as metadata. Does not apply to streaming.
    """


    if input_metadata_fields is None:
        input_metadata_fields = []
    
    def _decorator(func):
        name = module_name or func.__name__
        
        # Helper Functions 
        def extract_input_metadata_fields(**kwargs)-> Dict[str, Any]:
            '''Extracts specified input metadata fields from kwargs.'''
            return {'inputs': {k: kwargs[k] for k in input_metadata_fields if k in kwargs}} 
        
        async def _send(
            event_type: StreamType, msg: str, metadata: Optional[Dict[str, Any]] = None
        ):
            if not STREAM_RESPONSES:
                return
            
            if metadata is None:
                metadata = {}
            
            # Every event should have these fields to write to DynamoDB 
            core_metadata = {
                'node_id': getattr(current_node.get(), 'node_id', None),
                'session_id': current_session_id.get()
            }

            # Have optional metadata for certain event types 
            optional_metadata = {}
            if event_type == StreamType.INITIATE:
                optional_metadata['name'] = getattr(current_node.get(), 'label', None)


            # Merge core metadata with any additional metadata provided
            metadata = {**metadata, **core_metadata, **optional_metadata}

            try:
                sink = current_sink.get()
                await sink.send(
                    StreamEvent(type=event_type, data=msg, metadata=metadata)
                )
            except Exception as e:
                logger.error(
                    f"Failed to send {getattr(event_type, 'name', event_type)} message to sink for {name}. {e}"
                )
                raise

        # Decorator logic                
        # For wrapping async generators
        if inspect.isasyncgenfunction(func):

            @wraps(func)
            async def _agen_wrapper(*args, **kwargs):
                succeeded = False
                additional_metadata = extract_input_metadata_fields(**kwargs)
                await _send(START_TYPE, f"{prefix} Beginning {name}", additional_metadata)
                try:
                    async for item in func(*args, **kwargs):
                        yield item
                    succeeded = True
                except asyncio.CancelledError as e:
                    await asyncio.shield(
                        _send(StreamType.CANCEL, f"{prefix} {name} cancelled")
                    )
                    raise
                except Exception as e:
                    await asyncio.shield(
                        _send(
                            StreamType.ERROR,
                            f"{prefix} {name} failed",
                            {"error": str(e)} ,
                        )
                    )
                    raise
                finally:
                    if succeeded:
                        await asyncio.shield(
                            _send(
                                END_TYPE, 
                                f"{prefix} Completed {name} module"
                            )
                        )
            return _agen_wrapper

        # For wrapping async functions
        elif asyncio.iscoroutinefunction(func):

            @wraps(func)
            async def _awrapper(*args, **kwargs):
                succeeded = False
                additional_metadata = extract_input_metadata_fields(**kwargs)

                if START_TYPE == StreamType.DIAGNOSTICSTART: 
                    additional_metadata['status'] = 'running'
                    additional_metadata['diagnostic_name'] = name
                
                result = None
                await _send(START_TYPE, f"{prefix} Beginning {name}", additional_metadata)
                try:
                    result = await func(*args, **kwargs)
                    succeeded = True
                    return result
                except asyncio.CancelledError as e:
                    await asyncio.shield(
                        _send(StreamType.CANCEL, f"{prefix} {name} cancelled")
                    )
                    raise
                except Exception as e:
                    error_metadata = {'error': str(e)}

                    if END_TYPE == StreamType.DIAGNOSTICCOMPLETE:
                        error_metadata['status'] = 'failed'
                        error_metadata['diagnostic_name'] = name
                    
                    await asyncio.shield(
                        _send(
                            StreamType.ERROR,
                            f"{prefix} {name} failed",
                            error_metadata
                        )
                    )
                    raise
                finally:
                    if succeeded:
                        if log_output:
                            final_metadata = {'final_output': result}
                        else:
                            final_metadata = {}

                        if END_TYPE == StreamType.DIAGNOSTICCOMPLETE:
                            final_metadata['status'] = 'completed'
                            final_metadata['diagnostic_name'] = name

                        await asyncio.shield(
                            _send(
                                END_TYPE, f"{prefix} Completed {name} module", final_metadata
                            )
                        )

            return _awrapper

        else:
            logger.warning(
                f"{name} stream_status() decorator will not do anything since it is not being used in async context."
            )
            return func

    return _decorator



