import os
from dotenv import load_dotenv

load_dotenv()

import uuid
from textwrap import dedent
import json
import asyncio
import socket
from collections import deque
from typing import Deque, Dict, List, Optional, Any, Literal, get_args, Annotated
from pathlib import Path

from fastapi import FastAPI, HTTPException
from fastapi.encoders import jsonable_encoder
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from pydantic import BaseModel, Field, field_validator
from config.globals import STREAM_RESPONSES, DEBUG_MODE, USE_DB
from urllib.parse import urlparse
import ipaddress
import re

from schema.task_functions import TASK_FUNCTIONS
from tools.routing import (
    TASK_ROUTER,
    route_to_dorking_agent,
    route_to_fingerprint_agent,
    route_to_recon_agent,
    route_individual_exploit_tasks,
    route_to_attack_mapper,
)
from schema.task import WorkflowStage
from schema.state import PentestNode, NodeStatus
from tools.state_management import GLOBAL_STATE_HANDLER
from tools.browser.playwright_toolkit import run_authentication, PlaywrightToolkit
from custom_agents.base import current_model, CustomAgent
from server.sink import (
    QueueSink,
    StreamEvent,
    MultiSink,
    StorageSink,
    DBSink,
    StreamType,
)
from config.context import (
    current_model,
    current_sink,
    current_actions,
    current_node,
    current_session_id,
)

# Setup logging
import logging
from server.logging import setup_logging

setup_logging()
logger = logging.getLogger(__name__)

if USE_DB:
    from config.globals import DYNAMO_DB

app = FastAPI(title="Pentest Orchestrator API", version="1.0")
if os.getenv("ENV") == "local":
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

ModelLiteral = Literal[
    "litellm_proxy/apac.anthropic.claude-3-7-sonnet-20250219-v1:0",
    "litellm_proxy/apac.anthropic.claude-sonnet-4-20250514-v1:0",
    "litellm_proxy/csg.anthropic.claude-sonnet-4-20250514-v1:0",
    "litellm_proxy/azure/gpt-5-eastus2",
    "litellm_proxy/azure/gpt-5-chat-eastus2",
    "litellm_proxy/gemini-2.5-pro",
    "litellm_proxy/azure/gpt-4o-mini",
]

NonEmptyStr = Annotated[str, Field(min_length=1)]

class CreateSessionRequest(BaseModel):
    target: NonEmptyStr
    goal: NonEmptyStr
    model: ModelLiteral

    verify_url: Optional[NonEmptyStr] = None
    verify_str: Optional[NonEmptyStr] = None
    username: Optional[NonEmptyStr] = None
    password: Optional[NonEmptyStr] = None

    @field_validator("target")
    def validate_target(cls, v: str) -> str:
        v = v.strip()

        try:
            parsed_v = urlparse(v)
            if parsed_v.scheme not in {"http", "https"}:
                # Case where the scheme is invalid
                raise ValueError("URL must start with http:// or https://")
            
            host = parsed_v.hostname
            if not host:
                # Case where there is no host
                raise ValueError("Invalid URL host")
        
            if parsed_v.query:
                # Case where there is a query in the string
                raise ValueError("URL contains query component")
            
            if parsed_v.port is not None:
                if not (1 <= parsed_v.port <= 65535):
                    raise ValueError(f"Port {parsed_v.port} is out of range")
            
            try:
                # Case where it is in fact an ip address, check that it is a valid one
                ipaddress.ip_address(host)
                return v
            
            except ValueError:
                # This is the case where we failed to parse it into an IP address
                # Now we check the validity of the host address (standard constraints), reflected by regex below
                # 1) Length of domain is limited
                # 2) Constraints such as the domain cannot start with a "-"
                DOMAIN_REGEX = re.compile(
                    r'^(?=.{1,255}$)([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,63}$'
                )

                if DOMAIN_REGEX.match(host):
                    return v
                else:
                    raise ValueError(f"Host is malformed")
        
        except Exception as e:
            raise ValueError(f"Invalid target name: {e}")

class CreateSessionResponse(BaseModel):
    session_id: str

class StartRunResponse(BaseModel):
    session_id: str
    status: str


class StopRunResponse(BaseModel):
    session_id: str
    status: str


class FollowupRequest(BaseModel):
    message: str


class SubmitActionRequest(BaseModel):
    session_id: str
    action_id: str
    message: str


class SubmitActionResponse(BaseModel):
    success: bool

class ResumeResponse(BaseModel):
    session_id: str
    status: str


# In-memory states
class RuntimeSession:
    def __init__(self, session_id: str):
        self.session_id = session_id
        self.tasks_queue: Deque[PentestNode] = deque()
        self.stop_event: asyncio.Event = asyncio.Event()
        self.runner_task: Optional[asyncio.Task] = None
        self.model: Optional[ModelLiteral]
        self.actions: Dict[str, asyncio.Future] = {}
        self.sink: Optional[MultiSink] = None
        self.storage_state_path: Optional[str] = None
        self.pw: Optional[PlaywrightToolkit] = None
        self.pids: List[int] = []


RUNTIME: Dict[str, RuntimeSession] = {}


async def run_node(node: PentestNode, session_id: str):
    logger.debug(
        f"[Session_id: {session_id}] Running node: {node.label} [id: {node.node_id}]"
    )

    # Set the current node for all downstream tasks to reference
    token = current_node.set(node)
    global_state = await GLOBAL_STATE_HANDLER.aget_session(session_id)

    if node.function is None:
        logger.error(
            f"[Session_id: {session_id}] No function mapped for node: {node.label} [id: {node.node_id}]"
        )
        node.mark_failed(f"No function mapped for node: {node.label}")
        return

    inputs = node.inputs or {}

    if node.is_activated:
        try:
            # Mark as in progress and update global state and db
            node.mark_in_progress()
            await GLOBAL_STATE_HANDLER.aupdate_session(session_id, global_state)

            if asyncio.iscoroutinefunction(node.function):
                logger.info(
                    f"[Session_id: {session_id}] {node.label} [id: {node.node_id}] is async — awaiting..."
                )
                result = await node.function(**node.inputs)
            else:
                logger.info(
                    f"[Session_id: {session_id}] {node.label} [id: {node.node_id}] is sync — calling..."
                )
                result = node.function(**node.inputs)

                # Mark node as completed and save results to DB
            node.mark_completed(result)
            logger.info(
                f"[Session_id: {session_id}] {node.label} [id: {node.node_id}] completed."
            )
        except Exception as e:
            logger.exception(
                f"[Session_id: {session_id}] Task {node.label} [id: {node.node_id}] raised an error: {e}"
            )
            node.mark_failed(str(e))
    else:
        # TODO: Using positional args is quite vague, fix this
        # if node.stage in (WorkflowStage.DORKING, WorkflowStage.FINGERPRINTING):
        #     if not args or not isinstance(args[0], KatanaAnalysisOutput):
        #         raise ValueError(f"Mocking data for {task.stage}, got invalid input")
        #     task.result = args[0]
        logger.info(
            f"[Session_id: {session_id}] {node.name} is set to skip. Result: {node.result}"
        )
        node.mark_skipped()

    # Mark as success/failure/skipped and update global state and db
    await GLOBAL_STATE_HANDLER.aupdate_session(session_id, global_state)

    try:
        current_node.reset(token)
    except:
        pass


async def run_pentest_workflow(
    session_id: str, tasks_queue: Deque[PentestNode], stop_event: asyncio.Event
):
    global_state = await GLOBAL_STATE_HANDLER.aget_session(session_id)

    async def add_node(session_id, new_node, parent_node: Optional[PentestNode] = None):
        global_state.add_node(
            new_node, parent_id=parent_node.node_id if parent_node else None
        )
        # updates global state and saves to DB if enabled
        await GLOBAL_STATE_HANDLER.aupdate_session(session_id, global_state)
        tasks_queue.append(new_node)

    async def retry_node(node: PentestNode):
        """Requeues a node for retrying."""
        # updates global state and saves to DB if enabled
        node.mark_retrying()
        await GLOBAL_STATE_HANDLER.aupdate_session(session_id, global_state)
        tasks_queue.appendleft(node)

    print(tasks_queue)
    while tasks_queue and not stop_event.is_set():
        curr_node = tasks_queue.popleft()

        try:
            await run_node(curr_node, session_id)
        except asyncio.CancelledError:
            logger.error(
                f"[Session_id: {session_id}] Asyncio Cancellation: Exiting Session"
            )
            curr_node.mark_cancelled()
            global_state.mark_cancelled()
            await GLOBAL_STATE_HANDLER.aupdate_session(session_id, global_state)
            raise
        except Exception as e:
            logger.error(
                f"[Session_id: {session_id}] Unexpected error while running task {curr_node.label} [id: {curr_node.node_id}]: {e}"
            )

        await GLOBAL_STATE_HANDLER.aupdate_session(session_id, global_state)

        if curr_node.status == NodeStatus.FAILED:
            if curr_node.retry_counter < 3:
                logger.error(
                    f"Node {curr_node.label} [id: {curr_node.node_id}] FAILED! Retrying... (attempt {curr_node.retry_counter}/3)"
                )
                await retry_node(curr_node)
                continue
            logger.error(
                f"Node {curr_node.label} [id: {curr_node.node_id}] FAILED 3 retries. Terminating..."
            )
            return

        router_fn = TASK_ROUTER.get(curr_node.label, None)
        try:
            if router_fn is not None:
                next_nodes = router_fn(curr_node, session_id, tasks_queue=tasks_queue)
                for next_node in next_nodes:
                    await add_node(session_id, next_node, parent_node=curr_node)

        except Exception as e:
            raise

    global_state.mark_completed()
    await GLOBAL_STATE_HANDLER.aupdate_session(session_id, global_state)
    return


# Helpers
def ensure_runtime_session(session_id: str) -> RuntimeSession:
    rs = RUNTIME.get(session_id)
    if rs is None:
        rs = RuntimeSession(session_id)
        RUNTIME[session_id] = rs
    return rs


async def initialize_new_session(payload: CreateSessionRequest) -> str:
    session_id = str(uuid.uuid4())
    try:
        await GLOBAL_STATE_HANDLER.acreate_session(session_id, payload.goal, payload.target)
        global_state = await GLOBAL_STATE_HANDLER.aget_session(session_id)
        if payload.verify_url and payload.verify_str and payload.username and payload.password:
            global_state.verify_url = payload.verify_url.strip()
            global_state.verify_str = payload.verify_str.strip()
            global_state.username = payload.username.strip()
            global_state.password = payload.password.strip()
        await GLOBAL_STATE_HANDLER.aupdate_session(session_id, global_state)
    except Exception as e:
        logger.exception(f"[Session_id: {session_id}] Failed to create session: {e}")
        raise

    try:
        # create storage state file for session
        storage_state_path = f"{session_id}_storage_state.json"
        with open(storage_state_path, "w", encoding="utf-8") as f:
            json.dump({"cookies": [], "origins": []}, f, ensure_ascii=False, indent=2)

        rs = ensure_runtime_session(session_id)
        rs.storage_state_path = storage_state_path
        rs.model = payload.model.strip()
        rs.tasks_queue.clear()

        new_node = PentestNode(
            label=WorkflowStage.run_katana,
            function=TASK_FUNCTIONS[WorkflowStage.run_katana],
            inputs={
                "target": payload.target,
                "storage_state_path": rs.storage_state_path,
            },
        )
        global_state.add_node(node=new_node)

        rs.tasks_queue.append(new_node)
        global_state.mark_in_progress()
        await GLOBAL_STATE_HANDLER.aupdate_session(session_id, global_state)
        logger.info(f"[Session_id: {session_id}] Initialized new session {session_id}")

    except Exception as e:
        logger.exception(
            f"[Session_id: {session_id}] Failed to initialize session {session_id}: {e}"
        )
        raise

    return session_id


# Helper Function
def _ensure_sink(rs: RuntimeSession, is_without_frontend:bool=False):
    """
    Ensures that a per-session sink exists to enqueue events.

    If running without a frontend (e.g via `python -m server.server` for CLI interface), only sets up the DB sink to save to DynamoDB/S3.
    If running with a frontend, sets up both the DB sink and a QueueSink for SSE streaming to frontend.
    """

    if rs.sink:
        return  # already set up

    if is_without_frontend:
        rs.sink = MultiSink(
            buffer_size=20,
            allow_exceptions=False,
            sinks={
                "dynamo": DBSink(DYNAMO_DB, use_s3_fallback=True),
            },
        )
    else:
        q: asyncio.Queue[Any] = asyncio.Queue()
        rs.sink = MultiSink(
            buffer_size=20,
            allow_exceptions=False,
            sinks={
                "dynamo": DBSink(DYNAMO_DB, use_s3_fallback=True),
                "stream": QueueSink(q),
            },
        )


async def _run_chat(session_id: str, stop_event: asyncio.Event):
    """
    Swap out `await run_pentest_workflow` in `run_with_sink_context` to repurpose as a chat application.
    """

    from server.interactions import get_user_input
    from tools.shell_tools.safe_shell_tool import SafeShellTool
    from tools.web_requester.web_requester import WebRequesterTool

    agent = CustomAgent(
        name="Chat agent",
        goal=dedent("""
                    Follow the user's every instruction and goal.
                    """),
        success_criteria=dedent("""
                    Follow the user's every instruction and goal.
                    """),
        instructions=dedent("""
                            Chat with the user, using the get_user_input tool to obtain their responses.
                            The get_user_input tool is the ONLY way you can interact with the user. 
                            Never generate regular responses without using the tool, because your response will never reach the user. 
                            Upon their response, always follow up unless they explicitly say to end the conversation. 
                            """),
        sess_id=session_id,
        debug_mode=True,
        tools=[get_user_input, SafeShellTool(), WebRequesterTool(use_vpn=False)],
    )
    response_stream = await agent.arun(
        "Ask the user how you can help",
        include_global_state=False,
        stream=True,
    )
    async for r in response_stream:
        pass

# NOVNC_BASE = os.getenv("NOVNC_BASE", "https://novnc.maya-aipt.com")
NOVNC_BASE = os.getenv("NOVNC_BASE", "http://localhost")
DISPLAY_MIN, DISPLAY_MAX = 101, 199
VNC_MIN, VNC_MAX = 5901, 5999
WS_MIN,  WS_MAX  = 6200, 6230

async def _spawn(cmd:list[str], env:dict|None=None):
    return await asyncio.create_subprocess_exec(
        *cmd, env=env, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.STDOUT
    )

def _port_free(port:int)->bool:
    with socket.socket() as s:
        s.settimeout(0.1)
        try: s.bind(("127.0.0.1", port)); return True
        except OSError: return False

def _pick(range_):
    for x in range_:
        # displays: try locking by touching /tmp/.X<x>-lock if you want
        return x
    raise HTTPException(503, "exhausted")

def _pick_port(lo, hi):
    for p in range(lo, hi+1):
        if _port_free(p): return p
    raise HTTPException(503, "no free port")

async def _run_with_sink_context(session_id: str, rs: RuntimeSession):
    """
    Wraps the entire pentesting workflow with a sink context to deliver start, end and error messages.
    """

    sink_token = None
    model_token = None
    actions_token = None
    session_token = None
    gs = await GLOBAL_STATE_HANDLER.aget_session(session_id=session_id)
    try:
        # Set sink for this task's context so all downstream code has access to it
        sink_token = current_sink.set(rs.sink)
        model_token = current_model.set(rs.model)
        actions_token = current_actions.set(rs.actions)
        session_token = current_session_id.set(session_id)

        if gs.verify_url and gs.verify_str and gs.username and gs.password:
            logger.info("fulfill condition to run_authentication")
            # allocate resources
            display = _pick(range(DISPLAY_MIN, DISPLAY_MAX + 1))
            vnc_port = _pick_port(VNC_MIN, VNC_MAX)
            ws_port = _pick_port(WS_MIN, WS_MAX)

            logger.info(f"{display}, {vnc_port}, {ws_port}")

            # base env for X apps on that display
            env = os.environ.copy()

            # 1) Xvfb
            xvfb = await _spawn(["Xvfb", f":{display}", "-screen", "0", "1920x1080x24", "-nolisten", "tcp"])
            # 2) fluxbox
            flux = await _spawn(["fluxbox"], env=env)
            # 3) x11vnc (to VNC)
            x11 = await _spawn(["x11vnc", "-display", f":{display}", "-rfbport", str(vnc_port),
                                "-localhost", "-shared", "-forever", "-nopw"])
            # 4) websockify (to WS)
            # adjust --web path to where noVNC static files live
            wsfy = await _spawn(["websockify", "--web=/usr/share/novnc",
                                 str(ws_port), f"127.0.0.1:{vnc_port}"])

            logger.info("done with spawning")

            rs.pids.extend([xvfb.pid, flux.pid, x11.pid, wsfy.pid])

            # 5) Playwright for this session
            novnc_url = f"{NOVNC_BASE}/s/{ws_port}/vnc.html?path=/s/{ws_port}/ws"
            rs.pw = PlaywrightToolkit(headless=False, storage_state_path=rs.storage_state_path, manual_run=True, novnc_url=novnc_url)
            # ensure Playwright uses this DISPLAY (affects chromium.launch)
            os.environ["DISPLAY"] = f":{display}"

            logger.info(f"display: {os.getenv('DISPLAY')}")

            # kick off auth (will pause waiting for resume)
            await run_authentication(
                rs.pw, gs.target, gs.verify_url, gs.verify_str, gs.username, gs.password
            )
        await run_pentest_workflow(session_id, rs.tasks_queue, rs.stop_event)
        # await _run_chat(session_id,  rs.stop_event)

    except asyncio.CancelledError:
        logger.warning(
            f"[Session_id: {session_id}] Runner cancelled, shutting down resources"
        )
        raise
    finally:
        try:
            await asyncio.shield(
                rs.sink.send(
                    StreamEvent(
                        type=StreamType.RUN_COMPLETE,
                        data=f"[SYSTEM] Pentesting Completed!",
                        metadata={"session_id": session_id},
                    )
                )
            )
        except Exception as e:
            logger.error(
                f"[Session_id: {session_id}] Failed to send run complete message to sink: {e}"
            )
            # Don't raise here - we don't want to mask other exceptions

        try:
            if rs.sink is not None:
                await rs.sink.close()
        except Exception as e:
            logger.error(f"[Session_id: {session_id}] Failed to close sink: {e}")

        for t, v in [
            (sink_token, current_sink),
            (model_token, current_model),
            (actions_token, current_actions),
            (session_token, current_session_id),
        ]:
            if t is not None:
                try:
                    v.reset(t)
                except Exception as e:
                    logger.error(
                        f"[Session_id: {session_id}] Failed to reset context variable: {e}"
                    )

        if rs.pw is not None:
            await rs.pw.stop()

        for pid in rs.pids:
            try:
                os.kill(pid, 15)
            except Exception:
                pass

        # clean up storage state json file
        if rs.storage_state_path:
            Path(rs.storage_state_path).unlink(missing_ok=True)

async def start_runner(session_id: str):
    rs = ensure_runtime_session(session_id)
    if rs.runner_task and not rs.runner_task.done():
        raise RuntimeError("Runner already active for this session.")

    _ensure_sink(rs)
    rs.stop_event.clear()
    rs.runner_task = asyncio.create_task(_run_with_sink_context(session_id, rs))


# API Routes
@app.post("/sessions", response_model=CreateSessionResponse)
async def create_new_session(payload: CreateSessionRequest):
    if (
        not payload.target.strip()
        or not payload.goal.strip()
        or not payload.model.strip()
    ):
        raise HTTPException(
            status_code=400, detail="Both target and goal are required."
        )
    session_id = await initialize_new_session(
        payload
    )

    logger.info(f"Created new session id: {session_id}")
    return CreateSessionResponse(session_id=session_id)


@app.post("/sessions/{session_id}/run", response_model=StartRunResponse)
async def start_or_resume(session_id: str):
    try:
        _ = await GLOBAL_STATE_HANDLER.aget_session(session_id=session_id)
    except Exception:
        raise HTTPException(status_code=404, detail="Unknown session_id")

    try:
        await start_runner(session_id)
    except RuntimeError as e:
        logger.info(f"[Session_id: {session_id}] Runtime Error: {str(e)}")
    return StartRunResponse(session_id=session_id, status="running")


@app.post("/actions", response_model=SubmitActionResponse)
async def submit_action(payload: SubmitActionRequest):
    session_id = payload.session_id
    action_id = payload.action_id
    message = payload.message

    if not action_id.strip() or not message.strip():
        raise HTTPException(
            status_code=400, detail="action_id and message cannot be empty"
        )

    rs = ensure_runtime_session(session_id)
    _ensure_sink(rs)

    actions = rs.actions
    if action_id in actions:
        actions[action_id].set_result(message)
        return SubmitActionResponse(success=True)
    else:
        logger.warning(
            f"[Session_id: {session_id}] {action_id} is not a valid action_id, skipping..."
        )
        return SubmitActionResponse(success=False)


@app.post("/sessions/{session_id}/stop", response_model=StopRunResponse)
async def stop_run(session_id: str):
    rs = RUNTIME.get(session_id)
    if not rs or not rs.runner_task:
        raise HTTPException(
            status_code=404, detail="No active runner for this session."
        )
    rs.stop_event.set()
    rs.runner_task.cancel()

    global_state = GLOBAL_STATE_HANDLER.get_session(session_id)
    global_state.mark_cancelled()
    await GLOBAL_STATE_HANDLER.aupdate_session(session_id, global_state)

    if rs.pw is not None:
        await rs.pw.stop()
    for pid in rs.pids:
        try:
            os.kill(pid, 15)
        except Exception:
            pass

    # clean up storage state json file
    if rs.storage_state_path:
        Path(rs.storage_state_path).unlink(missing_ok=True)

    try:
        if rs.sink is not None:
            await rs.sink.close()
    except Exception:
        pass
    return StopRunResponse(session_id=session_id, status="stopping")


@app.get("/sessions/{session_id}/state")
async def get_state(session_id: str):
    try:
        current_global_state = await GLOBAL_STATE_HANDLER.aget_session(session_id)
    except Exception as e:
        raise HTTPException(status_code=404, detail="Unknown session_id")

    return current_global_state.model_dump()


@app.get("/sessions/{session_id}/stream")
async def stream(session_id: str):
    """
    SSE endpoint that streams everything queued into the per-session sink.
    Each event is JSON-encoded on the 'data:' line.
    """
    # Verify session exists
    try:
        _ = await GLOBAL_STATE_HANDLER.aget_session(session_id)
    except Exception:
        raise HTTPException(status_code=404, detail="Unknown session_id")

    rs = ensure_runtime_session(session_id)
    _ensure_sink(rs)  # make sure we have a sink even if runner hasn't started yet

    async def event_gen():
        try:
            yield "event: helloworld\ndata: {}\n\n"
            heartbeat = asyncio.create_task(asyncio.sleep(15))

            while True:
                item_task = asyncio.create_task(rs.sink.get("stream"))
                done, pending = await asyncio.wait(
                    {item_task, heartbeat}, return_when=asyncio.FIRST_COMPLETED
                )

                if heartbeat in done:
                    yield ": ping\n\n"
                    heartbeat = asyncio.create_task(asyncio.sleep(15))

                if item_task in done:
                    item = item_task.result()

                    if item is None:
                        break

                    # Don't stream Agno's internal system and user messages to frontend
                    if item.type in [StreamType.SYSTEM, StreamType.USER]:
                        continue

                    try:
                        payload = json.dumps(jsonable_encoder(item))
                    except Exception:
                        payload = json.dumps({"message": str(item)})
                    yield f"data: {payload}\n\n"
                else:
                    item_task.cancel()
                    try:
                        await item_task
                    except asyncio.CancelledError:
                        pass

        except asyncio.CancelledError:
            raise

    return StreamingResponse(event_gen(), media_type="text/event-stream")

@app.get("/sessions/{session_id}/resume", response_model=ResumeResponse)
async def resume(session_id: str):
    """
    Resume agentic workflow.
    """

    rs = ensure_runtime_session(session_id=session_id)
    rs.pw.resume()

    return ResumeResponse(session_id=session_id, status="resuming")

@app.get("/health")
def health():
    return "ok"


async def main():
    """For running locally and debugging without frontend. 

    FastAPI tends to suppress some error messages, making it difficult to debug.
    Run locally using `python -m server.server` and interact via the terminal for better debugging.
    """

    from server.sink import consume_sink

    sink = None
    sink_task = None
    token = None

    try:
        # target = await asyncio.to_thread(input, "Enter target: ")
        # goal = await asyncio.to_thread(input, "Enter goal: ")
        stream_to_cli = (DEBUG_MODE==False)
        logger.info('DEBUG_MODE=False, streaming output to CLI for debugging purposes.') if stream_to_cli else logger.info('DEBUG_MODE=True, not streaming output to CLI since Agno will do it.')
        logger.info('Running server.py in command line without uvicorn. This is for local debugging purposes.')
        target=input("Enter target: ")
        goal=input("Enter goal: ")
        session_id = await initialize_new_session(
            CreateSessionRequest(
            target=target,
            goal=goal,
            model="litellm_proxy/csg.anthropic.claude-sonnet-4-20250514-v1:0",
            )
        )
        
        rs = ensure_runtime_session(session_id)
        _ensure_sink(
            rs, 
            # to stream to CLI, we need the QueueSink active (is_without_frontend=False). Else, only the DB sink is active (is_without_frontend=True).
            is_without_frontend=(stream_to_cli is False) 
            ) 
        
        # Needs to be consumed to print to CLI
        if stream_to_cli and 'stream' in rs.sink._sinks: 
            asyncio.create_task(consume_sink(rs.sink._sinks['stream']))

        if not rs.runner_task or rs.runner_task.done():
            rs.stop_event.clear()
            rs.runner_task = asyncio.create_task(
                _run_with_sink_context(session_id, rs)
                )
        try:
            await rs.runner_task
        except asyncio.CancelledError:
            logger.warning(
                f"[Session_id: {session_id}] Runner cancelled, shutting down gracefully"
            )

    finally:
        try:
            if rs.sink is not None:
                await rs.sink.close()
        except Exception:
            pass
        if token is not None:
            try:
                current_sink.reset(token)
            except Exception:
                pass


if __name__ == "__main__":
    asyncio.run(main())
