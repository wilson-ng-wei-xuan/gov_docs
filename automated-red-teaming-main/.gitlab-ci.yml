workflow:
  rules:
    # If there is an open MR, don't create a branch (push) pipeline
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_OPEN_MERGE_REQUESTS'
      when: never
    # Run for MR pipelines
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    # Otherwise run for normal branch pushes
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH'
stages: [build, deploy]

variables:
  DOCKER_TLS_CERTDIR: ""
  DOCKER_DRIVER: overlay2

# üîê Secure OIDC -> AWS creds (no echo, no xtrace)
.aws_oidc: &aws_oidc
  id_tokens:
    GITLAB_OIDC_TOKEN:
      aud: https://sgts.gitlab-dedicated.com
  before_script:
    - set -eo pipefail
    - '{ set +x; } 2>/dev/null'
    # Ensure AWS CLI exists (build job uses docker:27.1.2 which lacks aws)
    - |
      if ! command -v aws >/dev/null 2>&1; then
        (apk add --no-cache aws-cli jq) || \
        (apt-get update -y && apt-get install -y awscli jq) || \
        (yum install -y awscli jq) || true
      fi
    - |
      CREDS="$(aws sts assume-role-with-web-identity \
        --role-arn "$ROLE_ARN" \
        --role-session-name "gitlab-$CI_PROJECT_ID-$CI_PIPELINE_ID" \
        --web-identity-token "$GITLAB_OIDC_TOKEN" \
        --duration-seconds 3600 \
        --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
        --output text)"
      IFS=' ' set -- $CREDS
      export AWS_ACCESS_KEY_ID="$1" AWS_SECRET_ACCESS_KEY="$2" AWS_SESSION_TOKEN="$3" AWS_DEFAULT_REGION="$AWS_REGION"
      unset CREDS GITLAB_OIDC_TOKEN
    - aws sts get-caller-identity

# --- FE build ---
fe_build:
  stage: build
  image: node:20-alpine
  cache:
    key: "node-modules"
    paths: [node_modules/]
  before_script:
    - cd frontend
    - corepack enable || true
  script:
    - npm ci
    - npm run build
    - tar -C dist -czf dist.tgz .
  artifacts:
    name: "fe-${CI_COMMIT_REF_SLUG}-${CI_COMMIT_SHORT_SHA}"
    when: always
    expire_in: 7 days
    paths: [frontend/dist.tgz]
  rules:
    # Run when FE changes‚Ä¶ but only for the active pipeline type
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      #changes: [ "frontend/**/*" ]
    - if: '$CI_PIPELINE_SOURCE == "push"'
      #changes: [ "frontend/**/*" ]
    - when: never

# --- FE deploy (SSM pulls artifact from GitLab) ---
fe_deploy:
  stage: deploy
  image:
    name: public.ecr.aws/aws-cli/aws-cli:latest
    entrypoint: [ "" ]
  needs: [fe_build]   # download link will point to fe_build artifact
  variables:
    # which directory on the instance to deploy to
    FE_WEBROOT: "/var/www/app"
    # name of the build job whose artifact we fetch
    FE_BUILD_JOB: "fe_build"
  id_tokens:
    GITLAB_OIDC_TOKEN:
      aud: https://sgts.gitlab-dedicated.com
  <<: *aws_oidc
  script:
    - |
      # Decide target Owner just like your BE deploy (main vs pusher)
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        DEV_USER="main"; ENV="prod";
      else
        ENV="dev";
        # Derive DEV_USER from CI_COMMIT_AUTHOR (display name only), lowercase & sanitize
        _author_name="$(printf '%s' "$CI_COMMIT_AUTHOR" | sed 's/ <.*$//; s/^[[:space:]]*//; s/[[:space:]]*$//')"
        _author_lc="$(printf '%s' "$_author_name" | tr '[:upper:]' '[:lower:]')"
        DEV_USER="$(printf '%s' "$_author_lc" | sed 's/[^a-z0-9._-]/-/g; s/-\{2,\}/-/g; s/^-//; s/-$//')"
      fi
      echo "Deploy FE as Owner=$DEV_USER Env=$ENV"
      # GitLab artifact URL for the *fe_build* job at this ref (protected by JOB-TOKEN)
      FE_BUILD_JOB_ID=$(
        curl -fsSL -H "JOB-TOKEN: $CI_JOB_TOKEN" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines/$CI_PIPELINE_ID/jobs?per_page=100" \
        | jq -r '.[] | select(.name=="fe_build") | .id' | head -n1
      )
      : "${FE_BUILD_JOB_ID:?fe_build job not found in this pipeline}"
      echo "fe_build job id: $FE_BUILD_JOB_ID"
      ART_URL="${CI_SERVER_URL}/api/v4/projects/${CI_PROJECT_ID}/jobs/${FE_BUILD_JOB_ID}/artifacts/frontend/dist.tgz"
      echo $ART_URL
      # 1) Build SSM parameters (no crazy escaping)
      cat > ssm.json <<EOF
      {
        "commands": [
          "set -e",
          "TMP=/tmp/dist.tgz",
          "curl --location -fsSL -H \"JOB-TOKEN: $CI_JOB_TOKEN\" \"$ART_URL\" -o \"\$TMP\"",
          "sudo tar -xzf \"\$TMP\" -C \"$FE_WEBROOT\" --strip-components=1",
          "sudo nginx -t",
          "sudo systemctl reload nginx",
          "echo OK"
        ]
      }
      EOF
      
      INSTANCE_ID=$(aws ec2 describe-instances \
       --filters "Name=tag:App,Values=aipt/maya" "Name=tag:Env,Values=$ENV" "Name=tag:Owner,Values=$DEV_USER" "Name=instance-state-name,Values=running" \
       --query 'Reservations[].Instances[0].InstanceId' --output text)
      echo "Deploying to $INSTANCE_ID"
      
      # 2) Send the command to that one instance
      CMD_ID=$(aws ssm send-command \
        --document-name AWS-RunShellScript \
        --instance-ids "$INSTANCE_ID" \
        --parameters file://ssm.json \
        --query 'Command.CommandId' --output text)
      
      echo "SSM CommandId: $CMD_ID"
      
      # 3) Wait for completion and fail the job if it failed
      while :; do
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$CMD_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'Status' --output text 2>/dev/null || echo "Pending")
        echo "Status: $STATUS"
        case "$STATUS" in
          Pending|InProgress|Delayed) sleep 2 ;;
          Success) break ;;
          Failed|Cancelled|TimedOut)
            echo "----- STDOUT -----"
            aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text || true
            echo "----- STDERR -----"
            aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query 'StandardErrorContent'  --output text || true
            exit 1
            ;;
          *) echo "Unknown status: $STATUS"; exit 1 ;;
        esac
      done
      
      echo "‚úÖ FE deploy completed on $INSTANCE_ID"
  rules:
    # Run when FE changes‚Ä¶ but only for the active pipeline type
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      #changes: [ "frontend/**/*" ]
    - if: '$CI_PIPELINE_SOURCE == "push"'
      #changes: [ "frontend/**/*" ]
    - when: never

be_build:
  stage: build
#  tags: ["aipt-maya"]
  image: docker:27.1.2
  before_script:
    - yum install -y docker >/dev/null   # CLI only; daemon is the host via socket
  variables:
    DOCKER_BUILDKIT: "1"
  <<: *aws_oidc
  script:
    - |
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        DEV_USER="main"
      else
        # Derive DEV_USER from CI_COMMIT_AUTHOR (display name only), lowercase & sanitize
        _author_name="$(printf '%s' "$CI_COMMIT_AUTHOR" | sed 's/ <.*$//; s/^[[:space:]]*//; s/[[:space:]]*$//')"
        _author_lc="$(printf '%s' "$_author_name" | tr '[:upper:]' '[:lower:]')"
        DEV_USER="$(printf '%s' "$_author_lc" | sed 's/[^a-z0-9._-]/-/g; s/-\{2,\}/-/g; s/^-//; s/-$//')"
        echo "DEV_USER=$DEV_USER"
      fi
    - >
      aws ecr get-login-password --region "$AWS_REGION" |
      docker login --username AWS --password-stdin "648618456143.dkr.ecr.ap-southeast-1.amazonaws.com"
    - ECR_URI="648618456143.dkr.ecr.ap-southeast-1.amazonaws.com/aipt/maya"
    - echo "$CI_JOB_TOKEN" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin
    - docker build -f Dockerfile-BE -t "$ECR_URI:$DEV_USER-latest" .
    - docker push "$ECR_URI:$DEV_USER-latest"
  rules:
    # Run when BE changes‚Ä¶ but only for the active pipeline type
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      #changes: [ "pentestagent-workflow/**/*" ]
    - if: '$CI_PIPELINE_SOURCE == "push"'
      #changes: [ "pentestagent-workflow/**/*" ]
    - when: never

be_deploy:
  stage: deploy
#  tags: ["aipt-maya"]
  image:
    name: public.ecr.aws/aws-cli/aws-cli:latest
    entrypoint: [""]
  needs: [be_build]
  before_script:
    - yum install -y docker >/dev/null   # CLI only; daemon is the host via socket
  variables:
    DOCKER_BUILDKIT: "1"
  <<: *aws_oidc
  script:
    - |
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        DEV_USER="main"
        ENV="prod"
      else
        _author_name="$(printf '%s' "$CI_COMMIT_AUTHOR" | sed 's/ <.*$//; s/^[[:space:]]*//; s/[[:space:]]*$//')"
        _author_lc="$(printf '%s' "$_author_name" | tr '[:upper:]' '[:lower:]')"
        DEV_USER="$(printf '%s' "$_author_lc" | sed 's/[^a-z0-9._-]/-/g; s/-\{2,\}/-/g; s/^-//; s/-$//')"
        echo "DEV_USER=$DEV_USER"
        ENV="dev"
      fi
      TAG="$DEV_USER-latest"   # or "$DEV_USER-$CI_COMMIT_SHORT_SHA" for immutable
      
      INSTANCE_ID=$(aws ec2 describe-instances \
       --filters "Name=tag:App,Values=aipt/maya" "Name=tag:Env,Values=$ENV" "Name=tag:Owner,Values=$DEV_USER" "Name=instance-state-name,Values=running" \
       --query 'Reservations[].Instances[0].InstanceId' --output text)
      # Build SSM params to run your deploy script with $TAG
      cat > ssm.json <<EOF
      {
        "commands": [
          "/bin/bash -lc '/home/ubuntu/deploy.sh $TAG'"
        ]
      }
      EOF

      echo "Sending SSM command to $INSTANCE_ID ‚Ä¶"
      CMD_ID=$(aws ssm send-command \
        --document-name AWS-RunShellScript \
        --instance-ids "$INSTANCE_ID" \
        --parameters file://ssm.json \
        --query 'Command.CommandId' --output text)

      echo "SSM CommandId: $CMD_ID"

      # Wait for terminal state
      while :; do
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$CMD_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'Status' --output text 2>/dev/null || echo "Pending")
        echo "Status: $STATUS"
        case "$STATUS" in
          Pending|InProgress|Delayed) sleep 2 ;;
          Success) break ;;
          Failed|Cancelled|TimedOut)
            echo "----- STDOUT -----"
            aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" \
              --query 'StandardOutputContent' --output text || true
            echo "----- STDERR -----"
            aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" \
              --query 'StandardErrorContent' --output text || true
            exit 1
            ;;
          *) echo "Unknown status: $STATUS"; exit 1 ;;
        esac
      done

      # Fetch outputs and assert success marker is present
      STDOUT=$(aws ssm get-command-invocation \
        --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" \
        --query 'StandardOutputContent' --output text)
      STDERR=$(aws ssm get-command-invocation \
        --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" \
        --query 'StandardErrorContent' --output text)

      echo "----- STDOUT -----"; printf '%s\n' "$STDOUT"
      echo "----- STDERR -----"; printf '%s\n' "$STDERR"

      # Accept if stdout contains the success line your script prints.
      # We check for both the word "Deployed" and the current $TAG to be strict.
      if printf '%s' "$STDOUT" | grep -q 'Deployed' && printf '%s' "$STDOUT" | grep -q "$TAG"; then
        echo "‚úÖ Deploy reported success (found 'Deployed' and '$TAG' in stdout)."
      else
        echo "‚ùå Deploy did not report success. Expected a line like: 'Deployed <image-for-$TAG>'."
        exit 1
      fi
  rules:
    # Run when BE changes‚Ä¶ but only for the active pipeline type
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      #changes: [ "pentestagent-workflow/**/*" ]
    - if: '$CI_PIPELINE_SOURCE == "push"'
      #changes: [ "pentestagent-workflow/**/*" ]
    - when: never
